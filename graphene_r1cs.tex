\section{Performance Evaluation}\label{sec:performancecompare} 
In Appendix ~\ref{sec:graphener1cs}, we present complete protocol for an R1CS
instance. Here we summarize several performance parameters attained by our protocol for 
R1CS with $N$ variables. Let $N= pms$, $\ell = s+t$ and $h$ be as in the previous sections. Let $\cfop$ denote the time taken for a field operation, $\cfft(x)$ denote the time to compute $\fft$ of a $x$ length vector, $\cmexp(x)$ denote the time taken for a multiexponentiation of length $x$, and $\cexp$ denote the time required for an exponentiation. Let $\bitsF$ and $\bitsG$ denote the number of bits required to represent an element of $\FF$ and $\GG$ respectively. Our protocol $\name$ achieves following efficiency parameters: 

%<<<<<<< HEAD
%We now summarize several performance parameters attained by our protocol for circuit
%size $N$ and soundness $2^{-\secpar}$. Let $N=pms$, $\ell=s+t$ and $h$ be as in
%previous sections. Let $\cfop$ denote the time taken for a field operation,
%$\cfft(x)$ denote the time to compute $\fft$ of a length $x$ vector, $\cmexp(x)$
%denote the time taken for a multiexponentiation of length $x$, and $\cexp$
%denote the time required for an exponentiation. Let $\bitsF$ and $\bitsG$ denote
%the number of bits required to represent an element of $\FF$ and $\GG$
%respectively. Our protocol $\name$ achieves
%following efficiency parameters:
%=======
\begin{comment}
\section{Performance Evaluation}\label{sec:performancecompare}
We now summarize several performance parameters attained by our protocol for circuit
size $N$ and soundness $2^{-\secpar}$. Let $N=pms$, $\ell=s+t$ and $h$ be as in
previous sections. Let $\cfop$ denote the time taken for a field operation,
$\cfft(x)$ denote the time to compute $\fft$ of a length $x$ vector, $\cmexp(x)$
denote the time taken for a multiexponentiation of length $x$, and $\cexp$
denote the time required for an exponentiation. Let $\bitsF$ and $\bitsG$ denote
the number of bits required to represent an element of $\FF$ and $\GG$
respectively. Our protocol $\name$ achieves
following efficiency parameters:
>>>>>>> 23d366f2e2ed1d9aa1e813a97eaeee4f95db57a1
\end{comment}
\begin{comment}
{\footnotesize
\begin{align*}
\begin{array}{llrl}
\mathrm{number\ of\ rounds} & \zkrounds & = & O(\log{N}) \\
& & & \\
\mathrm{argument\ size} & \zkcomm & = & 4pt\bitsF \\
& & & +(4pt+8t\log{m}+4\ell+s+8t+4)\bitsG \\
& & & \\
\mathrm{prover\ complexity} & t_\prover & = &
4p((m+n)\cfft(m)+m\cfft(l) \\
& & &+n\cfft(h) + 4p\ell\cmexp(m)\\
& & &+(n-\ell)\cmexp(\min(\ell,m))\\
& & & +(s+3\ell)\cmexp(2m)\\
& & &+ (48tm+32m)\cexp \\
& & & \\
\mathrm{verifier\ complexity} & t_\verifier & = &
O(N)\cfop + 4pm\cfft(s)\\ 
& & & +(2t+2)\cmexp(2m)\\
& & & +2t\cmexp(m)+t\cmexp(4p+\ell) \\
& & & \\
\mathrm{soundness\ error} & \kappa_{\rm gr} & = & (1-e/n)^t \\ 
& & & +2\big(2m/h+(1-2m/h)(2\ell+e)/n\big)^t 
\end{array}
\end{align*}
}
\end{comment}
\begin{itemize}
\item {\em Number of rounds}: $\zkrounds=O(\log{N})$.
\item {\em Argument size}: $\zkcomm= 4pt\bitsF$
$+(4pt+8t\log{m}+4\ell+s+8t+4)\bitsG$.
\item {\em Prover complexity}: $t_\prover=4p((m+n)\cfft(m)+m\cfft(l)$
$+n\cfft(h) + 4p\ell\cmexp(m)$
 $+(n-\ell)\cmexp(\min(\ell,m))$
 $+(s+3\ell)\cmexp(2m)$ $+ (48tm+32m)\cexp$
\item {Verifier complexity}:  $t_\verifier=O(N)\cfop + 4pm\cfft(s)$
 $+(2t+2)\cmexp(2m)$
 $+2t\cmexp(m)+t\cmexp(4p+\ell)$
\item{Soundness error} $\kappa_{\rm gr} = (1-e/n)^t$
 $+2\big(2m/h+(1-2m/h)(2\ell+e)/n\big)^t$.
\end{itemize}

In Appendix ~\ref{sec:performance}, we give similar expressions for Ligero and
Bulletproofs protocols. 
%\item {\bf Argument Size}: $8pt+8t\log{m}+4\ell+s+8t+4\log{m}+4$, where $4pt$ comes as part
%of oracle openings, another $4pt$ from opening $t$ vectors
%$W_u=\ewit[\cdot,j_u,k_u]$, $u\in [t]$ of size $4p$ each, $(4t+2)(2\log{m}+2)$ from
%the $4t+2$ inner product subprotocols ($2t+1$ in linear and quadratic check
%each), $\ell+(s+\ell)+2\ell$ from the commitments sent for proximity check,
%linear check and quadratic check.
%\item {\bf Verifier Complexity}:
%$O(N)+(2t+2)\mexp(2m)+2t\mexp(m)+t(\mexp(4p+\ell))$. The first
%term comes from computing $r_{lc}^TW$ and the second term comes from
%verification in inner product subprotocols, and the last term comes from
%checking the proximity check equations.
%\item {\bf Prover Complexity}: Encoding the witness involves
%$4p\big(m(\cfft(\ell)+\cfft(m))+n(\cfft(m)+\cfft(h))\big)$ operations in $\FF$ , 
%constructing the oracle takes
%$4p\big(\ell\mexp(m)+(n-\ell)\mexp(\min(\ell,m))\big)$, commiting ``P'' matrices
%take a further $(s+\ell)\mexp(2m)+2\ell\mexp(2m)$, the inner product
%subprotocols account for $(2t+2).16m + 2t.8m$ exponentiations. This gives a
%total of $O(N\log{N})$ field ops +
%$4p\big(\ell\mexp(m)+(n-\ell)\mexp(\min(\ell,m))\big)+(s+3\ell)\mexp(2m)$ +
%$(48tm+32m)$ exps.

%\item {\bf Soundness}: The soundness is given by:
%\begin{equation*}
%\kappa_{gr} :=
%\left(1-\frac{e}{n}\right)^t+2\left(\frac{2m}{h}+\left(1-\frac{2m}{h}\right)\left(\frac{2\ell+e}{n}\right)\right)^t
%\end{equation*}
%\end{enumerate}

For $c\geq 2$, setting $p=s=O(N^{1/c})$, $m=O(N^{1-2/c})$, $t=O(\secpar)$,
$n=O(\ell)$ and $h=O(m)$, we get $\kappa_{gr}=\negl(\secpar)$ with argument size
$O(N^{1/c})$, verifier's complexity as $O(N)$ field operations and
$O(N^{1-2/c})$ exponentiations. 

\begin{figure}[!]
\centering
\resizebox{.5\textwidth}{!}{
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
\hline
$N$ & \multicolumn{3}{|c|}{Arg. Size($\zkcomm$) MB} &
        \multicolumn{3}{|c|}{Verifier Time($t_\verifier$) sec} &
        \multicolumn{3}{|c|}{Prover Time($t_\prover$) sec} \\
\hline
 & \textsf{G} & \textsf{L} & \textsf{B} &
   \textsf{G} & \textsf{L} & \textsf{B} &
   \textsf{G} & \textsf{L} & \textsf{B} \\
\hline
$2^{19}$ & 0.728 & 3.5 & 0.001 & 43.0 & 3.0 & 89.1 & 802 & 137 & 662 \\
$2^{20}$ & 0.759 & 4.9 & 0.001 & 45.2 & 6.5 & 178.2 & 1514 & 291 & 1324 \\
$2^{21}$ & 0.884 & 6.95 & 0.001 & 46.7 & 13.1 & 356.5 & 2877 & 582 & 2648 \\
$2^{22}$ & 1.28  & 9.8 & 0.001 & 88.5 & 28.3 & 713 & 5558 & 1258 & 5297 \\
$2^{23}$ & 1.31  & 13.8 & 0.001 & 97.4 & 56.6 & 1426 & 10757 & 2516 & 10595 \\
$2^{24}$ & 1.34  & 19.5 & 0.001 & 115 & 120 & 2852 & 20878 & 5044 & 21190 \\
\hline
\end{tabular}
}
\caption{Comparison of Graphene(G), Ligero(L) and Bulletproofs(B) in single
prover setting for 80 bits of security}
\label{fig:standalonecompare}
\end{figure}


In Figure ~\ref{fig:standalonecompare}, we compare
$\name$ with Ligero ~\cite{ligero} and Bulletproofs ~\cite{bulletproofs} in
single prover setting based on the expressions in Appendix
~\ref{sec:performance}. The concrete estimates were obtained by timing the $\fft$
operations, exponentiations and multiexponentiations for different sizes, in a
single threaded setting using $\mathsf{libff}$ library. Parameters for $\name$ were optimized to yield best
proving time, while those for Ligero were optimized to yield best proof size.
From the table in Figure ~\ref{fig:standalonecompare}, we see that our protocol offers much more practical argument
sizes compared to Ligero, while still attaining low verifier complexity. Our
proofs are two orders of magnitude larger than those in Bulletproofs, but our
verifier is much more efficient. As such our construction offers a balance
between prover and verifier efficiency of Ligero, and succinct argument size of
Bulletproofs. Moreover, as discussed in the paper, our construction allows
efficient distributed proof generation, with sublinear communication between the
provers and the aggregator. 
