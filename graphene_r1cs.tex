\section{Graphene for R1CS}\label{sec:graphener1cs}
We use the linear and quadratic check protocols from Section \ref{sec:graphene}
to describe an efficient protocol for rank one constraint system (R1CS). Let 
$A,B$ and $C$ be $M\times N$ matrices. We prove existence of $\wit\in \FF^N$
satisfying $A\wit\circ B\wit=C\wit$ by showing existence of
$\wit_x,\wit_y,\wit_z$ and $\wit\in \FF^N$ satisfying the linear relations $A\wit=\wit_x$,
$B\wit=\wit_y$ and $C\wit=\wit_z$ and a quadractic relation
$\wit_x\circ\wit_y=\wit_z$. We probabilistically reduce the three linear
relations to the linear relation:
\begin{align}\label{eq:comblincheck}
\begin{bmatrix}
\gamma_xI\,|\gamma_yI\,|\gamma_zI\,|-(\gamma_xA+\gamma_yB+\gamma_zC)
\end{bmatrix}\begin{bmatrix}
\wit_x\\
\wit_y\\
\wit_z\\
\wit
\end{bmatrix}=\bm{0}
\end{align}
for $\gamma_x,\gamma_y,\gamma_z\sample \FF$. As before, we
$\wit_x,\wit_y,\wit_z$ and $\wit$ as $p\times m\times s$ matrices. Let $\bwit$
denote the $4p\times m\times s$ matrix formed by stacking $\wit_x,\wit_y,\wit_z$
and $\wit$ along ``slices''. The encoding $\ewit\gets\enc(\bwit)$ and commitment to
the encoding $\comoracle\gets \comm(\ewit)$ are computed as in Sections
~\ref{sec:witencoding} and ~\ref{sec:construct_oracle}. Note that
$\comoracle$ is a $4p\times n$ matrix. 
We now present the high level protocol for R1CS instance $(A,B,C)$.\smallskip

{\small
\noindent{$\grapheneRCS(\mathsf{pp},A,B,C,[\pi];\wit_x,\wit_y,\wit_z,\wit)$}:\\
\noindent{\bf Relation}: $A\wit\circ B\wit=C\wit$. \\
\noindent{\bf Oracle Setup}: Compute $\comoracle$ as described above. Set $\pi
:= \comoracle$.
\begin{enumerate}[{\rm 1.}]
\item $\verifier\rightarrow\prover$: $\gamma_x,\gamma_y,\gamma_z\sample \FF$,
$r_{lc}\sample \FF^M$, $r_{qd}\sample \FF^{p}$, $\rho\sample \FF^{4p}$.
\item $\prover\rightarrow\verifier$: $\prover$ computes $\tilde{U}=\sum_{i\in
[4p]}\rho_i\ewit[i,\cdot,\cdot]$ and sends commitments
$\tilde{c}_1,\ldots,\tilde{c}_\ell$ to $\tilde{U}$.
\item $\prover\leftrightarrow\verifier$ compute: $R=r_{lc}^TW$ for
$W=[\gamma_xI\,||\gamma_yI\,||\gamma_zI\,||-(\gamma_xA+\gamma_yB+\gamma_zC)]$,
 polynomials $R^i$,$i\in [4p]$ interpolating the slices of $R$ viewed as a
$4p\times m\times n$ matrix.
\item $\prover$ computes: 
\begin{itemize}
\item Polynomials $Q^i_x,Q^i_y,Q^i_z,Q^i$ for $i\in [p]$,
where polynomials $Q^i_a$, $i\in [p]$ correspond to $\wit_a$ for $a\in \{x,y,z\}$ and
polynomials $Q^i$,$i\in [p]$ correspond to $\wit$. 
\item $h\times n$ matrices $P_{lc}$ and $P_{qd}$ as ``P'' matrices for the linear check and
quadratic check respectively. Note that $p_j$ polynomial for $P_{lc}$ is given
by $p_j(\cdot)=\sum_{i=1}^p(R^i(\alpha_j,\cdot).Q_x^i(\alpha_j,\cdot)+
 R^{p+i}(\alpha_j,\cdot)Q^i_y(\alpha_j,\cdot)+R^{2p+i}(\alpha_j,\cdot)Q^i_z(\alpha_j,\cdot)+
R^{3p+i}(\alpha_j,\cdot)Q^i(\alpha_j,\cdot))$. The $p_j$ polynomials for the
matrix $P_{qd}$ are given by
$p_j(\cdot)=\sum_{i=1}^{p}r_{qd}[i](Q^i_x(\alpha_j,\cdot)Q^i_y(\alpha_j,\cdot)-Q^i_z(\alpha_j,\cdot))$.
\item Blinding vectors $U_{lc},U_{qd}\in \FF^{2m-1}$ for linear and quadratic check protocols
respectively, and commitments $c_0,d_0$ to vectors $U_{lc}$
and $U_{qd}$.
\end{itemize}
\item $\prover\rightarrow\verifier$: Commitments $c_0,c_1,\ldots,c_{s+\ell-1}$ for
the matrix $P_{lc}$ and commitments $d_0,d_1,\ldots,d_{2\ell-1}$ for matrix
$P_{qd}$. 
\item $\verifier\rightarrow\prover$: $Q=\{(j_u,k_u):u\in [t]\}$.
\item $\verifier\rightarrow\pi$: $\{k_u:u\in [t]\}$.
\item $\prover\rightarrow\verifier$: $V_u=\ewit[\cdot,j_u,k_u]$ for $u\in [t]$.
\item $\pi\rightarrow\verifier$: $\pi[\cdot,k_u]$, $u\in [t]$.
\item $\prover$ and $\verifier$ run the linear and quadratic check protocols in
parallel, parsing the vectors $V_u$ into $X_u,Y_u,Z_u,W_u$ as needed.
\item Check proximity as: $\prod_{a=1}^\ell
(\tilde{c}_a)^{\Lambda_{n,\ell}^T[a,k_u]}=\prod_{i=1}^{4p}(\pi[i,k_u])^{\rho_i}$ for $u\in [t]$.
\item $\verifier$ accepts if all the subprotocols accept.
\end{enumerate}
}
\smallskip
\section{Performance Evaluation}\label{sec:performancecompare} We now summarize several performance parameters attained by our protocol for circuit of size $N$ and soundness $2^{-\secpar}$. Let $N= pms$, $\ell = s+t$ and $h$ be as in the previous sections. Let $\cfop$ denote the time taken for a field operation, $\cfft(x)$ denote the time to compute $\fft$ of a $x$ length vector, $\cmexp(x)$ denote the time taken for a multiexponentiation of length $x$, and $\cexp$ denote the time required for an exponentiation. Let $\bitsF$ and $\bitsG$ denote the number of bits required to represent an element of $\FF$ and $\GG$ respectively. Our protocol $\name$ achieves following efficiency parameters: 

%<<<<<<< HEAD
%We now summarize several performance parameters attained by our protocol for circuit
%size $N$ and soundness $2^{-\secpar}$. Let $N=pms$, $\ell=s+t$ and $h$ be as in
%previous sections. Let $\cfop$ denote the time taken for a field operation,
%$\cfft(x)$ denote the time to compute $\fft$ of a length $x$ vector, $\cmexp(x)$
%denote the time taken for a multiexponentiation of length $x$, and $\cexp$
%denote the time required for an exponentiation. Let $\bitsF$ and $\bitsG$ denote
%the number of bits required to represent an element of $\FF$ and $\GG$
%respectively. Our protocol $\name$ achieves
%following efficiency parameters:
%=======
\begin{comment}
\section{Performance Evaluation}\label{sec:performancecompare}
We now summarize several performance parameters attained by our protocol for circuit
size $N$ and soundness $2^{-\secpar}$. Let $N=pms$, $\ell=s+t$ and $h$ be as in
previous sections. Let $\cfop$ denote the time taken for a field operation,
$\cfft(x)$ denote the time to compute $\fft$ of a length $x$ vector, $\cmexp(x)$
denote the time taken for a multiexponentiation of length $x$, and $\cexp$
denote the time required for an exponentiation. Let $\bitsF$ and $\bitsG$ denote
the number of bits required to represent an element of $\FF$ and $\GG$
respectively. Our protocol $\name$ achieves
following efficiency parameters:
>>>>>>> 23d366f2e2ed1d9aa1e813a97eaeee4f95db57a1
\end{comment}
{\footnotesize
\begin{align*}
\begin{array}{llrl}
\mathrm{alphabet} & \Sigma & = & \FF \\
& & & \\
\mathrm{number\ of\ rounds} & \zkrounds & = & O(\log{N}) \\
& & & \\
\mathrm{argument\ size} & \zkcomm & = & 4pt\bitsF \\
& & & +(4pt+8t\log{m}+4\ell+s+8t+4)\bitsG \\
& & & \\
\mathrm{prover\ complexity} & t_\prover & = &
4p((m+n)\cfft(m)+m\cfft(l) \\
& & &+n\cfft(h) + 4p\ell\cmexp(m)\\
& & &+(n-\ell)\cmexp(\min(\ell,m))\\
& & & +(s+3\ell)\cmexp(2m)\\
& & &+ (48tm+32m)\cexp \\
& & & \\
\mathrm{verifier\ complexity} & t_\verifier & = &
O(N)\cfop + (2t+2)\cmexp(2m)\\
& & & +2t\cmexp(m)+t\cmexp(4p+\ell) \\
& & & \\
\mathrm{soundness\ error} & \kappa_{\rm gr} & = & (1-e/n)^t \\ 
& & & +\big(2m/h+(1-2m/h)(2\ell+e)/n\big)^t 
\end{array}
\end{align*}
}

We give details in the Appendix, on how we compute the above parameters.
\pnote{No details are given in the appendix} \pdnote{Nitin Do we want to mention the actual parameter settings for each of the rows? are these numbers for bulletproof correct? Do we want to also mention efficiency parameters for other protocols in appendix?}
%\begin{enumerate}
%\item {\bf Argument Size}: $8pt+8t\log{m}+4\ell+s+8t+4\log{m}+4$, where $4pt$ comes as part
%of oracle openings, another $4pt$ from opening $t$ vectors
%$W_u=\ewit[\cdot,j_u,k_u]$, $u\in [t]$ of size $4p$ each, $(4t+2)(2\log{m}+2)$ from
%the $4t+2$ inner product subprotocols ($2t+1$ in linear and quadratic check
%each), $\ell+(s+\ell)+2\ell$ from the commitments sent for proximity check,
%linear check and quadratic check.
%\item {\bf Verifier Complexity}:
%$O(N)+(2t+2)\mexp(2m)+2t\mexp(m)+t(\mexp(4p+\ell))$. The first
%term comes from computing $r_{lc}^TW$ and the second term comes from
%verification in inner product subprotocols, and the last term comes from
%checking the proximity check equations.
%\item {\bf Prover Complexity}: Encoding the witness involves
%$4p\big(m(\cfft(\ell)+\cfft(m))+n(\cfft(m)+\cfft(h))\big)$ operations in $\FF$ , 
%constructing the oracle takes
%$4p\big(\ell\mexp(m)+(n-\ell)\mexp(\min(\ell,m))\big)$, commiting ``P'' matrices
%take a further $(s+\ell)\mexp(2m)+2\ell\mexp(2m)$, the inner product
%subprotocols account for $(2t+2).16m + 2t.8m$ exponentiations. This gives a
%total of $O(N\log{N})$ field ops +
%$4p\big(\ell\mexp(m)+(n-\ell)\mexp(\min(\ell,m))\big)+(s+3\ell)\mexp(2m)$ +
%$(48tm+32m)$ exps.

%\item {\bf Soundness}: The soundness is given by:
%\begin{equation*}
%\kappa_{gr} :=
%\left(1-\frac{e}{n}\right)^t+2\left(\frac{2m}{h}+\left(1-\frac{2m}{h}\right)\left(\frac{2\ell+e}{n}\right)\right)^t
%\end{equation*}
%\end{enumerate}

For $c\geq 2$, setting $p=s=O(N^{1/c})$, $m=O(N^{1-2/c})$, $t=O(\secpar)$,
$n=O(\ell)$ and $h=O(m)$, we get $\kappa_{gr}=\negl(\secpar)$ with argument size
$O(N^{1/c})$, verifier's complexity as $O(N)$ field operations and
$O(N^{1-2/c})$ exponentiations. In Figure ~\ref{fig:standalonecompare}, we compare
$\name$ with Ligero ~\cite{ligero} and Bulletproofs ~\cite{bulletproofs} in
single prover setting. The estimates were obtained by timing the $\fft$
operations, exponentiations and multiexponentiations for different sizes, in a
single threaded setting using $\mathsf{libff}$ library. Parameters for $\name$ were optimized to yeild best
proving time, while those for Ligero were optimized to yeild best proof size.
\begin{figure*}
\centering
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
\hline
$|C|$ & \multicolumn{3}{|c|}{Arg. Size($\zkcomm$) MB} &
        \multicolumn{3}{|c|}{Verifier Time($t_\verifier$) sec} &
        \multicolumn{3}{|c|}{Prover Time($t_\prover$) sec} \\
\hline
 & \textsf{G} & \textsf{L} & \textsf{B} &
   \textsf{G} & \textsf{L} & \textsf{B} &
   \textsf{G} & \textsf{L} & \textsf{B} \\
\hline
$2^{19}$ & 0.728 & 3.5 & 0.001 & 43.0 & 3.0 & 89.1 & 802 & 137 & 662 \\
$2^{20}$ & 0.759 & 4.9 & 0.001 & 45.2 & 6.5 & 178.2 & 1514 & 291 & 1324 \\
$2^{21}$ & 0.884 & 6.95 & 0.001 & 46.7 & 13.1 & 356.5 & 2877 & 582 & 2648 \\
$2^{22}$ & 1.28  & 9.8 & 0.001 & 88.5 & 28.3 & 713 & 5558 & 1258 & 5297 \\
$2^{23}$ & 1.31  & 13.8 & 0.001 & 97.4 & 56.6 & 1426 & 10757 & 2516 & 10595 \\
$2^{24}$ & 1.34  & 19.5 & 0.001 & 115 & 120 & 2852 & 20878 & 5044 & 21190 \\
\hline
\end{tabular}
\caption{Comparison of Graphene(G), Ligero(L) and Bulletproofs(B) in single
prover setting for 80 bits of security}
\label{fig:standalonecompare}
\end{figure*}

