\section{Graphene for R1CS}\label{sec:graphener1cs}
We use the linear and quadratic check protocols from Section \ref{sec:graphene}
to describe an efficient protocol for rank one constraint system (R1CS). Let 
$A,B$ and $C$ be $M\times N$ matrices. We prove existence of $\wit\in \FF^N$
satisfying $A\wit\circ B\wit=C\wit$ by showing existence of
$\wit_x,\wit_y,\wit_z$ and $\wit\in \FF^N$ satisfying the linear relations $A\wit=\wit_x$,
$B\wit=\wit_y$ and $C\wit=\wit_z$ and a quadractic relation
$\wit_x\circ\wit_y=\wit_z$. We probabilistically reduce the three linear
relations to the linear relation:
\begin{align}\label{eq:comblincheck}
\begin{bmatrix}
\gamma_xI\,|\gamma_yI\,|\gamma_zI\,|-(\gamma_xA+\gamma_yB+\gamma_zC)
\end{bmatrix}\begin{bmatrix}
\wit_x\\
\wit_y\\
\wit_z\\
\wit
\end{bmatrix}=\bm{0}
\end{align}
for $\gamma_x,\gamma_y,\gamma_z\sample \FF$. As before, we
$\wit_x,\wit_y,\wit_z$ and $\wit$ as $p\times m\times s$\pnote{It should be $p\times m\times s$ not $pmn$} matrices. Let $\bwit$
denote the $4p\times m\times s$ matrix formed by stacking $\wit_x,\wit_y,\wit_z$
and $\wit$ along ``slices''. The encoding $\ewit\gets\enc(\bwit)$ and commitment to
the encoding $\comoracle\gets \comm(\ewit)$ are computed as in Sections
~\ref{sec:witencoding} and ~\ref{sec:construct_oracle}. Note that
$\comoracle$ is a $4p\times n$ matrix. 
We now present the high level protocol for R1CS instance $(A,B,C)$.\smallskip

{\small
\noindent{$\grapheneRCS(\mathsf{pp},A,B,C,[\pi];\wit_x,\wit_y,\wit_z,\wit)$}:\\
\noindent{\bf Relation}: $A\wit\circ B\wit=C\wit$. \\
\noindent{\bf Oracle Setup}: Compute $\comoracle$ as described above. Set $\pi
:= \comoracle$.
\begin{enumerate}[{\rm 1.}]
\item $\verifier\rightarrow\prover$: $\gamma_x,\gamma_y,\gamma_z\sample \FF$,
$r_{lc}\sample \FF^M$, $r_{qd}\sample \FF^{p}$, $\rho\sample \FF^{4p}$.
\item $\prover\rightarrow\verifier$: $\prover$ computes $\tilde{U}=\sum_{i\in
[4p]}\rho_i\ewit[i,\cdot,\cdot]$ and sends commitments
$\tilde{c}_1,\ldots,\tilde{c}_\ell$ to $\tilde{U}$.
\item $\prover\leftrightarrow\verifier$ compute: $R=r_{lc}^TW$ for
$W=[\gamma_xI\,||\gamma_yI\,||\gamma_zI\,||-(\gamma_xA+\gamma_yB+\gamma_zC)]$,
 polynomials $R^i$,$i\in [4p]$ interpolating the slices of $R$ viewed as a
$4p\times m\times n$ matrix.
\item $\prover$ computes: 
\begin{itemize}
\item Polynomials $Q^i_x,Q^i_y,Q^i_z,Q^i$ for $i\in [p]$,
where polynomials $Q^i_a$, $i\in [p]$ correspond to $\wit_a$ for $a\in \{x,y,z\}$ and
polynomials $Q^i$,$i\in [p]$ correspond to $\wit$. 
\item $h\times n$ matrices $P_{lc}$ and $P_{qd}$ as ``P'' matrices for the linear check and
quadratic check respectively. Note that $p_j$ polynomial for $P_{lc}$ is given
by $p_j(\cdot)=\sum_{i=1}^p(R^i(\alpha_j,\cdot).Q_x^i(\alpha_j,\cdot)+
 R^{p+i}(\alpha_j,\cdot)Q^i_y(\alpha_j,\cdot)+R^{2p+i}(\alpha_j,\cdot)Q^i_z(\alpha_j,\cdot)+
R^{3p+i}(\alpha_j,\cdot)Q^i(\alpha_j,\cdot))$. The $p_j$ polynomials for the
matrix $P_{qd}$ are given by
$p_j(\cdot)=\sum_{i=1}^{p}r_{qd}[i](Q^i_x(\alpha_j,\cdot)Q^i_y(\alpha_j,\cdot)-Q^i_z(\alpha_j,\cdot))$.
\item Blinding vectors $U_{lc},U_{qd}\in \FF^{2m}$ for linear and quadratic check protocols
respectively, and commitments $c_0,d_0$ to vectors $U_{lc}$
and $U_{qd}$.
\end{itemize}
\item $\prover\rightarrow\verifier$: Commitments $c_0,c_1,\ldots,c_{s+\ell}$ for
the matrix $P_{lc}$ and commitments $d_0,d_1,\ldots,d_{2\ell}$ for matrix
$P_{qd}$. 
\item $\verifier\rightarrow\prover$: $Q=\{(j_u,k_u):u\in [t]\}$.
\item $\verifier\rightarrow\pi$: $\{k_u:u\in [t]\}$.
\item $\prover\rightarrow\verifier$: $V_u=\ewit[\cdot,j_u,k_u]$ for $u\in [t]$.
\item $\pi\rightarrow\verifier$: $\pi[\cdot,k_u]$, $u\in [t]$.
\item $\prover$ and $\verifier$ run the linear and quadratic check protocols in
parallel, parsing the vectors $V_u$ into $X_u,Y_u,Z_u,W_u$ as needed.
\item Check proximity as: $\sum_{a=1}^\ell
\Lambda_1^T[a,k_u]\tilde{c}_a=\sum_{i=1}^{4p}\rho_i\pi[i,k_u]$ for $u\in [t]$.
\item $\verifier$ accepts if all the subprotocols accept.
\end{enumerate}
}

\subsection{Performance: Standalone}
We now summarize several performance parameters attained by our protocol for circuit
size $N$ and soundness $2^{-\secpar}$. Let $N=pms$, $\ell=s+t$ and $h$ be as in
previous sections. Let $\cfop$ denote the time taken for a field operation,
$\cfft(x)$ denote the time to compute $\fft$ of a length $x$ vector, $\cmexp(x)$
denote the time taken for a multiexponentiation of length $x$, and $\cexp$
denote the time required for an exponentiation. Let $\bitsF$ and $\bitsG$ denote
the number of bits required to represent an element of $\FF$ and $\GG$
respectively. Our protocol $\name$ achieves
following efficiency parameters:
{\footnotesize
\begin{align*}
\begin{array}{llrl}
\mathrm{alphabet} & \Sigma & = & \FF \\
& & & \\
\mathrm{number\ of\ rounds} & \zkrounds & = & O(\log{N}) \\
& & & \\
\mathrm{argument\ size} & \zkcomm & = & 4pt\bitsF \\
& & & +(4pt+8t\log{m}+4\ell+s+8t+4)\bitsG \\
& & & \\
\mathrm{prover\ complexity} & t_\prover & = &
4p((m+n)\cfft(m)+m\cfft(l) \\
& & &+n\cfft(h) + 4p\ell\cmexp(m)\\
& & &+(n-\ell)\cmexp(\min(\ell,m))\\
& & & +(s+3\ell)\cmexp(2m)\\
& & &+ (48tm+32m)\cexp \\
& & & \\
\mathrm{verifier\ complexity} & t_\verifier & = &
O(N)\cfop + (2t+2)\cmexp(2m)\\
& & & +2t\cmexp(m)+t\cmexp(4p+\ell) \\
& & & \\
\mathrm{soundness\ error} & \kappa_{\rm gr} & = & (1-e/n)^t \\ 
& & & +\big(2m/h+(1-2m/h)(2\ell+e)/n\big)^t 
\end{array}
\end{align*}
}

We give details in the Appendix, on how we compute the above parameters.

%\begin{enumerate}
%\item {\bf Argument Size}: $8pt+8t\log{m}+4\ell+s+8t+4\log{m}+4$, where $4pt$ comes as part
%of oracle openings, another $4pt$ from opening $t$ vectors
%$W_u=\ewit[\cdot,j_u,k_u]$, $u\in [t]$ of size $4p$ each, $(4t+2)(2\log{m}+2)$ from
%the $4t+2$ inner product subprotocols ($2t+1$ in linear and quadratic check
%each), $\ell+(s+\ell)+2\ell$ from the commitments sent for proximity check,
%linear check and quadratic check.
%\item {\bf Verifier Complexity}:
%$O(N)+(2t+2)\mexp(2m)+2t\mexp(m)+t(\mexp(4p+\ell))$. The first
%term comes from computing $r_{lc}^TW$ and the second term comes from
%verification in inner product subprotocols, and the last term comes from
%checking the proximity check equations.
%\item {\bf Prover Complexity}: Encoding the witness involves
%$4p\big(m(\cfft(\ell)+\cfft(m))+n(\cfft(m)+\cfft(h))\big)$ operations in $\FF$ , 
%constructing the oracle takes
%$4p\big(\ell\mexp(m)+(n-\ell)\mexp(\min(\ell,m))\big)$, commiting ``P'' matrices
%take a further $(s+\ell)\mexp(2m)+2\ell\mexp(2m)$, the inner product
%subprotocols account for $(2t+2).16m + 2t.8m$ exponentiations. This gives a
%total of $O(N\log{N})$ field ops +
%$4p\big(\ell\mexp(m)+(n-\ell)\mexp(\min(\ell,m))\big)+(s+3\ell)\mexp(2m)$ +
%$(48tm+32m)$ exps.

%\item {\bf Soundness}: The soundness is given by:
%\begin{equation*}
%\kappa_{gr} :=
%\left(1-\frac{e}{n}\right)^t+2\left(\frac{2m}{h}+\left(1-\frac{2m}{h}\right)\left(\frac{2\ell+e}{n}\right)\right)^t
%\end{equation*}
%\end{enumerate}

For $c\geq 2$, setting $p=s=O(N^{1/c})$, $m=O(N^{1-2/c})$, $t=O(\secpar)$,
$n=O(\ell)$ and $h=O(m)$, we get $\kappa_{gr}=\negl(\secpar)$ with argument size
$O(N^{1/c})$, verifier's complexity as $O(N)$ field operations and
$O(N^{1-2/c})$ exponentiations. We discuss some concrete parameter settings
next for $N=10^6$ and $N=10^9$.
