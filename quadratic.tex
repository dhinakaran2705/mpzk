\subsection{Quadratic Check Protocol}\label{sec:quadcheck}
We now describe the IPCP which allows a prover to prove knowledge of vectors
$\wit_x$, $\wit_y$ and $\wit_z$ in $\FF^N$, satisfying $\wit_x\circ \wit_y =
\wit_z$. As before we view $\wit_x, \wit_y$ and $\wit_z$ as $p \times m \times s$ matrix, where $N=pms$. 
As described previously in Sections ~\ref{sec:witencoding} and ~\ref{sec:construct_oracle}, the prover obtains $\ewit_a \leftarrow \enc(\wit_a)$ and $\comoracle_a \leftarrow \comm(\ewit_a)$ $\forall a\in \{x,y,z\}$ . We present a full protocol in Figure ~\ref{fig:quadcheck}. First we describe the key ideas in the protocol for an honest prover. We then discuss how to achieve soundness against an adversarial prover.

%Once again, the protocol requires the prover to construct encodings
%$\ewit_x=\enc(\wit_x)$, $\ewit_y=\enc(\wit_y)$ and $\ewit_z=\enc(\wit_z)$ as
%described in Section \ref{sec:witencoding}. Thereafter, the prover uses
%commitment scheme $\comm$ to commit to these encodings as $\comoracle_x =
%\comm(\ewit_x)$, $\comoracle_y = \comm(\ewit_y)$ and $\comoracle_z = \comm(\ewit_z)$. 
%The prover forms the oracle $\pi\in \GG^{3p\times n}$ by vertically stacking the
%$p\times n$ matrices $\comoracle_x,\comoracle_y$ and $\comoracle_z$. As before,
%for a query $Q\subseteq [n]$, the oracle answers with columns $\pi[\cdot,k]$ for
%$k\in Q$. The columns returned by the oracle can be parsed into constituent columns 
%$\comoracle_x[\cdot,k]$, $\comoracle_y[\cdot,k]$ and $\comoracle_z[\cdot,k]$
%canonically. We again discuss the key ingredients of the protocol.

\noindent{\em Reduction to Inner Product}: Let $Q^i_x,Q^i_y$ and $Q^i_z, i\in [p]$ be the
polynomials interpolating the $i^{th}$ slices of $\wit_x$, $\wit_y$ and $\wit_z$
 as in Section \ref{sec:witencoding}. Then for vectors $\wit_x,\wit_y,\wit_z$ satisfying
$\wit_x\circ \wit_y=\wit_z$, the polynomials $Q^i=Q^i_x\cdot Q^i_y - Q^z_i$ interpolate
$\bm{0}^{m\times s}$ on the set $\{(\alpha_j,\zeta_k):j\in [m],k\in [s]\}$ for all $i\in [p]$. This can be probabilistically
checked by checking that the polynomial $F := \sum_{i\in [p]}r_iQ^i$ interpolates
$\bm{0}^{m\times s}$ on the above set for randomly sampled $r\in \FF^p$. 
To check that $F$ interpolates $\bm{0}^{m\times s}$ on the points
$\{(\alpha_j,\zeta_k)\}_{j\in [m],k\in [s]}$, the verifier checks that
$p(\cdot) := \sum_{j\in [m]}\gamma_jF(\alpha_j,\cdot)$ interpolates $\bm{0}^s$ on
$\overline{\bm{\zeta}}$ for randomly sampled $\gamma=(\gamma_1,\ldots,\gamma_m)\in \FF^m$.
Again, the verifier checks $p(\overline{\bm{\zeta}})=\bm{0}^s$ via the inner product
check $\innp{\tau}{p(\overline{\bm{\zeta}})}=0$ for a random $\tau\in \FF^s$. 

\noindent{\em Intermediate Commitment:} We introduce an $h\times n$ matrix $P$ which serves as a bridge between the oracle $\comoracle_a$ $\forall a \in \{x,y,z\}$ and the eventual vector $p(\overline{\bm{\zeta}})$. For $j\in [h]$, let $p_j(\cdot)$ denote the polynomial $\sum_{i\in[p]} r_iQ^i(\alpha_j, \cdot)$. We define the matrix $P$ by $P[j,k]= p_j(\eta_k)$ $\forall j\in[h], k\in[n]$. Note that the matrix $P$ is in the product of codes $\rsc{\eta}{n,2\ell}$ and $\rsc{\alpha}{h,2m}$. Let $\overline{P}$ is a submatrix of $P$ consisting of first $2m$ rows and $2\ell$ columns of $P$. By the construction of $P$, given a $\overline{P}$, there is unique $P$ and $\Lambda_5( \overline{P}\Lambda_4^T) = P$. We let the prover commit to $P$, by committing to the columns of $\overline{P}$. Let $c_1, \ldots, c_{2\ell}$ denote the commitments to columns of $\overline{P}$.

\noindent{\em Consistency of $P$ and $p(\overline{\bm{\zeta}})$:} Let $\overline{\bm{\eta}}$ denote the vector $(\eta_1, \ldots, \eta_{2\ell})$, and let $\Phi$ denote the $s\times 2\ell$ matrix such that $p(\overline{\bm{\zeta}}) = \Phi p(\overline{\bm{\eta}})$. further, observe that $p(\overline{\bm{\eta}}) = \overline{P}^T [\gamma||0^m]^T$ and thus $p(\zetabar) = \Phi \overline{P}^T [\gamma||0^m]^T$. Now we have $\innp{\tau}{p(\zetabar)} = p(\zetabar)^T \tau = [\gamma||0^m] \overline{P} \Phi^T \tau = \innp{[\gamma||0^m]^T}{\overline{P}\varphi}$ where $\varphi = \Phi^T \tau$. Given commitments $c_1, \ldots, c_{2\ell}$, the commitment to $\overline{P}\varphi$ can be computed as $\cm = \sum_{k\in[2\ell]} \varphi_k c_k$. Using an inner product argument the prover can show that the commitment $\cm$ opens to vector $z$ such that $\innp{[\gamma||0^m]^T}{z} = 0$. Binding property of the commitment ensures that $z = \overline{P}\varphi$ with overwhelming probability.

\noindent{\em Consistency of the oracle and  $P$:} The verifier additionally needs to determine if $P$ is correctly computed from the encoding $\ewit_x, \ewit_y, \ewit_z$ committed by the oracle $[\comoracle_x||\comoracle_y||\comoracle_z]$. The verifier proceeds to check the consistency at randomly sampled positions $Q=\{(j_u,k_u) : u\in[t] \} \subset [h]\times[n]$. It queries the oracle the oracle for the columns $\pi[\cdot, k_u]$ \pnote{$\pi$ is not described before} for $u\in[t]$ and queries the prover for vectors $X_u = \ewit_x[\cdot,j_u,k_u], Y_u = \ewit_y[\cdot, j_u,k_u], Z_u = \ewit_z[\cdot,j_u,k_u]$ for $u\in [t]$, let $f_u$ denote the unit vector in $FF^h$ with 1 in the $j_u$th position. The prover and the verifier run inner product arguments to establish the following: 

\begin{enumerate}[{\rm 1.}]
	\item $\innp{f_u}{P[\cdot,k_u]} = \sum_{i\in[p]} r_i[X_u[i]\cdot Y_u[i] - Z_u[i]]$ for $u\in[t]$. Note that for honestly computed $P$,  $\innp{f_u}{P[\cdot,k_u]} = P[j_u,k_u] = \sum_{i\in[p]} r_i Q^i(\alpha_{j_u},\eta_{k_u}) = \sum_{i\in[p]} r_i [Q_x^i(\alpha_{j_u},\eta_{k_u}) Q_y^i(\alpha_{j_u},\eta_{k_u})- Q_z^i(\alpha_{j_u},\eta_{k_u})] = \sum_{i\in[p]} r_i [\ewit_x[i,j_u,k_u] \ewit_y[i,j_u,k_u] - \ewit_z[i,j_u,k_u]]$ . Thus the identity holds for honestly computed $P$ and honest vectors $X_u, Y_u, Z_u$. 
	Define $W = \overline{P}\Lambda_4^T$, $W$ is a submatrix of $P$ consists of first $2m$ rows of $P$ (see Section ~\ref{sec:codesandmatrices}). Therefore commitment of the $k_u$th column of $W$ is $\cm_{k_u} = \sum_{a\in[2\ell]} \Lambda_4^T[a,k_u]c_a$. Next, we observe that $\innp{f_u}{P[\cdot,k_u]} = \innp{f_u}{\Lambda_5 W[\cdot,k_u]} = \innp{f_u^T\Lambda_5}{W[\cdot,k_u]}$. In the last formulation, the first vector is public and the commitment to the second vector is known $(\cm_{k_u})$ and hence the prover and the verifier can check the identity using inner product argument.
	
	\item $\innp{f_u}{\ewit_a[i,\cdot,k_u]} = X_u[i]$ $\forall u\in[t], i\in[p]$ and $a\in\{x,y,z\}$. Let $V^a_{iu}$ denotes a $m$ sized vector consisting of the first $m$ entries of $\ewit_a[i,\cdot, k_u]$, therefore, $\ewit_a[i,\cdot,k_u] = \Lambda_2 V^a_{iu}$. Then the above inner product can be written as $\innp{f_u^T \Lambda_2}{V^a_{iu}} = X_u[i]$ $\forall u\in[t], i\in[p]$ and $a\in\{x,y,z\}$, which can be executed as the commitment $\pi[\cdot,k_u]$ of $V^a_{iu}$ is present as part of the oracle response, for all $a\in \{x,y,z\}$. In fact, the checks for each $u\in [t]$ can be aggregated, leading to one inner product check for each $a\in \{x,y,z\}$.
\end{enumerate}

\noindent{\em Proximity Check for Oracle:}



\begin{figure}[t!]
{\small
	%\centering
	\begin{framed}
		\noindent{$\quadcheck(\mathsf{pp},[\pi];\ewit_x, \ewit_y, \ewit_z)$}:
		
		\noindent{\bf Relation}: $[\ewit_x||\ewit_y||\ewit_z]=\open(\pi)\wedge \wit_x \circ \wit_y = \wit_z$ for $\wit_a=\dec(\ewit_a)$ $\forall a\in \{x,y,z\}$.
		
		\begin{enumerate}[{\rm 1.}]
			\item $\verifier\rightarrow\prover$: $\rho\sample \FF^p$.
			\item $\prover$ computes: $\tilde{U}=\sum_{i\in [p]}\rho_i\ewit[i,\cdot,\cdot]$, 
			commitments $\tilde{c}_1,\ldots,\tilde{c}_\ell$ as in Section ~\ref{sec:matrixcommitment}.
			\item $\prover\rightarrow\verifier$: $\tilde{\bm{c}}=(\tilde{c}_1,\ldots,\tilde{c}_\ell)$.
			\item $\verifier\rightarrow\prover$: $r\sample \FF^p$.
			%\item $\prover\leftrightarrow\verifier$ compute: Polynomials $R^i$, $i\in [p]$ interpolating $R=r^TA$ as in Section ~\ref{sec:quadcheck}. 
			\item $\prover$ computes: $p_j(\cdot) = \sum_{i\in[p]} r_i[Q^i_x(\alpha_j,\cdot)Q^i_y(\alpha_j,\cdot) - Q^i_z(\alpha_j,\cdot)]$ $\forall j\in [h]$
			%\item 
			$\prover$ computes Matrix $P$ such that $P[j,k] = p_j(\eta_k)$ as described in Section ~\ref{sec:quadcheck}. %Samples $P_0\sample \FF^m$, $\omega_0\sample \FF$ and $c_0\gets \comm(P_0,\omega_0)$.
			Computes commitments $c_1,\ldots,c_{2\ell}$ from $P$.
			\item $\prover\rightarrow\verifier$: $c_1,\ldots,c_{2\ell}$.
			\item $\verifier\rightarrow\prover$: $Q=\{(j_u,k_u):u\in [t]\}$ for $(j_u,k_u)\sample [h]\times [n]$ for $u\in [t]$. And $\tau \sample \FF^s$, $\gamma \sample \FF^m$.
			\item $\verifier\rightarrow\pi$: $\{k_u:u\in [t]\}$.
			\item $\prover\rightarrow\verifier$: $X_u=\ewit_x[\cdot,j_u,k_u]$ , $Y_u=\ewit_y[\cdot,j_u,k_u]$ and $Z_u=\ewit_z[\cdot,j_u,k_u]$ for $u\in [t]$.
			
			\item $\pi\rightarrow\verifier$: $\pi[\cdot,k_u]$ for $u\in [t]$.
			\item $\verifier\rightarrow\prover$: $\delta\sample \FF^p$, %$\beta\sample \FF\backslash \{0\}$. 
			\item $\prover$ and $\verifier$ run inner product arguments to check:
			\begin{enumerate}
				\item $\innerproduct(\mathsf{pp},f_u^T\Lambda_5,\mathsf{cm}_{k_u},v_u;\overline{P}[\cdot,k_u])$ for $u\in [t]$ where $\mathsf{cm}_{k_u}=\sum_{a=1}^{2\ell}\Lambda_4^T[a,k_u]c_a$, 
				$v_u=\sum_{i=1}^p r_i[X_u[i]\cdot Y_u[i] - Z_u[i]]$ (check consistency of $P$ with $\pi$).
				\item $\innerproduct(\mathsf{pp},\gamma||0^m,\mathsf{cm},0;z)$ where $z=\overline{P}\varphi$ and $\varphi = \Phi^T\tau$ and $\mathsf{cm} = \sum_{a=1}^{2\ell} \varphi_ac_a$ %(check the condition $r^TAw = r^Tb$).
				\item
				\begin{itemize}  
					\item $\innerproduct(\mathsf{pp},f_u^T\Lambda_2,C_u,\innp{\delta}{X_u})$ for $u\in [t]$ 
				where $C_u=\sum_{i=1}^p\delta_i\comoracle_x[i,k_u]$
					\item 
					$\innerproduct(\mathsf{pp},f_u^T\Lambda_2,D_u,\innp{\delta}{Y_u})$ for $u\in [t]$ 
					where $D_u=\sum_{i=1}^p\delta_i\comoracle_y[i,k_u]$
					\item
					$\innerproduct(\mathsf{pp},f_u^T\Lambda_2,E_u,\innp{\delta}{Z_u})$ for $u\in [t]$ 
					where $E_u=\sum_{i=1}^p\delta_i\comoracle_z[i,k_u]$
				\end{itemize}				
				(consistency of $X_u, Y_u, Z_u$ with $\pi$). 
			\end{enumerate}
			\item $\verifier$ checks: $\sum_{a=1}^\ell\Lambda_1[a,k_u]\tilde{c}_a=\sum_{i=1}^p\rho_i\pi[i,k_u]$ for $u\in [t]$ (check proximity of $\ewit$ to $\mc{W}_1$).
		\end{enumerate}
	\end{framed}
	\caption{Quadratic Check Protocol}
	\label{fig:quadcheck}
}
\end{figure}
\pnote{ Complete the protocol by including proximity check}

%As in the linear check protocol, using $p(\overline{\bm{\zeta}})=\Phi p(\overline{\bm{\eta}})$, we get the following inner product check
%$\innp{(\gamma,0^{h-m})}{\overline{P}\varphi}=0$ where $\varphi=\Phi^T\tau$. 
%Once again, we
%ask the prover to ``commit'' to $F$ using a tamper resistant structure, like a codeword,
%which enables the verifier to check the aforementioned condition, as well as to
%ensure that the commitment is consistent with oracle replies and prior
%messages.
%\noindent{\em Reduction to Inner Products}: 
%The prover computes 
%$h\times n$ matrix $P$ given by $P[j,k]=F(\alpha_j,\eta_k)$. 

%It commits to $P$ using commitments $(c_1,\ldots,c_{2\ell})$ to the first $2\ell$ columns of $P$.
%Note that each row of $P$ commits to univariate component polynomials
%$F(\alpha_j,\cdot)$ of $F$ via their evaluations of $\bm{\eta}$. 
%Again, the verifier checks $p(\overline{\bm{\zeta}})=\bm{0}^s$ via the inner product
%check $\innp{\tau}{p(\overline{\bm{\zeta}})}=0$ for a random $\tau\in \FF^s$. As in the
%linear check protocol, using $p(\overline{\bm{\zeta}})=\Phi p(\overline{\bm{\eta}})$, we
%get the following inner product check
%$\innp{(\gamma,0^{h-m})}{\overline{P}\varphi}=0$ where $\varphi=\Phi^T\tau$. 
%The commitment to the vector $\overline{P}\varphi$ can be homomorphically computed
%from $c_1,\ldots,c_{2\ell}$.

%\noindent{\em Checking consistency with Oracle}: As in the linear check, the
%verifier uniformly and independently samples $(j_u,k_u)\in [h]\times [n]$ for
%$u\in [t]$, and queries the oracle $\pi$ for columns $\pi[\cdot,k_u]$. Let
%$\pi_x[\cdot,k_u]$, $\pi_y[\cdot,k_u]$ and $\pi_z[\cdot,k_u]$ denote the parse
%of $\pi[\cdot,k_u]$ into commitments corresponding to $\ewit_x,\ewit_y$ and
%$\ewit_z$ respectively. Further, the verifier asks prover for vectors
%$\ewit_x[\cdot,j_u,k_u]$, $\ewit_y[\cdot,j_u,k_u]$ and $\ewit_z[\cdot,j_u,k_u]$
%for $u\in [t]$. The verifier then checks the following:
%\begin{enumerate}[{\rm (i)}]
%\item For all $u\in [t]$: $P[j_u,k_u]=\sum_{i\in
%[p]}r_i(\ewit_x[i,j_u,k_u]\cdot\ewit_y[i,j_u,k_u]-\ewit_z[i,j_u,k_u])$.
%\item Checks that vectors $\ewit_x[\cdot,j_u,k_u]$ are consistent with
%commitments $\pi_x[\cdot,k_u]$ as in linear check protocol. Similar checks are
%made for $\ewit_y[\cdot,j_u,k_u]$ and $\ewit_z[\cdot,j_u,k_u]$.
%\end{enumerate}
%We present the full protocol in Figure \ref{fig:quadcheck}. The completeness of
%the protocol can again be verified by direct calculation. We state the soundness
%of the protocol below:
