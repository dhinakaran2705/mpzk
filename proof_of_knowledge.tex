\documentclass[runningheads]{llncs}
%packages---------------------------------
\usepackage{amsmath} %for matrix
\usepackage{amsfonts} %for mathbb
\usepackage{bm}
\usepackage{xcolor} %for red color text in pnote
\usepackage{comment}
%newcommands------------------------------
\newcommand{\innp}[2]{\langle #1,#2\rangle}
\newcommand{\name}{\textsf{ours}}
%comments---------------------------------
\newcommand{\pnote}[1] {\textcolor{red}  {PKP: \sl{#1}}}
%macros-----------------------------------
\def\ppt{\mathsf{PPT}}
\def\extrac{\mathcal{E}} %Extractor
\def\Sim{\mathcal{S}} %Simulator
\def\prover{\mathsf{P}}
\def\verifier{\mathsf{V}}
\def\RS{\mathsf{RS}} %Reed Solomon encoding
\def\cm{\mathsf{cm}} %Commitment vector
\def\com{\mathsf{com}} %Commitment protocol
\def\negl{\mathsf{neg}}
\def\NP{\mathsf{NP}}
\def\C{\mathsf{C}} %Circuit
\def\wit{\mathsf{w}} %Witness
\def\extwit{\hat{w}} %Extended witness
\def\stmt{\hat{x}} %Statement
\def\oracle{\mathcal{U}^{\RS}}
\def\dec{\mathsf{Dec}}
\def\enc{\mathsf{Enc}}

\def\calA{\mathcal{A}}
\def\calB{\mathcal{B}}
\def\calC{\mathcal{C}}
\def\calD{\mathcal{D}}
\def\calE{\mathcal{E}}
\def\calF{\mathcal{F}}
\def\calG{\mathcal{G}}
\def\calH{\mathcal{H}}
\def\calI{\mathcal{I}}
\def\calJ{\mathcal{J}}
\def\calK{\mathcal{K}}
\def\calL{\mathcal{L}}
\def\calM{\mathcal{M}}
\def\calN{\mathcal{N}}
\def\calO{\mathcal{O}}
\def\calP{\mathcal{P}}
\def\calQ{\mathcal{Q}}
\def\calR{\mathcal{R}}
\def\calS{\mathcal{S}}
\def\calT{\mathcal{T}}
\def\calU{\mathcal{U}}
\def\calV{\mathcal{V}}
\def\calW{\mathcal{W}}
\def\calX{\mathcal{X}}
\def\calY{\mathcal{Y}}
\def\calZ{\mathcal{Z}}

\def\bbA{\mathbb{A}}
\def\bbB{\mathbb{B}}
\def\bbC{\mathbb{C}}
\def\bbD{\mathbb{D}}
\def\bbE{\mathbb{E}}
\def\bbF{\mathbb{F}}
\def\bbG{\mathbb{G}}
\def\bbH{\mathbb{H}}
\def\bbI{\mathbb{I}}
\def\bbJ{\mathbb{J}}
\def\bbK{\mathbb{K}}
\def\bbL{\mathbb{L}}
\def\bbM{\mathbb{M}}
\def\bbN{\mathbb{N}}
\def\bbO{\mathbb{O}}
\def\bbP{\mathbb{P}}
\def\bbQ{\mathbb{Q}}
\def\bbR{\mathbb{R}}
\def\bbS{\mathbb{S}}
\def\bbT{\mathbb{T}}
\def\bbU{\mathbb{U}}
\def\bbV{\mathbb{V}}
\def\bbW{\mathbb{W}}
\def\bbX{\mathbb{X}}
\def\bbY{\mathbb{Y}}
\def\bbZ{\mathbb{Z}}
%-----------------------------------------
\begin{document}
\subsection{Proof of Knowledge}
	For \name2D protocol, we claim that the protocol has proof of knowledge property. That is there is a $\ppt$ machine $\extrac$ that has oracle access to the prover $\prover$ such that by rewinding $\prover$, $\extrac$ can output the witness $w$ such that for which $\prover$ can convince $\verifier$.
	
	We will prove the above claim by proving that each subprotocols have the special correctness property. 
	Suppose $x$ is encoded using interleaved $\RS$ encoding, then each column is commited using Pedersen commitment. 
	
	\subsubsection{Encoding:}\label{subsec: encode} 
	If $|x|=ml$ then read $x$ as 
	$$x=
	\begin{bmatrix}
		x_{11} & x_{12} & \ldots & x_{1l}\\
		x_{21} & x_{22} & \ldots & x_{2l}\\
		& \vdots\\
		x_{m1} & x_{m2} & \ldots & x_{ml}
	\end{bmatrix}
	$$	
	 Construct polynomials $\hat{f}^x_i(\cdot)$ of deg $k$ such that $\hat{f}^x_i(\zeta_j)=x_{ij}$ $\forall i\in [m], j\in [l]$ where $k>l$ and $l+t=k$.
	
	Define 
	$$\oracle_x =
	\begin{bmatrix}
		u_{11} & u_{12} & \ldots & u_{1n}\\
		u_{21} & u_{22} & \ldots & u_{2n}\\
		& \vdots\\
		u_{m1} & u_{m2} & \ldots & u_{mn}
	\end{bmatrix}
	$$
	where $u_{ij}= \hat{f}^x_i(\eta_j)$ $\forall i\in[m], j\in[n]$ $n>k$. $\bm{\zeta}=\{\zeta_1,\ldots,\zeta_l\}$ we will call it interpolation domain and $\bm{\eta} = \{\eta_1,\ldots,\eta_n\}$ we will call it evaluation domain. 
	
	Let $L$ be the set of codewords and the above linear code has distance $d$. Then a correctly computed $\oracle_x$ is in $L^m$.
	
	\subsubsection{Commitment:}\label{subsec: commit} Then compute the commitment of $\oracle_x$. Let $\cm_x=(c_1,\ldots c_n)$ where $c_j= \com( \begin{bmatrix}
	u_{1j} & u_{2j} & \ldots & u_{mj}
	\end{bmatrix}^T)$ $\forall j\in [n]$
	
	\paragraph{\textbf{Proximity Check:}}\label{sec:proximity} In this check $\prover$ convinces $\verifier$ that $\cm_x$ is the commitment of a correct codeword matrix $\oracle_x$ which is encoding of a matrix $x$. If $\oracle_x$ is malformed, i.e. if it is sufficiently far away from a correct codeword matrix, then $\prover$ passes the following check with $\negl(t)$ probability.
	\begin{enumerate}
		\item $\prover \rightarrow \verifier :$ $\prover$ sends $cm$ to $\verifier$.
		
		\item $\verifier \rightarrow \prover :$ $\verifier$ as a challenge picks $\gamma \in \bbF^m$ uniformly at random and sends it to $\prover$.
		
		\item $\prover \rightarrow \verifier :$ $\prover$ computes $u=\gamma^T\oracle_x$ and sends $u$ to $\verifier$.
<<<<<<< HEAD
		\pnote{instead of $w$, using $u=\gamma^T\oracle_x$, otherwise $w$ conflicts with the witness.
		\item $\verifier \rightarrow \prover :$ $\verifier$ picks a random subset $Q\subseteq [n]$ such that $|Q|=t$ and sends $Q$ to $\prover$.

		\item $\prover \leftrightarrow \verifier: $ $\prover$ and $\verifier$ run a subprotocol to prove the innerproduct arguement for the following statement $\innp{\gamma}{\oracle_x[\cdot,j_u]}=u_{j_u}$ $\forall j_u\in Q$

		\item If $\verifier$ accepts the innerproduct arguement in step 5, then checks if $w\in L$. If yes then $\verifier$ outputs accept else outputs reject.
	\end{enumerate}
	
	Note that the subprotocol for innerproduct arguement has the proof of knowledge property, proof given in \cite{Bulletproofs}. So there is an expected $\ppt$ extractor $\extrac_{innp}$ for the innerproduct argument, which either outputs the witness or breaks the binding property of the committment, if the arguement is accepted.
	\begin{theorem}\label{theo:proximity}
		For $e < \frac{d}{3} $, if $\innp{\prover^*(\cm, \calU^*)}{\verifier(\cm)} $ is true, then there is an expected $\ppt$ $\extrac^{\prover^*}(\cm) \rightarrow \calU^*$ such that with overwhelming probability $\calU^*$ satisfies one of the following events: 
		\begin{itemize}
			\item $\com(\calU^*) = \cm$ and $ d(\calU^*, L^m) < e$
			\item $\extrac$ breaks the binding of the commitment. 
		\end{itemize} 
		
	\end{theorem}

	\begin{proof}
		Now we will design a $\ppt$ $\extrac$ for the above protocol.
		In step 4 $\extrac$ emulates $\verifier$ and picks $Q$ uniformly at random, then if innerproduct arguement is accepted then run $\extrac_{innp}$, in polytime with overwhelming probability. $\extrac_{innp}$ outputs either $\calU^*[\cdot,j_u]$ $\forall j_u\in Q$ or breaks the binding property of the commitment scheme, and stores the indices of $Q$ in a set $S$. then rewinds to the step 4 and then again picks $Q$ uniformly at random, $\extrac$ keeps extracting $\calU^*[\cdot,j_u]$ and updates $S$ by including only the new indices repeating until $|S|=n$. That is $\extrac$ extracts the whole $\calU^*$.
		\begin{comment}
		In the next step $\extrac$ gets $\calU^*[\cdot,j_u]$ $\forall j_u \in S$. Since $|S|>k$, from $\oracle_x[\cdot,j_u]$ decoding is deterministic, so the $\extrac$ decodes $\oracle$ to $x$ and outputs $x$.
		\end{comment}
		
		Now $\extrac$ checks computes $d(\calU^*, L^m)$. Probability that $d(\calU^*,L^m) > e$ is $\negl(\lambda)$, by soundness analysis in \cite{Ligero2017}.
		
		Therefore $\extrac$ outputs $\calU^*$ whcih satisfies $\com(\calU^*) = \cm$ such that $d(\calU^*, L^m) < e$ with very high probability or it breaks the binding of the commitment scheme.
		
		Now we need to prove that the number of rewinding is polynomial.
		
		To get the bound on the expected number of rewindings consider $t=1$. 
		
		Let $X$ be the discrete random variable that represents the number of purchases until each of the $n$ column is picked at least once.
		
		Let $X_i$ be the discrete random variable that represents the number of rewindings after the $(i-1)^{th}$ distinct column to select the $i^{th}$ distinct column. As a base case, $X_1=1$, because the first column selected will always be distinct.
		
		By Linearity of expectation, $E[X]=\sum_{i=1}^{n}E[X_i]$
		
		After the $(i-1)^{th}$ distinct column is picked, there are $n-i+1$ columns remaining to be picked. Let $A_i$ be the event that one of those columns is picked in the next rewinding. Then $Pr(A_i)=\frac{n-i+1}{n}$.
		
		$X_i$ follows a geometric distribution (of trials). It's expected value is
		 $$E[X_i]= \frac{1}{Pr(A_i)} = \frac{n}{n-i+1}$$
		From before, $E[X]$ is equal to the sum of all these expectations: i.e.
		$$E[X] = \sum\limits_{i=1}^{n} \frac{n}{n-i+1} = n\sum\limits_{i=1}^{n} \frac{1}{i} \approx n \log n$$
		Which is polynomial in $n$ and so polynomial in security parameter.
		%\pnote{Remaining analysis is to check the expected number of rewinding required to obtain $\oracle$.}
	\end{proof}
	
	\paragraph{\textbf{Linear Check:}}\label{sec: linearity} In this check, there is a publicly known matrix $A \in \bbF^{ml\times ml}$ and public vector $b\in \bbF^{ml}$, and $\prover$ claims that he knows a $x$ such that $Ax=b$ is true. $\prover$ starts with encoding the $x$ using interleaved $\RS$ code which is described above and gets $\oracle_x$, then he computes the commitment $\cm_x$ in the same way mentioned above. Now the following check ensures that if a maformed $\calU$ is used for $\oracle$, which is not far away from a correct encoding of $x$ for which $Ax\neq b$, then $\verifier$ outputs reject with very high probability.
	\begin{enumerate}
		\item $\prover \rightarrow \verifier: $ $\prover$ sends $\cm_x$ to $\verifier$.
		\item $\verifier \rightarrow \prover: $ $\verifier$ picks a random $r\in \bbF^{ml}$ and sends that $r$ to $\prover$.
		\item $\prover$ and $\verifier$ compute $R=r^TA$, which is a vector of size $ml$. Read $R$ in a matrix form where first $l$ elements of $R$ forms the first row, next $l$ elements forms the second row, similary $R$ will have $m$ rows. Then they construct polynomials $R_i(\cdot)$ of degree $<l$ such that $R_i(\zeta_j)=R_{ij}$ $\forall i\in [m], j\in [l]$. 
		\item $\prover \rightarrow \verifier: $  $\prover$ computes a polynomial $p(\cdot)=\sum_{i\in[m]} ( R_i(\cdot)\cdot \hat{f}^x_i(\cdot))$ and sends $p(\cdot)$ to $\verifier$.
		\item $\verifier \rightarrow \prover: $ $\verifier$ samples $t$ distinct  indices $j_1,\ldots,j_t$ from the set $[n]$ independently at random and sends the indices to $\prover$.
		\item $\prover \leftrightarrow \verifier: $ $\prover$ and $\verifier$ run a subprotocol to prove the innerproduct arguement for the following statement $\innp{R_{j_u}}{\oracle_x[\cdot,j_u]} = p(\eta_{j_u})$ for all $j_u$ queried in the above step by $\verifier$, where $R_{j_u}=(R_1(\eta_{j_u}),\ldots,R_m(\eta_{j_u})$ and $\oracle_x[\cdot,j_u]$ denotes the $m-$length vector $(\oracle_x[1,j_u],\ldots, \oracle_x[m,j_u])$. $\verifier$ proceeds if the arguments succeed for all $u \in [t]$.
		\item $\verifier$ also checks that $\sum_{j\in[l]} p(\zeta_j)=0$.
		\item $\verifier$ accepts if all the above checks are succeed.	  
	\end{enumerate}
	
	\begin{theorem}
		For $e < \frac{d}{3} $, $\innp{\prover^*(\cm, \calU^*, A, b)}{\verifier(\cm, A, b)} \rightarrow 1 $ then there is an expected $\ppt$ $\extrac^{\prover^*}(\cm) \rightarrow \calU^*$ such that with overwhelming probability $\calU^*$ satisfies one of the following events:
		\begin{itemize}
			\item $\com(\calU^*)=\cm$ and $d(\oracle_x,L^m) > e $
			\item $\com(\calU^*)=\cm$ and $d(\oracle_x, l^m)\leq e \text{ and } x = \dec(\oracle_x)$ satisfies $ Ax = b$
			\item $\extrac$ breaks the commitment scheme.
		\end{itemize}
	\end{theorem}

	\begin{proof}
	We have a $\ppt$ extractor, $\extrac_{innp}$, for the inner product arguement for the statement $\innp{\bm{a}}{\bm{b}}=c$ where $\bm{a},\bm{b}$ are private, which can either extract $\bm{a}, \bm{b}$ or breaks the binding property of the commitment scheme with overwhelming probability. Now we will use $\extrac_{innp}$ to design a $\ppt$ extractor $\extrac$ which can extract the witness($\calU^*$) for which the arguement in the above protocol is accepted.
	
	 $\extrac$ emulates $\verifier$'s role in the protocol till step 5, then calls $\extrac_{innp}$ to get $\calU^*[\cdot,j_u]$ or collision for the commitment. $\extrac$ stores the indices in a set say $S$ and rewind the prover to step 5 and picks $t$ indices again uniformly at random again and follows the above procedure. $\extrac$ keeps rewinding till $|S|=n$.
	 
	 If $|S|=n$, then $\extrac$ has the whole $\calU^*$.
	 
	 Then $\extrac$ computes $d(\calU^*, L^m)$:
	 \begin{itemize}
	 	\item if $d(\calU^*,L^m) > e$ then $\extrac$ outputs $\calU^*$, which satisfies $\com(\calU^*)=\cm$ otherwise gets a collision for the binding property.
	 	
	 	\item if $d(\calU^*,L^m) \leq e$ then by soundness analysis in \cite{Ligero2017}, the nearest codeword of $\calU^*$ decodes to $x$ such that $Ax\neq b$ has $\negl(\lambda)$ probabillity. That means nearest codeword of $\calU^*$ decodes to $x$ which satisfies $Ax=b$ with very high probability and $\com(\calU^*)=\cm$.
	 \end{itemize}
 
	 Similar analysis of Theorem:~\ref{theo:proximity} proves that $\extrac$ requires polynomially many rewinding to extract the witness $x$.
	\end{proof}

	\paragraph{\textbf{Quadratic Check:}}\label{sec: quadratic} In this check $\prover$ claims that he knows $x,y,z\in\bbF^{ml}$ such that $x \circ y = z$. $\prover$ starts with encoding each of $x, y, z$ and obtains $\oracle_x, \oracle_y, \oracle_z$. Then $\prover$ performs column wise commitments and gets $\cm_x, \cm_y, \cm_z$. The following check ensures that if any of the $\oracle_x, \oracle_y, \oracle_z$ is malformed, which is not far away from a correct encoding of any of the $x, y, z$, then $\verifier$ rejects with very high probability.
	\begin{enumerate}
		\item $\prover \rightarrow \verifier: $ $\prover$ sends $\cm_x, \cm_y, \cm_z$ to $\verifier$.
		
		\item $\verifier \rightarrow \prover: $ $\verifier$ picks $r$ uniformly at random from $\bbF^{m}$ and sends $r$ to $\prover$.
		
		\item $\prover \rightarrow \verifier: $ $\prover$ computes the polynomial $p(\cdot)= \sum_{i\in [m]} [r_i\cdot (\hat{f}^x_i(\cdot)\cdot \hat{f}^y_i(\cdot) - \hat{f}^z_i(\cdot))] $ and sends $p(\cdot)$ to $\verifier$. 
		
		\item $\verifier \rightarrow \prover: $ $\verifier$ sends $t$ randomly sampled indices $Q=\{j_u\}_{u\in[t]}$ from $[n]$.
		
		\item $\prover \leftrightarrow \verifier: $ $\prover$ and $\verifier$ run a subprotocol to prove the innerproduct arguement for the following statement $\innp{r\circ \oracle_x[\cdot,j_u]}{\oracle_y[\cdot,j_u]} - \innp{r}{\oracle_z[\cdot,j_u]} = p(\eta_{j_u})$ $\forall u\in[t]$. 
		
		There are two inner products in the above statement and the prover does not want to reveal the values of the individual inner products. Hence, \name2D combine them into a single inner product relation.
		
		For each $u\in[t]$, $\prover$ runs the following inner product arguement with $\verifier$:
		$$\innp{(r\circ \oracle_x[\cdot,j_u]||r)}{(\oracle_y[\cdot,j_u]||-\oracle_z[\cdot,j_u])} = p(\eta_{j_u})$$
		To facilitate this, $\oracle_x, \oracle_y$ and $\oracle_z$ should have been committed with different independently chosen sets of generators. And, the set of generators used for committing $r$ (to be concatenated with $r \circ \oracle_x [\cdot, j_u])$ should also be independent of the above three sets of generators. $\verifier$ proceeds if the arguements succeed for all $u\in[t]$.
		\item $\verifier$ checks if $p(\zeta_j)=0$ $\forall j\in[l]$. If yes then accepts, else rejects.
	\end{enumerate}
	
	\begin{theorem}
		For $ e < \frac{d}{3}, $ if $\innp{\prover^*(\cm_1, \cm_2, \cm_3 , \calU^*_1	, \calU^*_2, \calU^*_3)}{\verifier(\cm_1, \cm_2, \cm_3)} \rightarrow 1$ then there is an expected $\ppt$  $\extrac^{\prover^*}(\cm_i)\rightarrow \calU^*_i$ $\forall i\in [3]$ such that with overwhelming probability $\forall i \in [3]$, $\calU^*_i$ satisfies one of the following event: 
		\begin{itemize}
			\item $\com(\calU^*_i) = \cm_i$ and $(\vee_{i=1}^{3} d(\calU^*_i, L^m)> e)$ 
			\item $\com(\calU^*_i) = \cm_i$ and $\wedge_{i=1}{3} d(\calU^*_i,L^m)\leq e$ and $ x_i = \dec(\calU_i)$, where $\calU_i$ is the nearest codeword to $\calU^*_i$, for all $i\in [3]$, such that $x_1 \circ x_2 = x_3$
			\item $\extrac$ breaks the binding of the commitment scheme.
		\end{itemize} 
	
	\end{theorem}
	\begin{proof}
	We have a $\ppt$ extractor, $\extrac_{innp}$, for the inner product arguement for the statement $\innp{\bm{a}}{\bm{b}}=c$ where $\bm{a},\bm{b}$ are private, which can extract either $\bm{a}, \bm{b}$ or breaks binding property of the commitment scheme with overwhelming probability. Now we will use $\extrac_{innp}$ to design an expected $\ppt$ extractor $\extrac$ which can extract $\calU^*_1, \cal^*_2, \cal^*_3$ for which the arguemnet is accepted in the above protocol.
	
	$\extrac$ emulates $\verifier$'s role in the protocol till step 4, then calls $\extrac_{innp}$ to get $(r\circ \calU^*_1[\cdot,j_u]||r)$ and $(\calU^*_2[\cdot,j_u]||-\calU^*_2[\cdot,j_u])$ forall $u\in [t]$ or breaks the binding property of the commitment scheme. $\extrac$ stores all the indices in a set say $S$. From the output of $\extrac_{innp}$, $\extrac$ computes $\calU^*_1[\cdot,j_u], \calU^*_2[\cdot,j_u],\calU^*_3[\cdot,j_u]$. $\extrac$ rewinds $\prover$ to step 4 and again picks a random $Q$. $\extrac$ keeps repeating the above process till $|S|=n$.
	 
	If $|S|=n$, then $\extrac$ has the whole of $\calU^*_1, \calU^*_2, \calU^*_3$.
	
	Then $\extrac$ checks if $\com(\calU^*_i)=\cm_i$, if no, then outputs a collision for the binding of the commitment scheme, else computes $d(\calU^*_i, L^m)$ for all $i \in [3]$:
	
	\begin{itemize}
		\item if $\vee_{i=1}^{3} d(\calU^*_i, L^m) > e$, then outputs $\calU^*_i \forall i\in [3]$.
		
		\item if $\wedge_{i=1}^3 d(\calU^*_i, L^m) \leq e$, then by soundness analysis in \cite{Ligero2017}, the nearest codewords of $\calU^*_1, \calU^*_2, \calU^*_3$ decode to $x, y, z$ repesctively such that probability that $x \circ y \neq z$ is $\negl(\lambda)$. That means the decoded values of the nearest codewords of $\calU^*_1, \calU^*_2, \calU^*_3$ satisfy $x\circ y = z$ with very high probability.
	\end{itemize}
	 
	Similar analysis of Theorem~\ref{theo:proximity} proves that $\extrac$ requires polynomially many rewinding to extract the witness $x, y, z$.
	\end{proof}
	
		
	\paragraph{\textbf{Complete protocol:}} Let $L$ be a language in $\NP$ and $\stmt$ is an instance of $L$. Let $\prover$ be a prover that claims that the instance $\stmt$ is true, i.e. $\prover$ has a witness $\wit$ such that there is deterministic circuit $\C$ such that $\C(\stmt,\wit)=1$ iff $\stmt \in L$. 
	
	Now $\prover$ wants to convince a verifier $\verifier$ that $\stmt\in L$ without revealing any information about the witness $\wit$. 
	
	To do that $\prover$ gives a proof that $\C$ on input $(\stmt, \wit)$ is correctly executed and output 1. In other words $\prover$ proves that gate by gate evaluation is correctly done on an input which has a public part known to both $\prover$ and $\verifier$, and a private part which is only known to $\prover$. 
	Note that $\C$ and $x$ both known to $\prover$ and $\verifier$. So without loss of generality we can assume that $\stmt$ is hardcoded in $\C$.
	
	$\prover$ constructs the extended witness $\extwit$ in the following way: \\
	Let $\C:\bbF^{n_i}\rightarrow \bbF$ such that $\prover$ has private input $\wit = (\wit_1,\ldots, \wit_{n_i})$ such that $\C(\wit)=1$.
	
	Define the extended witness $\extwit = (\wit_1,\ldots,\wit_{n_i}, \beta_1,\ldots, \beta_s) \in \bbF^{ml}$, where $\beta_i$ is the output of the $i^{th}$ gate evaluating $\C(\wit)$, and $s$ is the number of gates in $\C$ and $ml>n_i + s$. $\prover$ defines a system of constraints that contains the following constraint for every multiplication gate g in the circuit $\C$ $$\beta_{a}.\beta_{b}-\beta{c}=0$$
	and for every addition gate, the constraint 
	$$\beta_a + \beta_b - \beta_c = 0$$
	Where $\beta_a$, $\beta_b$ are the input values to the gate g and $\beta_c$ is the output value in the extended witness. For the output gate include the constraint $\beta_a + \beta_b - 1 = 0$ if the final gate is an addition gate, and $\beta_a\cdot \beta_b - 1 = 0$ if the final gate is an multiplication gate. 
	
	$\prover$ constructs vectors $x,y,z \in \bbF^{ml}$ where the $j^{th}$ entry of $x,y$ and $z$ contains the values $\beta_a, \beta_b$ and $\beta_c$ corresponding to the $j^{th}$ multiplication gate in $\extwit$.
	
	$\prover$ and $\verifier$ construct matrices $A, B$ and $C \in \bbF^{ml \times ml}$ such that 
	$$x = A \extwit, y= B \extwit, z= C \extwit$$
	
	Finally it constructs $P_{add} \in \bbF^{ml \times ml}$ such that the $j^{th}$ position of $P_{add} \extwit$ equals $\beta_a + \beta_b - \beta_c$ where $a, b$ and $c$ correspond to the $j^{th}$ addition gate of the circuit in $\extwit$.
	
	$\prover$ encodes $\extwit , x, y , z$ using the defined encoding in sec:~\ref{subsec: encode} and gets $\oracle_{\extwit}, \oracle_x, \oracle_y$ and $\oracle_z$ and commit each of them using Pedersen vector commitment described in ~\ref{subsec: commit} and gets $\cm_{\extwit}, \cm_x, \cm_y, \cm_z$. To commit, pick different set of generators for each $\oracle_{\extwit}, \oracle_x, \oracle_y, \oracle_z$, which will give the property that commitment of $\oracle_{\extwit||x}$ is $\cm_{\extwit} \circ \cm_x$. Where $\extwit||x$ means that a new matrix is formed by adjoining columns of $\extwit$ followed by the columns of $x$. 
	
	In the following protocol, $\verifier$ picks a random index set $Q\subseteq [n]$ of size $t$ and uses this $Q$ in all the followimg subprotocols.
	\begin{enumerate}
		\item $\prover \leftrightarrow \verifier: $ $\prover$ and $\verifier$ run the subprotocol ~\ref{sec:proximity} for proximity check for the matrix $\extwit||x||y||z$. Which is encoded to the matrix $\oracle{\extwit||x||y||z}$, and $\cm_{\extwit||x||y||z}$ is the corresponding commitment.
		
		\item $\prover \leftrightarrow \verifier: $ $\prover$ and $\verifier$ run the subprotocol ~\ref{sec: linearity} for the linearity check for the public matrix $P_{add}$ of dimension $ml\times ml$, and the public vector is the 0-vector of length $ml$. This check ensures that the addition gates are corretly evaluated.
		
		\item $\prover \leftrightarrow \verifier:$ $\prover$ and $\verifier$ run the subprotocol ~\ref{sec: linearity} for linearity check for the public matrix $[A|-I]$ where $I$ is the identity matrix of dimension $ml \times ml$, and the public vector is the 0 vector of length $2ml$. This check ensures that $x$ is correctly computed from $\extwit$.
		
		\item $\prover \leftrightarrow \verifier:$ $\prover$ and $\verifier$ run the subprotocol ~\ref{sec: linearity} for linearity check for the public matrix $[B|-I]$ where $I$ is the identity matrix of dimension $ml \times ml$, and the public vector is the 0 vector of length $2ml$.This check ensures that $y$ is correctly computed from $\extwit$.
		
		\item $\prover \leftrightarrow \verifier:$ $\prover$ and $\verifier$ run the subprotocol ~\ref{sec: linearity} for linearity check for the public matrix $[C|-I]$ where $I$ is the identity matrix of dimension $ml \times ml$, and the public vector is the 0 vector of length $2ml$.This check ensures that $z$ is correctly computed from $\extwit$.
		
		\item $\prover \leftrightarrow \verifier:$ $\prover$ and $\verifier$ run the subprotocol ~\ref{sec: quadratic} for quadratic check to prove that $x \circ y = z$.
		
		\item If $\prover$ passes all the above check, then $\verifier$ accepts the arguement, else rejects.
	\end{enumerate}
	
	Note that if $\prover$ executed all the steps correctly, then it passes all the checks and so $\verifier$ accepts the proof. So completeness holds for the protocol.
	
	To prove the proof of knowledge we will design an extractor which will output a witness if the arguement is accepted.
	
	\begin{theorem}
		For $e < \frac{d}{3}$, if $\innp{\prover^*(\cm_{\extwit||x||y||z}, \calU^*)}{\verifier(\cm_{\extwit||x||y||z})} \rightarrow 1$, then there is an expected $\ppt$ $\extrac^{\prover^*}(\cm_{\extwit||x||y||z}) \rightarrow \calU^*$ such that with overwhelming probability $\calU^*$ satisfies one of the following events:
		\begin{itemize}
			\item $\com(\calU^*)=\cm_{\extwit||x||y||z}$ and $A\extwit = x \wedge B \extwit = y \wedge C \extwit = z \wedge x\circ y =z \wedge P_{add} \extwit = 0$
			\item $\extrac$ breaks the binding property of the commitment scheme.
			
		\end{itemize}
		Let $\cm$ is the commitment of $\calU$, used in above protocol by $\prover$. If $\verifier$ accepts the arguement generated by $\prover$, then there is an expected $\ppt$ extrator $\extrac$ having rewinding access to $\prover$, with polynomially many rewindings either outputs a correct $\extwit$ or breaks the binding property of the commitment scheme.
	\end{theorem}
	\begin{proof}
		We have extractors for the proximity check, linearity check and quadratic check, say $\extrac_{prox}, \extrac_{lin}, \extrac_{quad}$ are the extractors respectively. Using these extractors we will design  $\extrac$ for the complete protocol. 
		
		$\extrac$ emulates the role of the verifier and starts the protocol. 
		
		In the first step it calls $\extrac_{prox}$ and $\calU_1^*$.
		
		After executing the first step it calls $\extrac_{lin}$ and gets $\calU_2^*$. If $\calU_1^* = \calU_2^*$, then outputs collision and terminates.
		
		After executing the second if it is not terminated, it calls $\extrac_{lin}$ in the step 3, 4, 5 and gets $\calU_3^*$. 
		
		In the above 2 steps it gets collision that breaks the binding of the commitment otherwise proceeds.
		
		In this step $\extrac$ calls $\extrac_{quad}$, by concatanating the output of $\extrac_{quad}$ construct final matrix which equates with $\calU_1^* (=\calU_2^*=\calU_3^*)$. If not then that gives break of the binding property of the commitment scheme. Otherwise $\calU^*=\calU_1^*$ should satisfy the following:
		\begin{itemize}
			\item $\com(\calU*)=\cm_{\extwit}\cdot\cm_x\cdot\cm_y\cdot\cm_z$.
			\item $d(\calU^*,L^{4m}) < e$ and let $\calU$ is the closest codeword of $\calU^*$. Define $\oracle_{\extwit}$ to be the first $m$ rows of $\calU$
			
			Define $\oracle_{x}$ to be the $(m+1)^{th}$ rows to $2m^{th}$ rows of $\calU$
			
			Define $\oracle_{y}$ to be the $(2m+1)^{th}$ rows to $3m^{th}$ rows of $\calU$
			
			Define $\oracle_{z}$ to be the $(3m+1)^{th}$ rows to $4m^{th}$ rows of $\calU$
			
			Let $w= \dec(\oracle_{\extwit}), x=\dec(\oracle_x), y=\dec(\oracle_y), z=\dec(\oracle_z)$ such that
			
			$A\extwit = x \wedge B \extwit = y \wedge C \extwit = z \wedge x\circ y =z \wedge P_{add} \extwit = 0$.
		\end{itemize}
		Therefore $\extwit$ is a correct witness. Since all the above extractors use polynomial number of rewindings, $\extrac$ uses polynomial number of rewindings.		
	\end{proof}

\subsection{Zero - Knowledge}
	Above defined three subprotocols are not zero-knowledge inherently. But converting them into zero-knowledge is easy. 
	
	Consider the proximity check: In this subprotocol, $\verifier$ is learning $u = \gamma^T\oracle_{x}$, whihc he can't compute on his own. To prevent that modify $\oracle_{x}$ in the following way: include a random codeword in $(m+1)^{th}$ row, which blinds $u$ and makes $u$ a random codeword. 
	In the remaining part, $\prover$ sends $\cm$, hiding property of the commitment scheme ensures that it does reveal any information.
	Innerproduct proofs are given for $t$ columns. Instead of giving the proof, If $\prover$ opens $t$ columns of $\oracle_{x}$, still it does not reveal any information about $x$, since $t$ is smaller than the degrees of the polynomials used in $\enc$.
	
	Consider the linear check: In the first step $\prover$ sends $\cm_x$ to $\verifier$. The hiding property of the commitment scheme ensures that $\verifier$ is getting no information about $\calU^*_x$ or $x$.
	Then $\prover$ sends $p(\cdot) = \sum_{i\in[m]} R_i \cdot \hat{f}^x_i(\cdot)$ to check that if $\sum_{j\in [l]} p(\zeta_j) = 0$. But $\verifier$ instead of learning whether $\sum_{j\in[l]} p(\zeta_j) = 0$ or not, gets the complete polynomial $p(\cdot)$. To avoid leaking additional information we need to blind $p(\cdot)$ by adding a blinding polynomial $p_{blind}(\cdot)$ of degree $< k + l - 1$ such that $\sum_{j\in[l]} p_{blind}(\zeta_j) = 0$. Include a new row to $\oracle_x$ at the end where $j^{th}$ entry of the row is $p_{blind}(\eta_j)$ $\forall j\in [n]$.
	Since number of inner product proofs is less than $t$, no information is leaked.
	
	Consider the quadratic check: In the first step commitments do not leak any information about the witness or it's encoded values.
	Then $\prover$ sends $p(\cdot) = \sum_{i\in[m]} [r_i\cdot (\hat{f}^x_i(\cdot)\cdot \hat{f}^y_i(\cdot) - \hat{f}^z_i(\cdot)]$. $\verifier$ is allowed to learn only if $p(\zeta_j)=0$ or not for all $j\in[l]$. To avoid leaking more information about $p(\cdot)$ we need to blind it. To do that pick a random polynomial $p_{blind}(\cdot)$ such that $p_{blind}(\zeta_j) = 0$ $\forall j\in [l]$. accordingly update $\oracle_x, \oracle_y,\oracle_z$ in the following way: pick there random codewords which are encodings of zeros, and append one of them each at the last of $\oracle_{x}, \oracle_{y}, \oracle_{z}$.
	Inner product arguement is same as Proximity and linear check, it does not require any changes. 
	
	\paragraph{Deisgning the simulator for the complete protocol: } In an actual execution of the protocol generates a transcript of the form:
	\begin{align*}
		\tau = \{ 
				& \cm_{\extwit||x||y||z},\\
				& \gamma(\in_R \bbF^{m}), r_1(\in_R \bbF^{ml}), r_2(\in_R \bbF^m), \\ 
				& (u' = u+u_{blind}), (q^{lin}(\cdot) = p^{lin}(\cdot)+p^{lin}_{blind}(\cdot)), (q^{quad}(\cdot) = p^{quad}(\cdot) + p^{quad}_{blind}(\cdot)),\\
				& Q (|Q|=t),\\
				& \text{ inner product proof for } \\
				& (\innp{\gamma}{\oracle_{\extwit||x||y||z}[\cdot, Q]} = u_Q, \innp{R_Q}{\oracle_{\extwit||x||y||z}[\cdot, Q]}=q^{lin}(\eta_Q),\\
				& \innp{(r\circ \oracle_x[\cdot,j_u]||r)}{(\oracle_y[\cdot,j_u]||-\oracle_z[\cdot,j_u])} = q^{quad}(\eta_{j_u})
			\}
	\end{align*}
	Consider a protocol, which is same as above protocol with the difference that $\prover$ instead of proving the inner product arguements opens the corresponding columns of $\oracle$. If this new protocol has zero knowledge property then our protocol also have zero knowledge property, since in our protocol whatever $\verifier$ can compute, $\verifier$ of the new protocol can also compute. It is easy to prove this by reduction.
	
	Now we will prove that the new protocol is zero-knowledge. It will have the transcript of the following form:
	\begin{align*}
	\tau' = \{
	& \cm_{\extwit||x||y||z},\\
	& \gamma(\in_R \bbF^{m}), r_1(\in_R \bbF^{ml}), r_2(\in_R \bbF^m), \\ 
	& (u' = u+u_{blind}), (q^{lin}(\cdot) = p^{lin}(\cdot)+p^{lin}_{blind}(\cdot)), (q^{quad}(\cdot) = p^{quad}(\cdot) + p^{quad}_{blind}(\cdot)),\\
	& Q (|Q|=t),\\
	& \oracle_{\extwit}[\cdot, Q], \oracle_{x}[\cdot, Q], \oracle_{y}[\cdot, Q], \oracle_{z}[\cdot, Q]
	 \}
	\end{align*}
	
	Let $\Sim$ be the simulator. $\Sim$ does the following:
	\begin{itemize}
		\item  picks a random subste $Q$ of size $t$.
		\item  uniformly at random chooses $\gamma \in \bbF^m$.
		\item  uniformly at random chooses $r_1 \in \bbF^{ml}$ and $r_2 \in \bbF^m$.
		\item  chooses $t$ columns for $\oracle_{\extwit||x||y||z}$ according to the indices of $Q$.
		\item  computes the commitment of columns indexed by $Q$ for $\oracle_{\extwit||x||y||z}$, and for remaining positions picks uniform values from the range of $\com$, that fixes $\cm_{\extwit||x||y||z}$.
		\item  computes components of $u'$ indexed by $Q$ using $\oracle_{\extwit||x||y||z}$ and $\gamma$. Out of $n$ for remaining $n-t$ picks values for $u'$ in such a way that $u'$ is a valid coedword.
		\item  picks a random polynomial $q^{lin}(\cdot)$ such that degree is $<k+l-1$ and $\sum_{j\in [l]} q^{lin}(\zeta_j) = 0$.
		\item  picks a random polynomial $q^{quad}(\cdot)$ such that degree is $<2k-1$ and $q^{quad}(\zeta_j) = 0$ $\forall j\in [l]$.
	\end{itemize} 
	Then $\Sim$ outputs a transcript $\tau''$ which is computationally indistinguishable from $\tau'$. Therefore the new protocol has zero knowledge property, and hence \name2D has zero-knowledge property.
	
	\bibliographystyle{plain}
	\bibliography{references}
\end{document}
