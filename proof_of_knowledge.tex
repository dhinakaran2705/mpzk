\documentclass[runningheads]{llncs}
%packages---------------------------------
\usepackage{amsmath} %for matrix
\usepackage{amsfonts} %for mathbb
\usepackage{bm}
\usepackage{xcolor} %for red color text in pnote
\usepackage{comment}
%newcommands------------------------------
\newcommand{\innp}[2]{\langle #1,#2\rangle}
\newcommand{\name}{\textsf{ours}}
%comments---------------------------------
\newcommand{\pnote}[1] {\textcolor{red}  {PKP: \sl{#1}}}
%macros-----------------------------------
\def\ppt{\mathsf{PPT}}
\def\extrac{\mathcal{E}}
\def\prover{\mathsf{P}}
\def\verifier{\mathsf{V}}
\def\RS{\mathsf{RS}} %Reed Solomon encoding
\def\cm{\mathsf{cm}} %Commitment vector
\def\com{\mathsf{com}} %Commitment protocol
\def\negl{\mathsf{neg}}
\def\NP{\mathsf{NP}}
\def\C{\mathsf{C}} %Circuit

\def\calA{\mathcal{A}}
\def\calB{\mathcal{B}}
\def\calC{\mathcal{C}}
\def\calD{\mathcal{D}}
\def\calE{\mathcal{E}}
\def\calF{\mathcal{F}}
\def\calG{\mathcal{G}}
\def\calH{\mathcal{H}}
\def\calI{\mathcal{I}}
\def\calJ{\mathcal{J}}
\def\calK{\mathcal{K}}
\def\calL{\mathcal{L}}
\def\calM{\mathcal{M}}
\def\calN{\mathcal{N}}
\def\calO{\mathcal{O}}
\def\calP{\mathcal{P}}
\def\calQ{\mathcal{Q}}
\def\calR{\mathcal{R}}
\def\calS{\mathcal{S}}
\def\calT{\mathcal{T}}
\def\calU{\mathcal{U}}
\def\calV{\mathcal{V}}
\def\calW{\mathcal{W}}
\def\calX{\mathcal{X}}
\def\calY{\mathcal{Y}}
\def\calZ{\mathcal{Z}}

\def\bbA{\mathbb{A}}
\def\bbB{\mathbb{B}}
\def\bbC{\mathbb{C}}
\def\bbD{\mathbb{D}}
\def\bbE{\mathbb{E}}
\def\bbF{\mathbb{F}}
\def\bbG{\mathbb{G}}
\def\bbH{\mathbb{H}}
\def\bbI{\mathbb{I}}
\def\bbJ{\mathbb{J}}
\def\bbK{\mathbb{K}}
\def\bbL{\mathbb{L}}
\def\bbM{\mathbb{M}}
\def\bbN{\mathbb{N}}
\def\bbO{\mathbb{O}}
\def\bbP{\mathbb{P}}
\def\bbQ{\mathbb{Q}}
\def\bbR{\mathbb{R}}
\def\bbS{\mathbb{S}}
\def\bbT{\mathbb{T}}
\def\bbU{\mathbb{U}}
\def\bbV{\mathbb{V}}
\def\bbW{\mathbb{W}}
\def\bbX{\mathbb{X}}
\def\bbY{\mathbb{Y}}
\def\bbZ{\mathbb{Z}}
%-----------------------------------------
\begin{document}
\section{Proof of Knowledge}
	For \name2D protocol, we claim that the protocol has special soundness property. That is there is a $\ppt$ machine $\extrac$ that has oracle access to the prover $\prover$ such that by rewinding $\prover$, $\extrac$ can output the witness $w$ such that for which $\prover$ can convince $\verifier$.
	
	We will prove the above claim by proving that each subprotocols have the special correctness property. 
	Suppose $x$ is encoded using interleaved $\RS$ encoding, then each column is commited using pederson commitment. That is if $|x|=ml$ then read $x$ as 
	$$x=
	\begin{bmatrix}
		x_{11} & x_{12} & \ldots & x_{1l}\\
		x_{21} & x_{22} & \ldots & x_{2l}\\
		& \vdots\\
		x_{m1} & x_{m2} & \ldots & x_{ml}
	\end{bmatrix}
	$$	
	\subsubsection{Encoding:} Construct polynomials $\hat{f}^x_i(\cdot)$ of deg $k$ such that $\hat{f}^x_i(\zeta_j)=x_{ij}$ $\forall i\in [m], j\in [l]$ where $k>l$ and $l+t=k$.
	
	Define 
	$$\calU^{\RS}_x =
	\begin{bmatrix}
		u_{11} & u_{12} & \ldots & u_{1n}\\
		u_{21} & u_{22} & \ldots & u_{2n}\\
		& \vdots\\
		u_{m1} & u_{m2} & \ldots & u_{mn}
	\end{bmatrix}
	$$
	where $u_{ij}= \hat{f}^x_i(\eta_j)$ $\forall i\in[m], j\in[n]$ $n>k$. $\bm{\zeta}=\{\zeta_1,\ldots,\zeta_l\}$ we will call it interpolation domain and $\bm{\eta} = \{\eta_1,\ldots,\eta_n\}$ we will call it evaluation domain.
	
	\subsubsection{Commitment:} Then compute the commitment of $\calU^{\RS}_x$. Let $\cm_x=(c_1,\ldots c_n)$ where $c_j= \com( \begin{bmatrix}
	u_{1j} & u_{2j} & \ldots & u_{mj}
	\end{bmatrix}^T)$ $\forall j\in [n]$
\paragraph{\textbf{Proximity Check:}} In this check $\prover$ convinces $\verifier$ that $\cm_x$ is the commitment of a correct codeword matrix $\calU^{\RS}_x$ which is encoding of a matrix $x$. If $\calU^{\RS}_x$ is malformed, i.e. if it is sufficiently far away from a correct codeword matrix, then $\prover$ passes the following check with $\negl(t)$ probability.
	\begin{enumerate}
		\item $\prover \rightarrow \verifier :$ $\prover$ sends $cm$ to $\verifier$.
		\item $\verifier \rightarrow \prover :$ $\verifier$ as a challenge picks $\gamma \in \bbF^m$ uniformly at random and sends it to $\prover$.
		\item $\prover \rightarrow \verifier :$ $\prover$ computes $w=\gamma^T\calU^{\RS}_x$ and sends $w$ to $\verifier$.
		\item $\verifier \rightarrow \prover :$ $\verifier$ picks a random subset $Q\subseteq [n]$ such that $|Q|=t$ and sends $Q$ to $\prover$.
		\item $\prover \leftrightarrow \verifier: $ $\prover$ and $\verifier$ run a subprotocol to prove the innerproduct arguement for the following statement $\innp{\gamma}{\calU^{\RS}_x[\cdot,j_u]}=w_{j_u}$ $\forall j_u\in Q$
		\item If $\verifier$ accepts the innerproduct arguement in step 5, then checks if $w\in L$. If yes then $\verifier$ outputs accept else outputs reject.
	\end{enumerate}
	
	Note that the subprotocol for innerproduct arguement has the special soundness property. So there is an $\extrac_{innp}$ for the innerproduct argument which is $\ppt$ machine and outputs the witness if the arguement is accepted.
	\begin{theorem}\label{theo:1}
		There is an $\ppt$ extractor $\extrac$ which has oracle access to $\prover$ such that rewinding a certain step of $\prover$, $\extrac$ can output the witness $x$ with overwhelming probability for which $\prover$ can convince $\verifier$.
	\end{theorem}
	%\pnote{Need to check for $\extrac$ is rewinding $\prover$ or $\verifier$?}
	\begin{proof}
		Now we will design a $\ppt$ $\extrac$ for the above protocol.
		In step 4 $\extrac$ emulates $\verifier$ and picks $Q$ uniformly at random, then if innerproduct arguement is accepted then run $\extrac_{innp}$, in polytime with overwhelming probability. $\extrac_{innp}$ outputs $\calU^{\RS}_x[\cdot,j_u]$ $\forall j_u\in Q$, and stores the indices of $Q$ in a set $S$. then rewinds to the step 4 and then again picks $Q$ uniformly at random, $\extrac$ keeps extracting $\calU^{\RS}_x[\cdot,j_u]$ and updates $S$ by including only the new indices repeating until $|S|>k$.
		
		In the next step $\extrac$ gets $\calU^{\RS}_x[\cdot,j_u]$ $\forall j_u \in S$. Since $|S|>k$, from $\calU^{\RS}_x[\cdot,j_u]$ decoding is deterministic, so the $\extrac$ decodes $\calU^{\RS}$ to $x$ and outputs $x$.
		
		Now we need to prove that the number of rewinding is polynomial.
		
		To get the bound on the expected number of rewindings consider $t=1$ and $k=n$. 
		
		Let $X$ be the discrete random variable that represents the number of purchases until each of the $n$ column is picked at least once.
		
		Let $X_i$ be the discrete random variable that represents the number of rewindings after the $(i-1)^{th}$ distinct column to select the $i^{th}$ distinct column. As a base case, $X_1=1$, because the first column selected will always be distinct.
		
		By Linearity of expectation, $E[X]=\sum_{i=1}^{n}E[X_i]$
		
		After the $(i-1)^{th}$ distinct column is picked, there are $n-i+1$ columns remaining to be picked. Let $A_i$ be the event that one of those columns is picked in the next rewinding. Then $Pr(A_i)=\frac{n-i+1}{n}$.
		

		 $X_i$ follows a geometric distribution (of trials). It's expected value is
		 $$E[X_i]= \frac{1}{Pr(A_i)} = \frac{n}{n-i+1}$$
		From before, $E[X]$ is equal to the sum of all these expectations: i.e.
		$$E[X] = \sum\limits_{i=1}^{n} \frac{n}{n-i+1} = n\sum\limits_{i=1}^{n} \frac{1}{i} \approx n \log n$$
		Which is polynomial in $n$ and so polynomial in security parameter.
		%\pnote{Remaining analysis is to check the expected number of rewinding required to obtain $\calU^{\RS}$.}
	\end{proof}
	
	\paragraph{\textbf{Linear Check:}} In this check, there is a publicly known matrix $A \in \bbF^{ml\times ml}$ and public vector $b\in \bbF^{ml}$, and $\prover$ claims that he knows a $x$ such that $Ax=b$ is true. $\prover$ starts with encoding the $x$ using interleaved $\RS$ code which is described above and gets $\calU^{\RS}_x$, then he computes the commitment $\cm_x$ in the same way mentioned above. Now the following check ensures that if a maformed $\calU$ is used for $\calU^{\RS}$, which is not far away from a correct encoding of $x$ for which $Ax\neq b$, then $\verifier$ outputs reject with very high probability.
	\begin{enumerate}
		\item $\prover \rightarrow \verifier: $ $\prover$ sends $\cm_x$ to $\verifier$.
		\item $\verifier \rightarrow \prover: $ $\verifier$ picks a random $r\in \bbF^{ml}$ and sends that $r$ to $\prover$.
		\item $\prover$ and $\verifier$ compute $R=r^TA$, which is a vector of size $ml$. Read $R$ in a matrix form where first $l$ elements of $R$ forms the first row, next $l$ elements forms the second row, similary $R$ will have $m$ rows. Then they construct polynomials $R_i(\cdot)$ of degree $<l$ such that $R_i(\zeta_j)=R_{ij}$ $\forall i\in [m], j\in [l]$. 
		\item $\prover \rightarrow \verifier: $  $\prover$ computes a polynomial $p(\cdot)=\sum_{i\in[m]} ( R_i(\cdot)\cdot \hat{f}^x_i(\cdot))$ and sends $p(\cdot)$ to $\verifier$.
		\item $\verifier \rightarrow \prover: $ $\verifier$ samples $t$ distinct  indices $j_1,\ldots,j_t$ from the set $[n]$ independently at random and sends the indices to $\prover$.
		\item $\prover \leftrightarrow \verifier: $ $\prover$ and $\verifier$ run a subprotocol to prove the innerproduct arguement for the following statement $\innp{R_{j_u}}{\calU^{\RS}_x[\cdot,j_u]} = p(\eta_{j_u})$ for all $j_u$ queried in the above step by $\verifier$, where $R_{j_u}=(R_1(\eta_{j_u}),\ldots,R_m(\eta_{j_u})$ and $\calU^{\RS}_x[\cdot,j_u]$ denotes the $m-$length vector $(\calU^{\RS}_x[1,j_u],\ldots, \calU^{\RS}_x[m,j_u])$. $\verifier$ proceeds if the arguments succeed for all $u \in [t]$.
		\item $\verifier$ also checks that $\sum_{j\in[l]} p(\zeta_j)=0$.
		\item $\verifier$ accepts if all the above checks are succeed.	  
	\end{enumerate}
	
	\begin{theorem}
	 There is an $\ppt$ extractor $\extrac$ which has oracle access to $\prover$ such that rewinding a certain step of $\prover$, $\extrac$ can output the witness $x$ for which $Ax=b$ holds with overwhelming probability.
	\end{theorem}
	\begin{proof}
	We have a $\ppt$ extractor, $\extrac_{innp}$, for the inner product arguement for the statement $\innp{\bm{a}}{\bm{b}}=c$ where $a,b$ are private, which can extract $a, b$ with overwhelming probability. Now we will use $\extrac_{innp}$ to design a $\ppt$ extractor $\extrac$ which can extract the witness for the above protocol which is $x : Ax=b$.
	
	 $\extrac$ emulates $\verifier$'s role in the protocol till step 5, then calls $\extrac_{innp}$ to get $\calU^{\RS}_x[\cdot,j_u]$. $\extrac$ stores the indices in a set say $S$ and rewind the prover to step 5 and picks $t$ indices again uniformly at random again and follows the above procedure. $\extrac$ keeps rewinding till $|S|>k$.
	 
	 If $|S|>k$, then $\extrac$ has more than $k$ columns of $\calU^{\RS}_x$ then by the deterministic decoding algorithm will output $x$. Now it is easy to check that whether $x$ satisfies $Ax=b$ or not. 
	 
	 Similar analysis of ~\ref{theo:1} proves that $\extrac$ requires polynomially many rewinding to extract the witness $x$.
	\end{proof}
	\paragraph{\textbf{Quadratic Check:}} In this check $\prover$ claims that he knows $x,y,z\in\bbF^{ml}$ such that $x \circ y = z$. $\prover$ starts with encoding each of $x, y, z$ and obtains $\calU^{\RS}_x, \calU^{\RS}_y, \calU^{\RS}_z$. Then $\prover$ performs column wise commitments and gets $\cm_x, \cm_y, \cm_z$. The following check ensures that if any of the $\calU^{\RS}_x, \calU^{\RS}_y, \calU^{\RS}_z$ is malformed, which is not far away from a correct encoding of any of the $x, y, z$, then $\verifier$ rejects with very high probability.
	\begin{enumerate}
		\item $\prover \rightarrow \verifier: $ $\prover$ sends $\cm_x, \cm_y, \cm_z$ to $\verifier$.
		\item $\verifier \rightarrow \prover: $ $\verifier$ picks $r$ uniformly at random from $\bbF^{m}$ and sends $r$ to $\prover$.
		\item $\prover \rightarrow \verifier: $ $\prover$ computes the polynomial $p(\cdot)= \sum_{i\in [m]} [r_i\cdot (\hat{f}^x_i(\cdot)\cdot \hat{f}^y_i(\cdot) - \hat{f}^z_i(\cdot))] $ and sends $p(\cdot)$ to $\verifier$. 
		\item $\verifier \rightarrow \prover: $ $\verifier$ sends $t$ randomly sampled indices $Q=\{j_u\}_{u\in[t]}$ from $[n]$.
		\item $\prover \leftrightarrow \verifier: $ $\prover$ and $\verifier$ run a subprotocol to prove the innerproduct arguement for the following statement $\innp{r\circ \calU^{\RS}_x[\cdot,j_u]}{\calU^{\RS}_y[\cdot,j_u]} - \innp{r}{\calU^{\RS}_z[\cdot,j_u]} = p(\eta_{j_u})$ $\forall u\in[t]$. 
		
		There are two inner products in the above statement and the prover does not want to reveal the values of the individual inner products. Hence, \name2D combine them into a single inner product relation.
		
		For each $u\in[t]$, $\prover$ runs the following inner product arguement with $\verifier$:
		$$\innp{(r\circ \calU^{\RS}_x[\cdot,j_u]||r)}{(\calU^{\RS}_y[\cdot,j_u]||-\calU^{\RS}_z[\cdot,j_u])} = p(\eta_{j_u})$$
		To facilitate this, $\calU^{\RS}_x, \calU^{\RS}_y$ and $\calU^{\RS}_z$ should have been committed with different independently chosen sets of generators. And, the set of generators used for committing $r$ (to be concatenated with $r \circ \calU^{\RS}_x [\cdot, j_u])$ should also be independent of the above three sets of generators. $\verifier$ proceeds if the arguements succeed for all $u\in[t]$.
		\item $\verifier$ checks if $p(\zeta_j)=0$ $\forall j\in[l]$. If yes then accepts, else rejects.
	\end{enumerate}
	
	\begin{theorem}
	There is a $\ppt$ extractor $\extrac$ which has oracle access to $\prover$ such that rewinding a certain step of $\prover$, $\extrac$ can outputthe witnesses $x, y, z$ such that $x\circ y = z$ holds.
	\end{theorem}
	\begin{proof}
	We have a $\ppt$ extractor, $\extrac_{innp}$, for the inner product arguement for the statement $\innp{\bm{a}}{\bm{b}}=c$ where $a,b$ are private, which can extract $a, b$ with overwhelming probability. Now we will use $\extrac_{innp}$ to design a $\ppt$ extractor $\extrac$ which can extract the witness for the above protocol which is $x,y,z : x \circ y = z$.
	
	 $\extrac$ emulates $\verifier$'s role in the protocol till step 4, then calls $\extrac_{innp}$ to get $(r\circ \calU^{\RS}_x[\cdot,j_u]||r)$ and $(\calU^{\RS}_y[\cdot,j_u]||-\calU^{\RS}_z[\cdot,j_u])$ forall $u\in [t]$. $\extrac$ stores all the indices in a set say $S$. From the output of $\extrac_{innp}$, $\extrac$ computes $\calU^{\RS}_x[\cdot,j_u], \calU^{\RS}_y[\cdot,j_u],\calU^{\RS}_z[\cdot,j_u]$. $\extrac$ rewinds $\prover$ to step 4 and again picks a random $Q$. $\extrac$ keeps repeating the above process till $|S|>k$.
	 
	 If $|S|>k$, then $\extrac$ has more than $k$ columns of $\calU^{\RS}_x, \calU^{\RS}_y, \calU^{\RS}_z$ then by the deterministic decoding algorithm will output $x, y, z$. Now it is easy to check that whether $x, y, z$ satisfies $x \circ y =z$ or not. 
	 
	 Similar analysis of ~\ref{theo:1} proves that $\extrac$ requires polynomially many rewinding to extract the witness $x, y, z$.
	\end{proof}
	
	\begin{comment}	
	\paragraph{\textbf{Complete protocol:}} Let $L$ be a language in $\NP$ and $\alpha$ is an instance of $L$. Let $\prover$ be a prover that claims that the instance $\alpha$ is true, i.e. $\prover$ has a witness $\beta$ such that there is deterministic circuit $\C$ such that $\C(\alpha,\beta)=1$ iff $\alpha \in L$. 
	
	Now $\prover$ wants to convince a verifier $\verifier$ that $\alpha\in L$ without revealing any information about the witness $\beta$. 
	
	To do that $\prover$ gives a proof that $\C$ on input $(\alpha, \beta)$ is correctly executed and output 1. In other words $\prover$ proves that gate by gate evaluation is correctly done on an input which has a public part known to both $\prover$ and $\verifier$, and a private part which is only known to $\prover$. 
	Note that $\C$ and $x$ both known to $\prover$ and $\verifier$. So without loss of generality we can assume that $x$ is hardcoded in $\C$.
	
	$\prover$ constructs the extended witness $w$ in the following way: \\
	Let $\C:\bbF^{n_i}\rightarrow \bbF$ such that $\prover$ has private input $\beta = (\beta_1,\ldots, \beta_{n_i})$ such that $\C(\beta)=1$.
	\end{comment}
\end{document}
