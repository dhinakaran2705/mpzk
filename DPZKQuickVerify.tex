%\newcommand{\enc}{\mathsf{Enc}}
\subsection{Witness Encoding}\label{sec:witencoding}
We start by describing a randomized encoding of the prover witness $\wit\in \FF^N$. Let $p,m$ and
$s$ be integers such that $N=pms$. We canonically view the
witness $\wit$ 
as $p\times m\times s$ matrix with entries $\wit[i,j,k]$ for $i\in [p]$,
$j\in [m]$ and $k\in [s]$. The encoding is specified by an independence 
parameter $\bi$, integers $\ell := s+\bi$, $h>2m$, $n>2\ell$, and sequences
$\bm{\zeta},\bm{\eta},\bm{\alpha}$ of distinct points in $\FF$ with cardinality 
$\ell,n,h$ respectively. We write $\bm{\zeta}=(\zeta_1,\ldots,\zeta_\ell)$,
$\bm{\eta}=(\eta_1,\ldots,\eta_n)$ and $\bm{\alpha}=(\alpha_1,\ldots,\alpha_h)$. 
Next We define the interpolation domain $G$ as $G=\{(\alpha_j,\zeta_k): j\in[m],
k\in [\ell]\}$ and evaluation domain $H$ as $H=\{(\alpha_j,\eta_k): j\in [h],
k\in [n]\}$. Finally, we encode $\wit$ as follows:
\begin{enumerate}[{\rm (i)}]
\item First we embed $\wit$ into a $p\times m\times \ell$ matrix $\hat{\wit}$
where $\hat{\wit}[i,j,k]=\wit[i,j,k]$ for $k\leq s$, while the entries
$\hat{\wit}[i,j,k]$ for $k>s$ are sampled from $\FF$ uniformly at random.
\item We construct bivariate polynomials $Q^i(x,y)$ with $deg_x(Q)<m$ and
$deg_y(Q) $ $<\ell$ such that $Q^i$ interpolates the slice
$\hat{\wit}[i,\cdot,\cdot]$ on $G$, i.e,
$Q^i(\alpha_j,\zeta_k)=\hat{\wit}[i,j,k]$. 
\item Let $\ewit$ denote the $p\times h\times n$ matrix, where the slice
$\ewit[i,\cdot,\cdot]$ consists of evaluations of $Q^i$ on $H$, i.e,
$\ewit[i,j,k]=Q^i(\alpha_j,\eta_k)$ for $i\in [p], j\in [h]$ and $k\in [n]$.
Then $\ewit$ is a randomized encoding of $\wit$.
\end{enumerate}
We denote the above computation as $\ewit\sample \enc(\wit)$, where $\enc(\wit)$
denotes the random variable denoting the encodings of $\wit$. It is easily seen
that $\ewit\in \rsc{\eta}{\ell}\oplus \rsc{\alpha}{m}$. We remark that the above
encoding can be computed using $O(N\log N)$ field operations (see Appendix for
details).
%%  Computing the encoding in O(Nlog N) time: Move to Appendix
%\noindent{\em Efficiently computing the encoding}: Although the previous
%description of the encoding involves the bivariate polynomials, 
%the prover does not explicitly need to compute the bivariate polynomials to
%construct the encoding. We describe an efficient method to construct the
%encoding. Given an $m\times \ell$
%matrix $\matx$, the prover first computes polynomials $p_j$ for $j\in
%[m]$ as $p_j(y) := \ifft(\matx[j,\cdot], \bm{\zeta})$. Then it constructs a $m\times n$
%matrix $\maty$, where the $j^{th}$ row of $\maty$ is evaluation of $p_j$ on the set
%$\bm{\eta}$, i.e, $\maty[j,\cdot] := \fft(p_j, \bm{\eta})$. Next, the prover constructs
%polynomials $q_k$ for $k\in [n]$ by interpolating the column $\maty[\cdot,k]$ on
%$\bm{\alpha}^0 = (\alpha_1,\ldots,\alpha_m)$, i.e, $q_k(x) := \ifft(\maty[\cdot,k],
%\bm{\alpha}^0)$. It obtains the encoding $\enc(\matx)$ as the $h\times n$ matrix
%$\matz$ whose columns are evaluations of polynomials $q_k$ on the set $\bm{\eta}$, i.e,
%$\matz[\cdot,k]=\fft(q_k,\bm{\alpha})$. The above computation involves
%$O(mn\log(mn))$ operations in $\FF$ for each $m\times \ell$ matrix. Thus, computing $\enc(\wit)$ takes
%$O(pmn\log(mn))$ which is $O(N\log{N})$. We also remark that $\maty$ is a submatrix
%of $\matz$, and thus
%$p_j=\ifft((\matz[j,1],\ldots,\matz[j,\ell]),(\eta_1,\ldots,\eta_{\ell}))$ for $j\in
%[m]$. This allows us to consistently define polynomials $p_j$ for $m<j\leq h$ by
%$p_j=\ifft((\matz[j,1],\ldots,\matz[j,\ell]),(\eta_1,\ldots,\eta_{\ell}))$.
%%
The encoding $\enc$ satisfies the following {\em bounded independence} property:
\begin{lemma}[Bounded Independence]\label{lem:boundedindependence}
Let $B\subseteq [n]$ be a set of size $\bi$. Let $\mc{U}(p,h,b)$ denote the
set of $p\times h\times b$ matrices $\matx$ such
that $\matx[i,\cdot,k]$ is a codeword in $\rsc{\alpha}{m}$ for all $i\in
[p],k\in [\bi]$. Then for any $p\times m\times s$ matrix $\wit$, the random
variable $\ewit_B := \{\ewit[\cdot,\cdot,B]: \ewit\sample \enc(\wit)\}$ is
distributed uniformly on $\mc{U}(p,h,b)$.
\end{lemma}
We defer the proof of the above Lemma to the Appendix.

\subsection{Oracle Construction}\label{sec:construct_oracle} 
Unlike prior IOP constructions such as \cite{ligero, aurora}, we additionally
obtain a homomorphic commitment on the encoded witness $\enc(\wit)$ and provide
oracle access to the commitment. Concretely, we use a
homomorphic vector commitment scheme $\comm$ with message space $\FF^h$,
commitment space $\GG$ and randomness space $\FF$. We compute commitments
$c_{ik}=\comm(\ewit[i,.,k],\delta_{ik})$ where $\delta_{ik}$ denotes the
commitment randomness. Finally we define $p\times n$ matrix $\comoracle$ as
$\comoracle[i,k]=c_{ik}$. We provide oracle access to $\comoracle$ where for a
query $Q\subseteq [n]$, the oracle responds with columns $\comoracle[.,k]$ for
$k\in Q$.

\subsection{Codes and Matrices}\label{sec:codesandmatrices}
Throughout, let $L_1$ and $L_2$ denote the codes $\rsc{\eta}{\ell}$ and
$\rsc{\alpha}{m}$ respectively. Let $\mc{C}_1 := \ric{L_1}{h}$ and $\mc{C}_2 :=
\cic{L_2}{n}$ denote the interleaved codes of $L_1$ and $L_2$. We denote the
parity check matrices for $L_1$ and $L_2$ by $\mc{H}_1$ and $\mc{H}_2$. We also
notate the set of three dimensional $p\times h\times n$ matrices as $\mc{M}_{p,h,n}$ and
the set of two dimensional $h\times n$ matrices as $\mc{M}_{h\times n}$. We
assume standard distance metrics on the sets $\mc{M}_{p,h,n}$ and $\mc{M}_{h,n}$
as discussed in Section \ref{sec:prelims}. 

\subsection{Proximity Protocol}\label{sec:proximityprotocols}
In this section we introduce {\em well formed} encodings and
describe a proximity protocol to check that an encoding is well formed.
Let $\mc{W}$ denote the subset of $\mc{M}_{p,h,n}$
consisting of matrices $U$ such that $U[i,\cdot,\cdot]\in L_1\oplus L_2$ for all $i\in [p]$. 
Let $\mc{W}_1$ denote the set of matrices
$U$ in $\mc{M}_{p,h,n}$ such that the $n$-length vector $U[i,j,\cdot]$ is a
codeword in $L_1$ for all $i,j$. Similarly let $\mc{W}_2$ denote the set of
matrices $U$ such that the $h$-length vector $U[i,\cdot,k]$ is a codeword in
$L_2$ for all $i,k$. It can be seen that $\mc{W}=\mc{W}_1\cap \mc{W}_2$. For $U^\ast\in \mc{M}_{p,h,n}$ define
$d(U^\ast,\mc{W}_i)=\min\{\Delta_i(U^\ast,U):U\in \mc{W}_i\}$ for $i=1,2$.
Our goal is to construct an IPCP for proximity that allows a prover to convince a verifier that
the oracle $\comoracle$ opens to a three dimensional matrix $\ewit\in \mc{W}$.
We first need a protocol to check the membership of an $h\times n$ matrix in the
product code $L_1\oplus L_2$.\smallskip

\noindent{\em Membership in Product Code:}
Assume that $U$ is an $h\times n$ matrix, purported to be a codeword in
$L_1\oplus L_2$. Let $\overline{U}$ denote the $h\times \ell$ matrix consisting of
the first $\ell$ columns of $U$. We note that for $U\in L_1\oplus L_2$, we must
have $U=\overline{U}\mc{T}$ for some $l\times n$ matrix $\mc{T}$ of rank $\ell$. Thus, the membership protocol involves the prover sending the column
commitments $\bm{c}=(c_1,\ldots,c_\ell)$ and prove that they correspond to a matrix
$\overline{U}$ such that $\overline{U}\mc{T}\in \mc{C}_2$ (because $\overline{U}\mc{T}\in
\mc{C}_1$ for all $\overline{U}$). Let $\bm{\omega}=(\omega_1,\ldots,\omega_\ell)$ denote 
the randomness used to compute the commitments. We first discuss the protocol
informally. Proving $\overline{U}\mc{T}\in \mc{C}_2$ is equivalent to proving
$(\overline{U}\mc{T})^T\mc{H}_2=\bm{0}$. The verifier can probabilistically
check this by sending random $\tau\sample \FF^n$ and $\delta\sample \FF^{h-m}$
and have the prover prove, $\tau^T(\overline{U}\mc{T})^T\mc{H}_2\delta=0$ which
can be written as $\innp{x}{z}=0$ for $x=\mc{H}_2\delta$ and
$z=\overline{U}\mc{T}\tau$. Since the vector $x$ is public, and the vector $z$
is a linear combination of columns of $\overline{U}$, it's commitment can be
computed from column commitments of $\overline{U}$. Thus, the protocol reduces
to the inner product argument. In the actual protocol, we additionally allow the
prover to randomize $z$ by adding a random codeword $u_0\in L_2$, and commit to
$u_0$ before the verifier's message. This precludes the need for the inner
product argument to be zero knowledge. Throughout our protocols, the witnesses
to the inner product protocols are randomized, which enables us to reduce prover
interaction during distributed proof computation. 

The complete protocol appears in Figure \ref{fig:protocol1}. In the
Figure \ref{fig:protocol1}, $\innerproduct(\FF,\GG,\bm{g},x,\mathsf{cm},v;z,\omega)$ denotes 
an interactive protocol for proving the relation $\innp{x}{z}=v$ and 
$\open(\mathsf{cm})=(z,\omega)$, where $\GG$ denotes the commitment group and 
$\bm{g}$ denotes the generators for vector commitment. 
\begin{figure}[ht]
\begin{framed}
\begin{itemize}
\item {$\proximityTwoD$} $(\FF,\GG, \ell, L_1, L_2,\mathbf{c}; \overline{U},\bm{\omega})$:
\item {\bf Relation}: $\overline{U}=\open(\mathbf{c})$ and $\overline{U}\mc{T}\in \mc{C}_2$.
\begin{enumerate}[{\rm 1.}]
\item $\prover\rightarrow\verifier$: $\prover$ samples a random codeword $u_0\in
L_2$, and computes $d_0=\comm(u_0,\nu_0)$ for $\nu_0\sample \FF$. It sends $d_0$ to $\verifier$.
\item $\verifier\rightarrow \prover$: Verifier samples $\tau\sample
\FF^n$, $\delta\sample \FF^{h-m}$ and sends them to the prover.
\item $\prover\leftrightarrow \verifier$ compute: $\mu=\mc{T}\tau$,
$\mathsf{cm} = d_0+\sum_{i\in [\ell]} \mu_ic_i$, $x=\mc{H}_2\delta$.
\item $\prover$ computes: $z=u_0+\overline{U}\mu$, $\nu=\nu_0+\sum_{i\in [\ell]}\mu_k\omega_k$.
\item $\prover$ and $\verifier$ run the subprotocol:
	\begin{itemize}
	\item $b=\innerproduct(\FF,\GG,\bm{g},x,\mathsf{cm},0;z,\nu)$
	\end{itemize}
\item $\verifier$ accepts if $b=1$.
\end{enumerate}
\end{itemize}
\end{framed}
\caption{Membership Protocol for Product Code}
\label{fig:protocol1}
\end{figure}

We state the correctness of the protocol, deferring the formal proofs to
Appendix.  
\begin{lemma}[Completeness]\label{lem:proximity2d_complete}
For $\overline{U}$ such that $\overline{U}\mc{T}\in \mc{C}_2$, the protocol $\proximityTwoD$ accepts.
\end{lemma}

%\begin{proof}
%For the honest prover, we have:
%\begin{align*}
%\innp{x}{z} &= \innp{\mc{H}_2\delta}{u_0+\overline{U}\mc{T}\tau} \\
%	&= (u_0+\overline{U}\mc{T}\tau)^T\mc{H}_2\delta \\
%	&= u_0^T\mc{H}_2\delta + \tau^T(\overline{U}\mc{T})^T\mc{H_2}\delta \\
%	&= 0 + 0 \text{ as $u_0^T\mc{H}_2=\bm{0}$ and $(\overline{U}\mc{T})^T\mc{H}_2=\bm{0}$ }
%\end{align*}
%It can also be seen that $\mathsf{cm}=\comm(z,\omega)$ and hence by the completeness of the inner product protocol, the verifier accepts.
%\end{proof}
 
\begin{lemma}[Soundness]\label{lem:proximity2d_sound}
For every bounded prover $P^\ast$ and every $\bm{c}\in \GG^\ell$, there exists an
expected polynomial time extractor $\extr$ with
rewinding access to the transcript oracle $\mc{O}=\langle P^\ast(\bm{c},\cdot),V(\bm{c},\cdot)\rangle$
such that $\extr$ either breaks the commitment binding, or outputs a valid
witness with overwhelming probability whenever $P^\ast$ succeeds, i.e,
{\small
\begin{align*}
\condprob{
\begin{array}{l}
\overline{U} = \open(\bm{c}) \wedge \\
\overline{U}\mc{T}\in \mc{C}_2
\end{array}
}{
\begin{array}{l}
\sigma\sample \gen(\secparam) \\
\overline{U}\sample \extr^{\mc{O}}(\bm{c},\sigma)
\end{array}}
\geq \epsilon(P^\ast) - \kappa_{2d}(\lambda)
\end{align*}
}
where $\epsilon(P^\ast)=\condprob{\langle
P^\ast(\bm{c},\sigma),\verifier(\bm{c},\sigma)\rangle = 1}{\sigma\sample
\gen(\secparam)}$ and $\kappa_{2d}$ is negligible in $\lambda$.
\end{lemma}

We now proceed with the construction of the proximity protocol
that allows a prover to prove that a matrix of vector commitments $\pi := \comoracle$ opens to a three
dimensional matrix $\ewit\in \mc{W}$, given oracle access to it. To minimize communication, the key idea is that the verifier chooses
$r\sample \FF^p$ and asks the prover to commit to the two dimensional
matrix $\tilde{U}:=\sum_{i\in [p]}r_i\ewit[i,\cdot,\cdot]$ by sending
commitments $\tilde{c}_1,\ldots,\tilde{c}_\ell$ to the columns of $\tilde{U}$.
Thereafter, we use the protocol $\proximityTwoD$ to check the commitments
correspond to some $U$ such that $U\in L_1\oplus L_2$. To prevent the prover
from sending arbitrary commitments, the verifier checks the consistency of the
commitments with the oracle $\pi$ by querying $t$ columns of the oracle
using a query $Q\subseteq [n]$. For each $k\in Q$, the verifier checks
$\tilde{c}_k = \sum_{i\in [p]}r_i\pi[i,k]$. The soundness relies on the fact
that if the oracle $\pi$ opens to encoding $\ewit$ which is far from a well
formed encoding, by Lemma \ref{lem:compression3d}, with high probability
$\tilde{U}\not\in L_1\oplus L_2$. Thus, an adverserial prover is forced to cheat
by sending several ``inconsistent'' commitments, in which case it fails the
consistency check with overwhelming probability. The complete protocol appears
in Figure \ref{fig:prox3d}. The completeness of the protocol can be directly
verified. We state the soundness property, while deferring the detailed proof to
Appendix.
\begin{figure}[h!]
\begin{framed}
\begin{itemize}
\item {$\proximityThreeD(\FF,\GG,L_1,L_2,[\pi];\ewit)$}
\item {\bf Relation}: $\ewit=\open(\pi)$, $\ewit\in \mc{W}$.
\item {\bf Oracle Setup}: Prover computes $\comoracle$ from $\ewit$ as in
Section \ref{sec:construct_oracle} and sets
$\pi := \comoracle$ as the oracle.
\begin{enumerate}[{1.}]
\item $\verifier\rightarrow \prover$: Verifier samples $r\sample \FF^p$ and
sends $r$ to $\prover$.
\item $\prover$ computes: 
	\begin{itemize}
	\item $\tilde{U}=\sum_{i\in [p]}r_i\ewit[i,\cdot,\cdot]$.
	\item $\tilde{c}_k = \sum_{i\in [p]}r_i\comoracle[i,k]$ for $k\in [\ell]$.
	\end{itemize}
\item $\prover\rightarrow \verifier$: Prover sends
$\tilde{\bm{c}}=(\tilde{c}_1,\ldots,\tilde{c}_\ell)$ to the verifier.
\item $\prover \text{ and } \verifier$: Prover and verifier run the subprotocol:
	\begin{itemize}
	\item $b=\proximityTwoD(\FF,\GG,\ell,L_1,L_2,\tilde{\bm{c}};\tilde{U})$
	\end{itemize}
\item $\verifier$ queries: Verifier samples $Q\subseteq [n]$ of size
$t$ and makes oracle queries for positions in $Q$.
\item Oracle Answers: The oracle responds with columns $\pi[.,k]$ for
$k\in Q$.
\item $\verifier$ checks: The verifier checks $\sum_{i\in
[p]}r_i\pi[i,k]=\sum_{i\in [\ell]}\mc{T}[i,k]\tilde{c}_i$ for $k\in Q$ (the matrix $\mc{T}$ as defined earlier).
\item $\verifier$ accepts if the check passes and $b=1$.
\end{enumerate}
\end{itemize}
\end{framed}
\caption{Proximity Protocol for 3D encoding}
\label{fig:prox3d}
\end{figure}

%\begin{lemma}[Completeness]\label{lem:proximity3d_complete}
%For $\ewit\in\mc{W}$, the protocol $\proximityThreeD$ accepts.
%\end{lemma}
%\begin{proof}
%The assertion follows from the fact that $\ewit\in \mc{W}$ and
%$\ewit=\open(\comoracle)$ implies $\tilde{U}\in L_1\oplus L_2$ and
%$\tilde{U}=\open(\tilde{\mathbf{c}})$, and from the completeness of the protocol
%$\proximityTwoD$.
%\end{proof}

\begin{lemma}[Soundness]\label{lem:proximity3d_sound}
For every bounded prover $P^\ast$ and every oracle $\pi\in \FF^{p\times n}$ and 
proximity parameter $e<d_1/3$,
there exists a polynomial time extractor $\extr$ with rewinding access to
transcript oracle $\mc{O}=\langle P^\ast(\cdot),\verifier^{\pi}(\cdot)\rangle$
such that:
{\small
\begin{align*}
\condprob{
\begin{array}{l}
\ewit=\open(\pi) \wedge \\
\ewit\in \mc{W}_2\wedge \\
d_1(\ewit,\mc{W}_1)\leq e
\end{array}
}{
\begin{array}{l}
\sigma\sample \gen(\secparam)\\
\ewit\sample \extr^{\mc{O}}(\sigma)
\end{array}
}\geq \condprob{\langle
P^\ast(\sigma),\verifier^\pi(\sigma)\rangle=1}{\sigma\sample
\gen(\secparam)}-s_{3d}(\secpar)
\end{align*}
}
for some negligible function $s_{3d}$. Note that in the above, $\extr$ can
rewind and proceed with fresh queries to the oracle $\pi$. 	
\end{lemma}

\subsection{Linear Check Protocol}
In this section, we describe an IPCP that allows a prover to prove knowledge of
witness $\wit\in \FF^N$ satisfying a linear constraint of the form $A\wit = b$
for some $A\in \FF^{M\times N}$ and $b\in \FF^M$. As before we veiw $\wit$ as
$p\times m\times s$ matrix where $N=pms$. As desribed previously in Sections
\ref{sec:witencoding} and \ref{sec:construct_oracle}, we obtain $\ewit\sample 
\enc(\wit)$ and $\comoracle\sample \comm(\ewit)$. We present the full protocol in
Figure \ref{fig:linearcheck}. Below we summarize the key ideas in the protocol.
\smallskip

\noindent {\em Probabilistic Reduction}: To check $A\wit = b$, the verifier samples
random $r\sample \FF^M$ and asks the prover to prove $r^TA\wit = r^Tb$ instead.
\smallskip

\noindent {\em Reduction to Polynomial Identity}: Both prover and verifier view the
vector $r^TA\in \FF^N$ as a $p\times m\times \ell$ matrix $R$ and interpolate
polynomials $R^i(x,y)$ for $i\in [p]$ with $deg_x(R^i)<m$ and $deg_y(R^i)<s$
satisfying $R^i(\alpha_j,\zeta_k)=R[i,j,k]$. Let $Q^i$, $i\in [p]$ denote the
polynomials used in interpolating (and encoding) witness $\wit$. Then, 
$\wit[i,j,k]=Q^i(\alpha_j,\zeta_k)$. The check $\innp{R}{\wit}=r^Tb$ reduces to
$\sum_{i,j,k}R^i(\alpha_j,\zeta_k).Q^i(\alpha_j,\zeta_k)=r^Tb$ where $i,j$ and
$k$ run over indices in $[p],[m]$ and $[s]$ respectively. In principle, the
prover can send the degree $\ell+s$ polynomial
$p(\cdot):=\sum_{i=1}^p\sum_{j=1}^mR^i(\alpha_j,\cdot)Q^i(\alpha_j,\cdot)$ and
the verifier can check $\sum_{k\in [s]} p(\zeta_k)=r^Tb$. 
\smallskip

\noindent {\em Reduction to Inner Product}: Let $\overline{\bm{\zeta}}$ denote the vector $(\zeta_1,\ldots,\zeta_s)$ and let $p(\overline{\bm{\zeta}})$ denote the vector of
evaluations of $p$ on points in $\overline{\bm{\zeta}}$. Similarly, let $\overline{\bm{\eta}}$ denote
the points $(\eta_1,\ldots,\eta_{2\ell})$. The check $\sum_{k\in
[s]}p(\zeta_k)=r^Tb$ can be written as $\innp{1^s}{p(\overline{\bm{\zeta}})}=r^Tb$. 
Let $p_j$ denote the polynomial $\sum_{i\in
[p]}R^i(\alpha_j,\cdot).Q^i(\alpha_j,\cdot)$ for $j\in [h]$. Note that
$p=\sum_{j\in [m]}p_j$. We see that there exists a $2\ell\times s$ matrix
$\Phi$ such that $p(\overline{\bm{\zeta}})=\Phi p(\overline{\bm{\eta}})$. We now describe
how to compute $p(\overline{\bm{\eta}})$ from ``tamper resistant'' structures
such as codewords. Define $h\times n$ matrix $P$ by $P[j,k]=p_j(\eta_k)$. Note
that the matrix $P$ is in the product code of codes $\rsc{\eta}{s+\ell}$ and
$\rsc{\alpha}{2m}$. Let $\overline{P}$ denote the matrix consisting of the first
$2\ell$ columns of $P$ and let $c_1,\ldots,c_{2\ell}$ be the commitments of the
columns of $\overline{P}$. Now it can be seen that:
\begin{align}
p(\overline{\bm{\eta}}) = \begin{bmatrix} p(\eta_1) \\ \vdots \\
p(\eta_{2\ell}) \end{bmatrix} = 
	{\begin{bmatrix}
	p_1(\eta_1) & \hdots & p_1(\eta_{2\ell}) \\
	\vdots & \ddots & \vdots \\
	p_m(\eta_1) & \hdots & p_m(\eta_{2\ell}) \\
	\vdots & \ddots & \vdots \\
	p_h(\eta_1) & \hdots & p_h(\eta_{2\ell})
	\end{bmatrix}}^T
	\begin{bmatrix}
	1^m \\
	0^{h-m}
	\end{bmatrix}=\overline{P}^T\begin{bmatrix} 1^m \\ 0^{h-m}\end{bmatrix}
\end{align}
From the above we have, 
\begin{align}\label{eq:necessarycondlin}
\innp{1^s}{p(\overline{\bm{\zeta}})} = \left\langle 1^s, \Phi\overline{P}^T\begin{bmatrix}
1^m \\ 0^{h-m} \end{bmatrix}\right\rangle = {\begin{bmatrix} 1^m \\ 0^{h-m}
\end{bmatrix}}^T\overline{P}\Phi^T[1^s]
\end{align}
Let $\varphi=(\varphi_1,\ldots,\varphi_{2\ell})$ denote the vector
$\Phi^T[1^s]$. Then, check $\sum_{k\in [s]}p(\zeta_k)=r^Tb$ reduces to
proving the inner product $\langle (1^m,0^{h-m}),\overline{P}\varphi\rangle=r^Tb$. Given
commitments $c_1,\ldots,c_{2\ell}$ we can compute commitment to the vector
$\overline{P}\varphi$ and then run the
protocol
$\innerproduct(\GG,\bm{g},x, \mathsf{cm},v;z)$ with $x=(1^m, 0^{h-m})$,
$z=\overline{U}\varphi$, $v=r^Tb$ and $\mathsf{cm}=\sum_{k\in [\ell]}\varphi_kc_k$.
The
advantage of the above is that $P$ has ``tamper resistant'' structure of being a
product codeword (which we can check given commitments $c_1,\ldots,c_{2\ell}$),
and we can establish if it is correctly derived from encoded witness $\ewit$ by
checking consistency at a few locations. In the actual protocol, the prover will randomize
the final vector $\overline{P}\varphi$ as $\varphi_0P_0 + \overline{P}\varphi$ for a random codeword $P_0\in L_2$ satisfying $\sum_{j\in [m]} P_0[j]=0$. The randomization will allow us to ensure the privacy of individual provers in distributed setting against the aggregator. \smallskip

\noindent{\em Checking Consistency with Oracle}: Note that a correctly computed
$P$ in the previous step satisfies $P[j,k]=\sum_{i\in
[p]}R^i(\alpha_j,\eta_k).\ewit[i,j,k]$. The verifier samples $t$ pairs $(j_u,k_u)$ for $u\in
[t]$ uniformly from $[h]\times [n]$ and asks the prover to provide vectors
$\ewit[\cdot,j_u,k_u]$ and $\pi[\cdot,k_u]$ for all $u\in [t]$. The prover and
verifier then run inner product protocols to check:
\begin{enumerate}[{\rm (i)}]
\item $P[j_u,k_u]=\langle P[\cdot,k_u], e_{j_u}\rangle=\sum_{i\in
[p]}R^i(\alpha_{j_u},\eta_{k_u}).\ewit[i,j_u,k_u]$ for $u\in [t]$.
\item Check that $\ewit[i,j_u,k_u]$ is consistent with oracle $\pi$ by verifying
$\innp{\ewit[i,\cdot,k_u]}{e_{j_u}}=\ewit[i,j_u,k_u]$. Note that the commitment
$\pi[i,k_u]$ for $\ewit[i,\cdot,k_u]$ is obtained as part of oracle answer. Moreover, we can aggregate inner product checks for entire column $\ewit[\cdot,j_u,k_u]$
into one inner product check.
\end{enumerate}
The complete linear check protocol is described in Figure \ref{fig:linearcheck}. 
In Figure \ref{fig:linearcheck}, the protocol $\agginnerproduct$ denotes the protocol 
for veryfying inner products of several commited vectors with a common vector. 
The completeness of the linear check protocol can be easily verified. We provide the proof for its
soundness.

\begin{figure}[h!]
\centering
\begin{framed}
\begin{itemize}
\item {$\linearcheck(\FF,\GG,L_1,L_2,A\in \FF^{M\times N},b\in \FF^M,[\pi];\ewit)$}:
\item {\bf Relation}: $\exists \ewit$ s.t. $\ewit=\open(\pi)$ and $A\wit = b$
for $\wit=\dec(\ewit)$.
\item {\bf Oracle Setup}: The prover $\prover$ computes
$\comoracle = \comm(\ewit)$ as in Section \ref{sec:construct_oracle}. 
The prover sets $\pi := \comoracle$ as the oracle.
\begin{enumerate}[{\rm 1.}]
\item $\verifier\rightarrow\prover$: $\verifier$ samples $r\sample \FF^N$ and
sends it to $\prover$.
\item $\prover\longleftrightarrow\verifier$: Both $\prover$ and $\verifier$
compute polynomials $R^i$, $i\in [p]$ such that
$R^i(\alpha_j,\zeta_k)=r[i,j,k]$. 
\pnote{Polynomial $R^i(\cdot, \cdot)$ should not be constructed from $r$, it should be from $r^TA$}
\item $\prover$ computes:
	\begin{enumerate}
	\item Polynomials $p_j(\cdot) := \sum_{i\in
[p]}R^i(\alpha_j,\cdot).Q^i(\alpha,\cdot)$ for $j\in [h]$.
	\item An $h\times n$ matrix $P$ such that $P[j,k]=p_j(\eta_k)$.
	\item Commitments $c_k=\comm(P[\cdot,k],\omega_k)$ for $k\in [s+\ell]$
where $\omega_k\sample \FF$.
	\item Sample a codeword $P_0\in \dashL_2$ s.t $\sum_{j\in [m]}P_0[j]=0$.
Compute $c_0=\comm(P_0,\omega_0)$ for $\omega_0\sample \FF$.
	\end{enumerate}
\item $\prover\rightarrow\verifier$: The prover sends $c_0,c_1,\ldots,c_{s+\ell}$ to
the verifier.
\item $\verifier\rightarrow\prover$: $\verifier$ samples $(j_u,k_u)\sample [h]\times
[n]$ for $u\in [t]$. It also samples $\beta\sample\FF$. The verifier sends
$Q=\{(j_u,k_u):u\in [t]\}$ and $\beta$ to $\prover$.
\item $\prover\rightarrow\verifier$: The prover sends vectors
$X_u=\ewit[\cdot,j_u,k_u]$ for $u\in [t]$ to $\verifier$.
\item Oracle Queries: $\verifier$ queries the oracle $\pi$ with $\{k_u:u\in
[t]\}$. 
\item Oracle Answers: The oracle replies with columns $\pi[\cdot,k_u]$, $u\in
[t]$.
\item $\prover\longleftrightarrow\verifier$: Both $\prover$ and $\verifier$
compute $\varphi := \Phi^T[1^s]$ and $\mathsf{cm} := \beta c_0 + \sum_{k\in
[s+\ell]}\varphi_kc_k$.
\item $\prover$ and $\verifier$ run the subprotocol:
	\begin{itemize}
	\item $b_{\rm 2d} = \proximityTwoD(\FF,\GG,\dashL_1,\dashL_2,\bm{c};\overline{P})$
where $\bm{c}=(c_1,\ldots,c_{s+\ell})$ and $\overline{P}$ is the submatrix of $P$
consisting of the first $s+\ell$ columns. Here $\dashL_1=\rsc{\eta}{s+\ell}$ and
$\dashL_2=\rsc{\alpha}{2m}$.
	\end{itemize}
\item $\prover$ and $\verifier$ run the subprotocol:
	\begin{itemize}
	\item $b = \innerproduct(\GG,\bm{g},x,\mathsf{cm},v;z)$
with $x=(1^m,0^{h-m})$, $v=r^Tb$ and $z=\beta P_0+\overline{P}\varphi$.
	\end{itemize}
\item $\prover$ and $\verifier$ compute: For all $u\in [t]$ $c_{k_u} =
\sum_{a\in 2\ell}T[a,k_u]c_a$, where $T$ is the matrix such that $P=\overline{P}T$.
\item $\prover$ and $\verifier$ run inner product subprotocols for each $u\in
[t]$:
	\begin{itemize}
	\item $s_u=\innerproduct(\GG,\bm{g},x,c_{k_u},v;P[\cdot,k_u])$ with
$x=e_{j_u}$, $v=\sum_{i\in [p]}R^i(\alpha_{j_u},\eta_{k_u})X_u$.
	\end{itemize}
\item $\prover$ and $\verifier$ run aggregate inner product protocols for each
$u\in [t]$:
	\begin{itemize}
	\item
$a_u=\agginnerproduct(\GG,\bm{g},e_{j_u},\pi[\cdot,k_u],X_u;\ewit[\cdot,\cdot,k_u])$
	\end{itemize}
\item $\prover$ and $\verifier$ run the subprotocol: 
	\begin{itemize}
	\item $b_{\rm prox} = \proximityThreeD(\FF,\GG,L_1,L_2,[\pi];U)$
	\end{itemize}
\item The verifier accepts if all the subprotocols accept.
\end{enumerate}
\end{itemize}

\begin{itemize}
\item $\agginnerproduct(\FF,\GG,\bm{g},x,\bm{c}\in \GG^n,\bm{v}\in \FF^n;W\in
\FF^{m\times n})$:
\item {\bf Relation}: $\forall i\in [n]$: $W[i,\cdot]=\open(\bm{c}[i])$,
$\innp{x}{W[i,\cdot]}=v[i]$. 
\begin{enumerate}
\item $\verifier\rightarrow\prover$: Verifier samples $\delta\in \FF^n$ and
sends it to the prover.
\item $\prover\leftrightarrow\verifier$ compute: $\mathsf{cm}=\sum_{i\in
[n]}\delta_i\bm{c}[i]$, $V=\sum_{i\in [n]}\delta_i\bm{v}[i]$
\item $\prover$ and $\verifier$ run the subprotocol:
	\begin{itemize}
	\item $b=\innerproduct(\FF,\GG,\bm{g},\delta,\mathsf{cm},V;\bm{v}^TW)$
	\end{itemize}
\item $\verifier$ accepts if $b=1$.
\end{enumerate}
\end{itemize}
\end{framed}
\caption{Linear Check Protocol}
\label{fig:linearcheck}
\end{figure}

\begin{lemma}[Soundness]\label{lem:linercheck_sound}
For all polynomially bounded provers $P^\ast$ and all $\pi\in \GG^{p\times n}$,
$A\in \FF^{M\times N}, b\in \FF^M$, there exists an expected polynomial time
extractor $\extr$ with rewinding access to transcript oracle $\mc{O}=\langle
P^\ast(\cdot),\verifier^\pi(\cdot)\rangle$ such that:
{\small
\begin{align*}
\condprob{\begin{array}{c}
\ewit=\open(\pi)\wedge A\wit=b \\
\text{ where } \wit=\dec(\ewit)
\end{array}
}{
\begin{array}{c}
\sigma\sample \gen(\secparam) \\
\ewit\sample \extr^{\mc{O}}(\bm{x},\sigma)
\end{array}}\geq
\condprob{\innp{P^\ast(\bm{x},\sigma)}{\verifier^\pi(\bm{x},\sigma)}=1}
{\sigma\sample\gen(\secparam)}-\kappa_{\rm lc}(\secpar)
\end{align*}
}
for negligible function $\kappa_{\rm lc}$. In tha above $\bm{x} := (A,b,M,N)$.
\end{lemma}
\begin{proof}
We describe an extractor $\extr$ which outputs $\ewit$ such that $\open(\pi)=\ewit$ and $A\wit = b$ 
for $\wit=\dec(\ewit)$. The extractor $\extr$ uses the extractor $\extr_{3d}$ for
the protocol $\proximityThreeD$ to extract the witness $\ewit$ which opens to
the oracle $\pi$. Note that, with probability at least ($1-\kappa_{3d}(\secpar)$),
the extracted witness $\ewit$ satisfies $d_1(\ewit,\mc{W}_1)<e$ and $\ewit\in
\mc{W}_2$. It follows that for each slice $\ewit^i:=\ewit[i,\cdot,\cdot]$ for $i\in [p]$,
we have $\ewit^i\in \mc{C}_2$ and $d_1(\ewit^i,\mc{C}_1)<e$. Let $E\subseteq
[n]$ denote the indices of the {\em planes} where $\ewit$ differs from its closest
neighbor in $\mc{W}_1$. Since $e<d_1/2$, $E$ also denotes the set of columns
where slices $\ewit^i$ differ from their closest neighbors in $\mc{C}_1$. We
decode each slice seperately. Applying Lemma \ref{lem:bicdecoding} for each
slice, we have codewords $W^i\in L_1\oplus L_2$ for each $i\in [p]$ such that
$W^i[\cdot,k]=\ewit^i[\cdot,k]$ for all $k\not\in E$. Let $Q^i$, $i\in [p]$ be
the unique polynomials with $deg_x(Q^i)<m$ and $deg_y(Q^i)<\ell$ such that
$Q^i(\alpha_j,\eta_k)=W^i[j,k]$ for $(j,k)\in [h]\times [n]$. We define the
witness $\wit$ by $\wit[i,j,k] := Q^i(\alpha_j,\zeta_k)$ for $i\in [p],j\in
[m],k\in [s]$. Note that $\wit=\dec(\ewit)$. In case, the subprotocol extractor
$\extr_{3d}$ outputs $\ewit$ such that $d_1(\ewit,\mc{W}_1)>e$, the extractor
$\extr$ fails with output $\wit := \bot$. Let $\ewit_{\rm hon}$ denote the
encoding of $\wit$ given by $\ewit_{\rm hon}[i,j,k]=Q^i(\alpha_j,\eta_k)$ for
$i\in [p],j\in [h], k\in [n]$. Observe that we have $d_1(\ewit,\ewit_{\rm
hon})<e$. Let $\mc{S}$ denote the event that the
first transcript succeeds. As before, the key step to ensure soundness is to
upper bound the probability $\prob{\mc{S}\cap (A\wit\neq b)}\leq
\condprob{\mc{S}}{A\wit\neq b}\leq \condprob{\mc{S}}{r^TA\neq r^Tb}+1/|\FF|$
where $r\sample \FF^N$ denotes the message sent by $\verifier$ in Step 1. Let
$P_{\rm hon}$ denote the matrix $P$ which is correctly computed from $\ewit_{\rm
hon}$ in
Step 3. Let $c_1,\ldots,c_{\ell}$ be the commitments sent (possibly,
adverserial) by the prover to the verifier in Step 4. Let $\overline{P}_{\rm adv}$ be the
witness extracted using the extractor $\extr_{2d}$ for the subprotocol in Step
10. Let $P_{\rm adv}$ denote the matrix $\overline{P}_{\rm adv}T$. Then with overwhelming
probability ($1-\kappa_{2d}(\secpar)$), $P_{\rm adv}\in \dashL_1\oplus \dashL_2$. Observe
that if $P_{\rm hon}=P_{\rm adv}$, then $r^TA\neq r^Tb$ implies that
$\overline{P}=\overline{P}_{\rm adv}$ does not satisfy Equation
\eqref{eq:necessarycondlin} and thus the subprotocol in Step 11 succeeds with
probability at most $\kappa_{ip}(\secpar)$, or $\extr$ succeeds in finding
distinct openings to the commitment in subprotocol in Step 11. Assume then that $P_{\rm hon}\neq
P_{\rm adv}$. Again, from subprotocol in Step 14, we conclude that $X_u =
\ewit[\cdot,j_u,k_u]$, except with probability $\kappa_{agg}(\secpar)$, or
$\extr$ outputs two openings to one of the commitments $\pi[j_u,k_u]$ for $u\in
[t]$. Similarly, assuming $\extr$ does not break binding of the commitment
scheme, the witnesses extracted for inner product protocols in Step 13, are the
columns $P_{\rm adv}[\cdot,k_u]$ for $u\in [t]$. Thus, with overwhelming probability, the inner product check in Step 13 is
equivalent to checking the following for all $u\in [t]$:
\begin{equation}\label{eq:check1}
P_{\rm adv}[j_u,k_u]=\sum_{i\in
[p]}R^i(\alpha_{j_u},\eta_{k_u})\ewit[i,j_u,k_u]
\end{equation}
For $u\in [t]$, let $\mc{E}_u$ denote the event that the above equation holds
for $u$. For $k_u\not\in E$, we have $\ewit[\cdot,\cdot,k_u]=\ewit_{\rm
hon}[\cdot,\cdot,k_u]$ and thus the right hand side in \eqref{eq:check1} equates
to $P_{\rm hon}[j_u,k_u]$. Now, $P_{\rm adv}$ and $P_{\rm hon}$ differ in at
least $\dashD_1$ columns, where $\dashD_1$ denotes the minimum distance of the
code $\dashL_1$. Let $E'$ denote the column indices where $P_{\rm adv}$ and
$P_{\rm hon}$ differ. For $k_u\in E'\backslash E$, the check succeeds if the
distinct codewords $P_{\rm adv}[\cdot,k_u]$ and $P_{\rm hon}[\cdot,k_u]$ agree
at position $j_u$. Since $(j_u,k_u)$ are sampled uniformly and independently
(also independent of extracted witness $\wit$), we have:
{\small
\begin{align}\label{eq:probeq6}
\prob{\mc{E}_u} &\leq \frac{n-\dashD_1+e}{n} +
\frac{\dashD_1-e}{n}.\frac{h-\dashD_2}{h}
\nonumber \\
	&\leq \frac{s+\ell+e}{n} + \frac{n-s-\ell-e}{n}.\frac{2m}{h} \nonumber \\
	& = \frac{2m}{h} +
\left(1-\frac{2m}{h}\right)\left(\frac{s+\ell+e}{n}\right)
\end{align}
}
For initial transcript to accept, all the $t$ checks should succeed, and thus we
have:
{\small
\begin{align}\label{eq:probeq7}
\prob{\mc{S}\cap (A\wit\neq b)}&\leq
\left(\frac{2m}{h}+\left(1-\frac{2m}{h}\right)\left(\frac{s+\ell+e}{n}\right)\right)^t
+ \kappa_{3d}(\secpar) + \mc{B}(\secpar) +
\frac{O(|C|)}{|\FF|} \nonumber \\
&\leq \left(1-\frac{e}{n}\right)^t +
\left(\frac{2m}{h}+\left(1-\frac{2m}{h}\right)\left(\frac{s+\ell+e}{n}\right)\right)^t
+ \frac{O(|C|)}{|\FF|} + \mc{B}(\secpar)
\end{align}
}
Thus the statement of the lemma holds for $\kappa_{lc}(\secpar) := (1-e/n)^t +
(2m/h + (1-2m/h)(2\ell/n + e/n))^t+O(|C|)/|\FF|+\mc{B}(\secpar)$.
\end{proof}

\subsection{Quadratic Check Protocol}
We now describe the IPCP which allows a prover to prove knowledge of vectors
$\wit_x$, $\wit_y$ and $\wit_z$ in $\FF^N$, satisfying $\wit_x\circ \wit_y =
\wit_z$. Once again, the protocol requires the prover to construct encodings
$\ewit_x=\enc(\wit_x)$, $\ewit_y=\enc(\wit_y)$ and $\ewit_z=\enc(\wit_z)$ as
described in Section \ref{sec:witencoding}. Thereafter, the prover uses
commitment scheme $\comm$ to commit to these encodings as $\comoracle_x =
\comm(\ewit_x)$, $\comoracle_y = \comm(\ewit_y)$ and $\comoracle_z = \comm(\ewit_z)$. 
The prover forms the oracle $\pi\in \GG^{3p\times n}$ by vertically stacking the
$p\times n$ matrices $\comoracle_x,\comoracle_y$ and $\comoracle_z$. As before,
for a query $Q\subseteq [n]$, the oracle answers with columns $\pi[\cdot,k]$ for
$k\in Q$. The columns returned by the oracle can be parsed into constituent columns 
$\comoracle_x[\cdot,k]$, $\comoracle_y[\cdot,k]$ and $\comoracle_z[\cdot,k]$
canonically. We again discuss the key ingredients of the protocol.\smallskip

\noindent{\em Probabilistic Reduction}: Let $Q^i_x,Q^i_y$ and $Q^i_z, i\in [p]$ be the
polynomials interpolating the $i^{th}$ slices of $\wit_x$, $\wit_y$ and $\wit_z$
 as in Section \ref{sec:witencoding}. Then for vectors $\wit_x,\wit_y,\wit_z$ satisfying
$\wit_x\circ \wit_y=\wit_z$, the polynomials $Q^i=Q^i_x\cdot Q^i_y - Q^z_i$ interpolate
$\bm{0}^{m\times s}$ on the set $\{(\alpha_j,\zeta_k):j\in [m],k\in [s]\}$ for all $i\in [p]$. This can be probabilistically
checked by checking that the polynomial $F := \sum_{i\in [p]}r_iQ^i$ interpolates
$\bm{0}^{m\times s}$ on the above set for randomly sampled $r\in \FF^p$. Once again, we
ask the prover to ``commit'' to $F$ using a tamper resistant structure, like a codeword,
which enables the verifier to check the aforementioned condition, as well as to
ensure that the commitment is consistent with oracle replies and prior
messages.\smallskip

\noindent{\em Reduction to Inner Products}: The prover computes the matrix
$h\times n$ matrix $P$ given by $P[j,k]=F(\alpha_j,\eta_k)$. It commits to $P$
using commitments $(c_1,\ldots,c_{2\ell})$ to the first $2\ell$ columns of $P$.
Note that each row of $P$ commits to univariate component polynomials
$F(\alpha_j,\cdot)$ of $F$ via their evaluations of $\bm{\eta}$. To check that
$F$ interpolates $\bm{0}^{m\times s}$ on the points
$\{(\alpha_j,\zeta_k)\}_{j\in [m],k\in [s]}$, the verifier checks that
$p(\cdot) := \sum_{j\in [m]}\gamma_jF(\alpha_j,\cdot)$ interpolates $\bm{0}^s$ on
$\overline{\bm{\zeta}}$ for randomly sampled $\gamma=(\gamma_1,\ldots,\gamma_m)\in \FF^m$.
Again, the verifier checks $p(\overline{\bm{\zeta}})=\bm{0}^s$ via the inner product
check $\innp{\tau}{p(\overline{\bm{\zeta}})}=0$ for a random $\tau\in \FF^s$. As in the
linear check protocol, using $p(\overline{\bm{\zeta}})=\Phi p(\overline{\bm{\eta}})$, we
get the following inner product check
$\innp{(\gamma,0^{h-m})}{\overline{P}\varphi}=0$ where $\varphi=\Phi^T\tau$. Again,
the commitment to the vector $\overline{P}\varphi$ can be homomorphically computed
from $c_1,\ldots,c_{2\ell}$. \smallskip

\noindent{\em Checking consistency with Oracle}: As in the linear check, the
verifier uniformly and independently samples $(j_u,k_u)\in [h]\times [n]$ for
$u\in [t]$, and queries the oracle $\pi$ for columns $\pi[\cdot,k_u]$. Let
$\pi_x[\cdot,k_u]$, $\pi_y[\cdot,k_u]$ and $\pi_z[\cdot,k_u]$ denote the parse
of $\pi[\cdot,k_u]$ into commitments corresponding to $\ewit_x,\ewit_y$ and
$\ewit_z$ respectively. Further, the verifier asks prover for vectors
$\ewit_x[\cdot,j_u,k_u]$, $\ewit_y[\cdot,j_u,k_u]$ and $\ewit_z[\cdot,j_u,k_u]$
for $u\in [t]$. The verifier then checks the following:
\begin{enumerate}[{\rm (i)}]
\item For all $u\in [t]$: $P[j_u,k_u]=\sum_{i\in
[p]}r_i(\ewit_x[i,j_u,k_u]\cdot\ewit_y[i,j_u,k_u]-\ewit_z[i,j_u,k_u])$.
\item Checks that vectors $\ewit_x[\cdot,j_u,k_u]$ are consistent with
commitments $\pi_x[\cdot,k_u]$ as in linear check protocol. Similar checks are
made for $\ewit_y[\cdot,j_u,k_u]$ and $\ewit_z[\cdot,j_u,k_u]$.
\end{enumerate}
We present the full protocol in Figure \ref{fig:quadcheck}. The completeness of
the protocol can again be verified by direct calculation. We state the soundness
of the protocol below:
\begin{figure}[h!]
\centering
\begin{framed}
\begin{itemize}
\item $\quadcheck(\FF,\GG,L_1,L_2,[\pi];\wit_x,\wit_y,\wit_z)$:
\item {\bf Relation}: $\exists (\ewit_x,\ewit_y,\ewit_z)$
s.t. $[\ewit_x||\ewit_y||\ewit_z]=\open(\pi)$, $\wit_{a}=\dec(\ewit_a)$ for $a\in
\{x,y,z\}$ and $\wit_x\circ \wit_y = \wit_z$.
\item {\bf Oracle Setup}: The prover $\prover$ computes $\comoracle_a=\comm(\ewit_a)$ 
for $a\in \{x,y,z\}$. It sets $\pi :=
[\comoracle_x||\comoracle_y||\comoracle_z]$ where the notation denotes vertical
stacking of the matrices. 
\begin{enumerate}[{\rm 1.}]
\item $\verifier\rightarrow\prover$: Verifier samples $r\sample\FF^p$ and sends
it to $\prover$.
\item $\prover$ computes:
	\begin{itemize}
	\item polynomials $p_j(\cdot):=\sum_{i\in
[p]}r_i\big(Q^i_x(\alpha_j,\cdot)Q^i_y(\alpha_j,\cdot)-Q^i_z(\alpha_j,\cdot)\big)$
for $j\in [h]$.
	\item $h\times n$ matrix $P$ such that $P[j,k]=p_j(\eta_k)$.
	\item commitments $c_1,\ldots,c_{2\ell}$ to the first $2\ell$ columns of
$P$.
	\end{itemize}
\item $\prover\rightarrow\verifier$: The prover sends $c_1,\ldots,c_{2\ell}$ to
the verifier.
\item $\verifier\rightarrow\prover$: $\verifier$ samples $(j_u,k_u)\sample
[h]\times [n]$ for $u\in [t]$. The verifier also samples $\tau\sample
\FF^{\ell}$. It sends $Q=\{(j_u,k_u):u\in [t]\}$ and $\tau$ to $\prover$.
\item $\prover\rightarrow\verifier$: The prover sends vectors
$X_u=\ewit_x[\cdot,j_u,k_u],Y_u=\ewit_y[\cdot,j_u,k_u],Z_u=\ewit_z[\cdot,j_u,k_u]$
to the verifier, for all $u\in [t]$.
\item Oracle Queries: $\verifier$ queries the oracle $\pi$ with $\{k_u: u\in
[t]\}$.
\item Oracle Response: The oracle responds with columns $\pi[\cdot,k_u]$ for
$u\in [t]$.
\item $\prover\leftrightarrow\verifier$: Both $\prover$ and $\verifier$ compute
$\varphi := \Phi^T\tau$ and $\mathsf{cm}:= \sum_{k\in [2\ell]}\phi_kc_k$.
\item $\prover$ and $\verifier$ run the subprotocol:
	\begin{itemize}
	\item $b_{\rm
2d}=\proximityTwoD(\FF,\GG,\dashL_1,\dashL_2,\bm{c};\overline{P})$ where
$\bm{c}=(c_1,\ldots,c_{2\ell})$ and $\overline{P}$ is the submatrix of $P$ consisting
of the first $2\ell$ columns. Here $\dashL_1=\rsc{\eta}{2\ell}$ and
$\dashL_2=\rsc{\alpha}{2m}$.
	\end{itemize}
\item $\prover$ and $\verifier$ run the subprotocol:
	\begin{itemize}
	\item $b=\innerproduct(\FF,\GG,\bm{g},x,\mathsf{cm},v;z)$
with $x=(\gamma,0^{h-m})$, $v=0$ and $z=\overline{P}\varphi$.
	\end{itemize}
\item $\prover$ and $\verifier$ compute: For all $u\in [t]$ $c_{k_u} =
\sum_{a\in 2\ell}T[a,k_u]c_a$, where $T$ is the matrix such that $P=\overline{P}T$.
\item $\prover$ and $\verifier$ run inner product subprotocols for each $u\in
[t]$:
	\begin{itemize}
	\item $s_u=\innerproduct(\GG,\bm{g},x,c_{k_u},v;P[\cdot,k_u])$ with
$x=e_{j_u}$, $v=\sum_{i\in [p]}r_i(X_u[i]\cdot Y_u[i] - Z_u[i])$.
	\end{itemize}
\item $\prover$ and $\verifier$ run aggregate inner product protocols for each
$u\in [t]$:
	\begin{itemize}
	\item
$a_{1u}=\agginnerproduct(\GG,\bm{g},e_{j_u},\pi_x[\cdot,k_u],X_u;\ewit_x[\cdot,\cdot,k_u])$
	\item
$a_{2u}=\agginnerproduct(\GG,\bm{g},e_{j_u},\pi_y[\cdot,k_u],Y_u;\ewit_y[\cdot,\cdot,k_u])$
	\item
$a_{3u}=\agginnerproduct(\GG,\bm{g},e_{j_u},\pi_z[\cdot,k_u],Z_u;\ewit_z[\cdot,\cdot,k_u])$
	\end{itemize}
\item $\prover$ and $\verifier$ run the subprotocol: 
	\begin{itemize}
	\item $b_{\rm prox} =
\proximityThreeD(\FF,L_1,L_2,e,[\pi];[\ewit_x||\ewit_y||\ewit_z])$
	\end{itemize}
\item The verifier accepts if all the subprotocols accept.
\end{enumerate}
\end{itemize}
\end{framed}
\caption{Quadratic Check Protocol}
\label{fig:quadcheck}
\end{figure}

\begin{lemma}[Soundness]\label{lem:quadcheck_sound}
For all polynomially bounded provers $P^\ast$ and all $\pi\in \GG^{3p\times n}$,
there exists an expected polynomial time extractor $\extr$ with rewinding access
to the transcript oracle $\mc{O}=\innp{P^\ast(\cdot)}{\verifier^{\pi}(\cdot)}$
such that:
{\small
\begin{align*}
\condprob{
\begin{array}{c}
{[}\ewit_x||\ewit_y||\ewit_z{]}=\open(\pi)\wedge \\
\wit_z=\wit_x\circ\wit_y
\end{array}
}{
\begin{array}{c}
\sigma\sample \gen(\secparam) \\
{[}\ewit_x||\ewit_y||\ewit_z{]}\sample \extr^{\mc{O}}(\sigma)\\
\wit_a=\dec(\ewit_a), a\in \{x,y,z\}
\end{array}
}\geq \epsilon(P^\ast) - \kappa_{\rm qd}(\secpar)
\end{align*}
}
for some negligible function $\kappa_{qd}$. In the above, $\epsilon(P^\ast)$
denotes the success probability of the prover $P^\ast$ given by
$\condprob{\innp{P^\ast(\sigma)}{\verifier^\pi(\sigma)}=1}{\sigma\sample
\gen(\secparam)}$.
\end{lemma}
\begin{proof}
The proof is similar to the proof of the linear check protocol. Using similar
arguments, one can show that the above Lemma holds with:
{\small
\begin{equation*}
\kappa_{qd}(\secpar) := \left(1-\frac{e}{n}\right)^t +
\left(\frac{2m}{h}+\left(1-\frac{2m}{h}\right)\left(\frac{2\ell+e}{n}\right)\right)^t
+ \frac{O(|C|)}{|\FF|} + \mc{B}(\secparam)
\end{equation*}
}
\end{proof}

\subsection{Zero Knowledge}
We now prove protocols $\linearcheck$ and $\quadcheck$ to be honest verifier zero knowledge by
designing simulators for them. We will infact simulate ``extended'' view of the
verifier. This will help us in proving the privacy of our protocol in
distributed setting (in particular, the protocol specific messages received by
the aggregator do not {\em leak}). As part of the extended view, we will include
the witnesses consisting of the committed vector and commitment randomness for
all $\innerproduct$ subprotocols. It is clear then, that the simulation can be
completed by running the inner product argument on these simulated witness
vectors. We describe the view of the verifier in the linear check protocols with
the aforementioned extensions. We decompose the view as:
\begin{itemize}
\item {\bf Verifier Randomness}: Vector $r\in \FF^N$ in Step 1,
$\{j_u,k_u\}_{u\in [t]}$, $\beta\in \FF_\ast$ in Step 5, $\tau,\delta$ as
part of $\proximityTwoD$ subprotocol in Step 10, $\rho\sample \FF^p$ as the
random vector for compressing in subprotocol $\proximityThreeD$ in Step 15,
$\tau',\delta'$ for the second invocation of $\proximityTwoD$ from within
$\proximityThreeD$. We
do not include the query positions as part of the subprotocol $\proximityThreeD$
as we assume that the same query positions sampled in Step 5 are used there.
Summarizing, the verifier randomness consists of $r,\{j_u,k_u\}_{u\in
[t]},\beta,\tau,\delta,\rho,\tilde{\tau},\tilde{\delta}$.

\item {\bf Commitments}: Commitment $c_0$ to the random codeword sampled in Step
3(d), commitments $c_1,\ldots,c_{s+\ell}$ to the first $s+\ell$ columns of the
matrix $P$, commitment $d_0$ for random vector $u_0$ used in $\proximityTwoD$
subprotocol in Step 10, commitments $\tilde{c}_1,\ldots,\tilde{c}_{\ell}$ as
part of $\proximityThreeD$ protocol in Step 15, and commitment $\tilde{d'}_0$ to
the random codeword in the invocation of $\proximityTwoD$ from within
$\proximityThreeD$ in step 15. Additionally, the view contains commitments
$\pi[\cdot,k_u]$ for $u\in [t]$ as part of oracle query response. Summarizing,
the view consists of commitments:
\[ c_0,c_1,\ldots,c_{s+\ell},d_0,\tilde{c}_1,\ldots,\tilde{c}_{\ell},\tilde{d}_0,\{\pi[\cdot,k_u]\}_{u\in
[t]}\]

\item {\bf Commitment Randomness}: We include randomness used to compute certain
commitments as part of the extended view. We include $\nu=\nu_0+\sum_{a\in
[s+\ell]}\mu_a\omega_a$ for the vector $z$ in the subprotocol
$\proximityTwoD$ in Step 10 (here $\mu=\mc{T}\tau$),
$\omega=\beta\omega_0+\sum_{a\in [s+\ell]}\varphi_ac_a$ for inner product in
Step 11, $\chi_u=\sum_{a\in [s+\ell]}T[a,k_u]c_a$ for $u\in [t]$ for the inner
products in Step 13, $\{O[\cdot,k_u]\}_{u\in [t]}$ for aggregate inner product
arguments in Step 14, $\tilde{\nu}=\tilde{\nu}_0+\sum_{a\in
[\ell]}\tilde{\mu}_a\tilde{c}_a$ for the vector $\tilde{z}$ in the
$\proximityTwoD$ protocol called as part of $\proximityThreeD$ protocol in Step
15. Summarizing, the view includes $\nu,\omega,\{\chi_u\}_{u\in
[t]},\{O[\cdot,k_u]\}_{u\in [t]},\tilde{\nu}$.

\item {\bf Witness related vectors}: We describe various vectors derived from
witness encoding provided to the verifier. Vectors $X_u=\ewit[\cdot,j_u,k_u]$
for $u\in [t]$ in Step 6, the vector $z=u_0 + \overline{P}\mu$ ($\mu=\mc{T}\tau$) as
part of view of the subprotocol $\proximityTwoD$ in Step 10, the vector
$z'=\beta P_0+\overline{P}\varphi$ as the witness to the inner product check in Step
11, vectors $P[\cdot,k_u]$ for $u\in [t]$ as witnesses to inner product checks
in Step 13, matrices $\ewit[\cdot,\cdot,k_u]$ for $u\in [t]$ as witnesses to
aggregate inner product checks in Step 14, and finally the vector
$\tilde{z}=\tilde{u}_0 + \sum_{a\in [\ell]}\tilde{\mu}_a\tilde{c}_a$ as part of
protocol $\proximityTwoD$ from within $\proximityThreeD$ in Step 15. We drop
$\{X_u\}_{u\in [t]}$ and $\{P[\cdot,k_u]\}_{u\in [t]}$ from the view as these
can be derived from $\ewit[\cdot,\cdot,k_u]$ and $r$. Thus, the vectors in the
view consist of: $z,z',\{\ewit[\cdot,\cdot,k_u]\}_{u\in [t]},\tilde{z}$.
\end{itemize}

\noindent{\bf Simulator}: The simulator outputs $r$, $\{j_u,k_u\}_{u\in [t]}$,
$\beta$, $\tau,\delta$, $\rho$, $\tilde{\tau},\tilde{\delta}$ by uniformly and
independently sampling them from their respective domains, as in the honest
execution of the protocol. Simulator also outputs $z,\tilde{z}$ uniformly from
$L_2$, and $z'$ uniformly from $\dashL_2$ satisfying $\sum_{j\in [m]}z'[j]=0$ . It outputs
$\ewit[\cdot,\cdot,k_u]$ uniformly such that each plane has columns as codewords
in $L_2$. 
Next, the simulator outputs $\omega,\nu,\tilde{\nu}$
and $\chi_1,\ldots,\chi_t$, $\{O[\cdot,k_u]\}_{u\in [t]}$ choosing them randomly and
independently from $\FF$. Finally, the simulator outputs
$c_0,d_0,\ldots,c_{s+\ell}$ and $\tilde{d}_0,\tilde{c}_1,\ldots,\tilde{c}_\ell$ choosing 
them uniformly from $\GG$ subject to:
\begin{align}\label{eq:commiteq}
d_0 + \sum_{a=1}^{s+\ell}\mu_ac_a &= \comm(z,\nu) \nonumber \\
c_0 + \sum_{a=1}^{s+\ell}\varphi_ac_a &= \comm(z',\omega) \nonumber \\
\sum_{a=1}^{s+\ell}T[a,k_u]c_a &= \comm(P[\cdot,k_u],\chi_u) \quad \forall u\in
[t] \nonumber \\ 
\sum_{a=1}^{\ell}\mc{T}[a,k_u]\tilde{c}_a &= \comm\big(\sum_{i\in
[p]}\rho_i U[i,\cdot,k_u],\sum_{i\in [p]}\rho_i O[i,k_u]\big) \forall u\in [t]
\nonumber \\
\beta\tilde{d}_0 + \sum_{a=1}^{\ell}\tilde{\mu}_a\tilde{c}_a &=
\comm(\tilde{z},\tilde{\nu})
\end{align}

\begin{lemma}\label{lem:simlincheck}
There exists an efficient simulator whose output is perfectly indistinguishable
from the extended view of the verifier in honest execution of the protocol
$\linearcheck$ for $t\leq \bi$.
\end{lemma}
\begin{proof}
We consider the simulator as discussed. Let $\bm{r}=(r,\{j_u,k_u\}_{u\in
[t]},\beta,\tau,\delta,\rho,\tilde{\tau},\tilde{\delta})$ denote the vector
consisting of verifier's randomness, which is chosen exactly in the honest
protocol execution. Distributions $p(z|\bm{r})$ and $p(\tilde{z}|\bm{r})$ are
uniform distributions on $L_2$ due to the blinding vector $u_0\in L_2$ chosen by
the prover in the $\proximityTwoD$ protocol. Similarly, due to blinding vector
$P_0\in \dashL_2$ chosen in Step 3(d), the distribution
$p(z'|\bm{r})$ is also uniform on the vectors $z'$ in $\dashL_2$ satisfying
$\sum_{j\in [m]}z'[j]=0$. Since $t\leq \bi$, from Lemma
\ref{lem:boundedindependence}, we conclude that the planes
$\ewit[\cdot,\cdot,k_u]$ are distributed uniformly independent of $\bm{r}$. In
the real execution of the protocol, the prover chooses
$\omega_0,\omega_1,\ldots,\omega_{s+\ell}$ and $\nu_0$ independently at random
and computes:
\begin{align}\label{eq:simeq}
\chi_u &= \sum_{a\in [s+\ell]}T[a,k_u]\omega_a \forall u\in [t] \nonumber \\
\omega &= \omega_0 + \sum_{a\in [s+\ell]}\mu_a\omega_a \nonumber \\
\nu &= \nu_0 + \sum_{a\in [s+\ell]}\phi_a\omega_a
\end{align}    
Since any $t$ columns of $T$ are linearly independent, we see that the matrix of
coefficients in \eqref{eq:simeq} has full row rank, and thus the vector
$(\chi_1,\ldots,\chi_t,\omega,\nu)$ is disrtributed uniformly in $\FF^{t+2}$.
Similarly, $\{O[\cdot,k_u]\}_{u\in [t]}$ also consists of uniformly sampled
entries in $\FF$ as in the real protocol. We now consider computation of
$\tilde{\nu}$ in the honest protocol execution. We have:
\begin{align}\label{eq:simeq2}
\tilde{\nu} &= \tilde{\nu}_0 + \sum_{a\in [\ell]}\tilde{\mu}_a\tilde{\omega}_a
 \text{ where } \nonumber \\
\tilde{\omega}_a &= \sum_{i\in [p]}\rho_iO[i,a] \quad \forall a\in [\ell]
\end{align} 
Since $\tilde{\nu}_0$ is choesn randomly by the prover, the distribution of
$\tilde{\nu}$ is uniform, independent of other variables in the view. Finally,
the commitments in the view satisfy relations in Equation \ref{eq:commiteq} in
the real protocol, and are picked uniformly subject to those constraints by the
simulator. Thus the view output by the simulator perfectly simulates the
extended view of the verifier as defined. 
\end{proof}

We omit the simulation for the quadratic check protocol, as it is very similar
to the linear check. One key difference we highlight is that we do not need to
randomize the vector $\overline{P}\varphi$, the witness in the inner product check in
Step 10 (and part of the extended view), as in the honest execution of the
protocol, $\overline{P}\varphi$ is the unique codeword $z$ of $L_2$ with $z[j]=0$ for
all $j\in [m]$. We state the lemma formally, skipping the proof.

\begin{lemma}\label{lem:simquadcheck}
There exists an efficient simulator $\simulator$ whose output is perfectly
indistinguishable from the extended view of the verifier in the honest execution
of the protocol $\quadcheck$ for $t\leq \bi$.
\end{lemma}


\subsection{Extension to DPZK}
We now describe variants of the protocols discussed previously when the witness
is shared among several provers. We assume that there are $K$ provers
$P_1,\ldots,P_K$. For $\xi\in [K ]$, let $[[\wit]]_\xi$ denote the prover
$P_{\xi}'s$ share of the witness $\wit$. We assume that the sharing is additive,
i.e, $\sum_{\xi\in [K]}\wit_\xi=\wit$. When denoting witnesses to certain
protocols, we use the $[[\cdot]]$ to denote that the witness is additively
shared among the provers, i.e, notation $[[x]]$ in the witness list of the
protocol denotes that the provers have shares $[[x]]_\xi$ of $x$. We assume that
there is a designated party $\Ag$ which aggregates the messages received from
provers $P_1,\ldots,P_K$ and constructs the message to be sent to the verifier
$\verifier$. The verifier's  messages are assumed to be available to every
prover through a broadcast channel. Finally, we mention that aggregator's role
is conceptual, and may be played by one of the provers. We proceed to describe
distributed versions of the key subprotocols.\smallskip
\nnote{Probably move it to some common section}

\noindent{\bf Distributed Membership Test}: We describe the variant of the
protocol $\proximityTwoD$ for the case when the matrix $\overline{U}$ is shared
across several parties. The complete protocol appears in Figure
\ref{fig:distprox2d}. \smallskip

\begin{figure}[h!]
\centering
\begin{framed}
\begin{itemize}
\item $\distproxTwoD(\FF,\GG,\ell,L_1,L_2,\bm{c};[[\overline{U}]],[[\bm{\omega}]])$:
\item {\bf Relation}: $(\overline{U},\bm{\omega})=\open(\bm{c})$ and
$\overline{U}\mc{T}\in \mc{C}_2$.
\begin{enumerate}[{\rm 1.}]
\item $\distprover\rightarrow \Ag$: Samples random codeword $u^\xi_0\in L_2$ and
computes $d^\xi_0=\comm(u^\xi_0,\nu^\xi_0)$ for randomly sampled $\nu^\xi_0$.
Sends $d^\xi_0$ to $\Ag$.
\item {\color{red} $\Ag\rightarrow \verifier$: $\Ag$ computes $d_0=\sum_{\xi\in
K}d^\xi_0$ and sends $d_0$ to $\verifier$ }.
\item $\verifier\rightarrow \distprover$: Verifier samples $\tau\sample \FF^m$,
$\delta\sample \FF^{h-m}$ and sends them to $\distprover$.
\item $\Ag\leftrightarrow \verifier$ compute: $\mu=\mc{T}\tau$,
$\mathsf{cm}=d_0+\sum_{i\in [\ell]}\mu_ic_i$, $x=\mc{H}_2\delta$.
\item $\distprover$ computes: $[[z]]^\xi=u^\xi_0+[[\overline{U}]]^\xi\mu$,
$[[\nu]]_\xi=\nu^\xi_0+\sum_{i\in [\ell]}\mu_i[[\omega_i]]^\xi$.
\item {\color{red} $\Ag$ computes: $z=\combine([[z]]^\xi)$,
$\nu=\combine([[\nu]]^\xi)$}.
\item $\Ag$ and $\verifier$ run the subprotocol:
	\begin{itemize}
	\item $b=\innerproduct(\FF,\GG,\bm{g},x,\mathsf{cm},0;z,\nu)$.
	\end{itemize}
\item $\verifier$ accepts if the subprotocol accepts.
\end{enumerate}
\end{itemize}
\end{framed}
\caption{Distributed Membership Test}
\label{fig:distprox2d}
\end{figure}

\noindent{\bf Distributed Proximity Test}: We describe a protocol that allows
multiple provers, each having share of the witness, to construct commitment to
the encoded witness as in Section \ref{sec:witencoding}, and convince the
verifier that the commitment opens to a well formed encoding by providing oracle
access to the commitment. The protocol appears in Figure
\ref{fig:distprox3d}.\smallskip

\begin{figure}[h!]
\centering
\begin{framed}
\begin{itemize}
\item {$\distproxThreeD(\FF,\GG,L_1,L_2,[\pi];[[\ewit]])$}:
\item {\bf Relation}: $\ewit=\open(\pi)$, $\ewit\in \mc{W}$.
\item {\bf Oracle Setup}: 
	\begin{itemize}
	\item $\distprover\rightarrow \Ag$: Each prover computes shares $[[\comoracle]]^\xi$ from $[[\ewit]]^\xi$ as $[[\comoracle]]^\xi=\comm([[\ewit]]^\xi)$ as in Section \ref{sec:construct_oracle}. 
	\item {\color{red} $\Ag$ computes: $\comoracle :=
\combine([[\comoracle]]^\xi)$ and sets $\pi := \comoracle$ as the oracle}.
	\end{itemize}
\begin{enumerate}[{\rm 1.}]
\item $\verifier\rightarrow\distprover$: Verifier samples $r\sample \FF^p$ and
sends $r$ to $\distprover$.
\item $\distprover$ computes:
	\begin{itemize}
	\item $\shr{\tilde{U}} := \sum_{i\in [p]}r_i\shr{\ewit}[i,\cdot,\cdot]$.
	\item $\shr{\tilde{c}_k} := \sum_{i\in [p]}\shr{\comoracle}[i,k]$ for
$k\in [\ell]$.
	\item $\shr{\tilde{\omega}_k} := \sum_{i\in [p]}O^\xi[i,k]$ for
$k\in [\ell]$.
	\end{itemize}
\item $\distprover\rightarrow\Ag$: The provers send $\shr{\tilde{\bm{c}}} :=
(\shr{\tilde{c}_1},\ldots,\shr{\tilde{c}_\ell})$ to $\Ag$.
\item {\color{red} $\Ag\rightarrow\verifier$: $\Ag$ computes $\tilde{\bm{c}} :=
\combine(\shr{\tilde{\bm{c}}})$ and sends
$\tilde{\bm{c}}=(\tilde{c}_1,\ldots,\tilde{c}_\ell)$ to $\verifier$}.
\item $\Ag$ and $\verifier$ run the subprotocol:
	\begin{itemize}
	\item
$b=\distproxTwoD(\FF,\GG,\ell,L_1,L_2,\tilde{\bm{c}};\shr{\tilde{U}})$.
	\end{itemize}
\item $\verifier$ queries: $\verifier$ samples $Q\subseteq [n]$ of size $t$ and
makes oracle queries for positions in $Q$.
\item Oracle Answers: The oracle responds with columns $\pi[\cdot,k]$ for $k\in
Q$.
\item $\verifier$ checks: The verifier checks $\sum_{i\in
[p]}r_i\pi[i,k]=\sum_{i\in [\ell]}\mc{T}[i,k]\tilde{c}_i$ for $k\in Q$.
\item $\verifier$ accepts if the above check succeeds and $b=1$. 
\end{enumerate}
\end{itemize}
\end{framed}
\caption{Distributed 3D Proximity Protocol}
\label{fig:distprox3d}
\end{figure}

\noindent{\bf Distributed Linear Check}: In the distributed linear check, the
provers with shares $\shr{\wit}$ of the witness $\wit$ try to convince the
verifier that $A\wit=b$ for public matrix $A$ and a public vector $b$. In Figure
\ref{fig:distlincheck}, we present the adaptation of the protocol $\linearcheck$ to
the distributed setting. We will assume that the parties have shares of $0^h$.
Without loss of efficiency, this may be obtained as part of obtaining shares of
the witness.

\begin{figure}[h!]
\centering
\begin{framed}
\begin{itemize}
\item {$\distlinearcheck(\FF,\GG,L_1,L_2,A\in \FF^{M\times N},b\in
\FF^M,[\pi];\shr{\ewit},\shr{0^h})$}
\item {\bf Relation}: $\exists \ewit$ s.t. $\ewit=\open(\pi)$ and $A\wit = b$
for $\wit=\dec(\ewit)$.
\item {\bf Oracle Setup}: 
	\begin{itemize}
	\item $\distprover\rightarrow\Ag$: The prover $\distprover$ computes
$\shr{\comoracle} = \comm(\shr{\ewit})$ as in Section
\ref{sec:construct_oracle}. It sends $\shr{\comoracle}$ to $\Ag$. 
	\item {\color{red} $\Ag$ computes: $\comoracle := \combine(\shr{\comoracle})$ and
sets $\pi := \comoracle$}.
	\end{itemize}
\begin{enumerate}[{\rm 1.}]
\item $\verifier\rightarrow\distprover$: $\verifier$ samples $r\sample \FF^N$ and
sends it to $\distprover$.
\item $\distprover\leftrightarrow\verifier$: Provers ($\distprover$) and $\verifier$
compute polynomials $R^i$, $i\in [p]$ such that
$R^i(\alpha_j,\zeta_k)=R[i,j,k]$ where $R=r^TA$. 
\item $\distprover$ computes:
	\begin{enumerate}
	\item Polynomials $\shr{p_j}(\cdot) := \sum_{i\in
[p]}R^i(\alpha_j,\cdot).\shr{Q^i}(\alpha,\cdot)$ for $j\in [h]$. Here the
polynomial $\shr{Q^i}$ interpolates the witness share
$\shr{\wit}[i,\cdot,\cdot]$ on $G$.
	\item An $h\times n$ matrix $\shr{P}$ such that $\shr{P}[j,k]=\shr{p_j}(\eta_k)$.
	\item Commitments $\shr{c_k}=\comm(\shr{P}[\cdot,k],\shr{\omega}_k)$ for $k\in [s+\ell]$
where $\shr{\omega}_k\sample \FF$.
	\item Sample a codeword $\shr{P_0}\in \dashL_2$ s.t $\sum_{j\in
[m]}\shr{P_0}[j]=0$.
Compute $\shr{c_0}=\comm(\shr{P_0},\shr{\omega_0}$ for $\shr{\omega_0}\sample \FF$.
	\item Compute $\shr{Z} := \beta\shr{P_0} + \shr{P}\varphi + \shr{0^h}$ for
$\varphi=\Phi^T[1^s]$.
	\end{enumerate}
\item $\distprover\rightarrow\Ag$: Provers send
$\shr{c_0},\shr{c_1},\ldots,\shr{c_{s+\ell}}$ and $\shr{Z}$ to $\Ag$.

% Aggregation step
\item {\color{red} $\Ag$ computes: $(c_0,c_1,\ldots,c_{s+\ell}) :=
\combine(\shr{c_0},\shr{c_1},\ldots,\shr{c_{s+\ell}})$ and $Z :=
\combine(\shr{Z})$}.

\item $\verifier\rightarrow\distprover$: $\verifier$ samples $(j_u,k_u)\sample [h]\times
[n]$ for $u\in [t]$. It also samples $\beta\sample\FF$. The verifier sends
$Q=\{(j_u,k_u):u\in [t]\}$ and $\beta$ to provers $\distprover$.
\item $\distprover\rightarrow\Ag$: The provers sends vectors
$\shr{Y_u}=\shr{\ewit}[\cdot,\cdot,k_u]$ for $u\in [t]$ to $\Ag$.

% Aggregation step
\item {\color{red} $\Ag$ computes: 
	\begin{itemize}
	\item $Y_u=\combine(\shr{Y_u})$ for $u\in [t]$.
	\item $X_u=Y_u[j_u,\cdot]$ for $u\in [t]$.
	\item Compute $P[\cdot,k_u]$ from $R$ and $Y_u$ for $u\in [t]$.
	\end{itemize}
} 
\item Oracle Queries: $\verifier$ queries the oracle $\pi$ with $\{k_u:u\in
[t]\}$. 
\item Oracle Answers: The oracle replies with columns $\pi[\cdot,k_u]$, $u\in
[t]$.
\item $\Ag\leftrightarrow\verifier$: Both $\Ag$ and $\verifier$
compute $\varphi := \Phi^T[1^s]$ and $\mathsf{cm} := \beta c_0 + \sum_{k\in
[s+\ell]}\varphi_kc_k$.
\item $\Ag$ and $\verifier$ run the subprotocol:
	\begin{itemize}
	\item $b_{\rm 2d} =
\distproxTwoD(\FF,\GG,s+\ell,\dashL_1,\dashL_2,\bm{c};[[\overline{P}]])$
where $\bm{c}=(c_1,\ldots,c_{s+\ell})$ and $\overline{P}$ is the submatrix of $P$
consisting of the first $s+\ell$ columns. Here $\dashL_1=\rsc{\eta}{s+\ell}$ and
$\dashL_2=\rsc{\alpha}{2m}$.
	\end{itemize}
\item $\Ag$ and $\verifier$ run the subprotocol:
	\begin{itemize}
	\item $b = \innerproduct(\GG,\bm{g},x,\mathsf{cm},v;z)$
with $x=(1^m,0^{h-m})$, $v=r^Tb$ and $z=Z$.
	\end{itemize}
\item $\Ag$ and $\verifier$ compute: For all $u\in [t]$ $c_{k_u} =
\sum_{a\in 2\ell}T[a,k_u]c_a$, where $T$ is the matrix such that $P=\overline{P}T$.
\item $\Ag$ and $\verifier$ run inner product subprotocols for each $u\in
[t]$:
	\begin{itemize}
	\item $s_u=\innerproduct(\GG,\bm{g},x,c_{k_u},v;P[\cdot,k_u])$ with
$x=e_{j_u}$, $v=\sum_{i\in [p]}R^i(\alpha_{j_u},\eta_{k_u})X_u$.
	\end{itemize}
\item $\Ag$ and $\verifier$ run aggregate inner product protocols for each
$u\in [t]$:
	\begin{itemize}
	\item
$a_u=\agginnerproduct(\GG,\bm{g},e_{j_u},\pi[\cdot,k_u],X_u;\ewit[\cdot,\cdot,k_u])$
	\end{itemize}
\item $\prover$ and $\verifier$ run the subprotocol: 
	\begin{itemize}
	\item $b_{\rm prox} = \proximityThreeD(\FF,\GG,L_1,L_2,[\pi];U)$
	\end{itemize}
\item The verifier accepts if all the subprotocols accept.
\end{enumerate}
\end{itemize}
\end{framed}
\caption{Distributed Linear Check Protocol}
\label{fig:distlincheck}
\end{figure}

Our next lemma captures the fact that the aggregator $\Ag$ gains no additional
knowledge from the messages sent by the provers in the distributed protocol
$\distlinearcheck$. 

\begin{lemma}\label{lem:distlincheckzk}
For $\xi\in [K]$, let $\View^\xi_\Ag$ denote the view of the aggregator $\Ag$ in the distributed
linear check protocol consisting of messages from the prover $\distprover$ with
witness $\shr{\wit}$. Then there exists an efficient simulator $\simulator$
which outputs a view indistinguishalbe from the joint view $\langle
\View^1_\Ag,\ldots,\View^K_\Ag\rangle$ whenever $A\wit=b$ for
$\wit=\combine(\shr{\wit})$.
\end{lemma}
\begin{proof}


\end{proof}


%\end{enumerate}
   



\subsection{Non-interactive}
IOP to NIROP
