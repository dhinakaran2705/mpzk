%\newcommand{\enc}{\mathsf{Enc}}


\section{DPZKQuickVerify} \label{sec:quickverify}
While the construction of the previous section leads to smaller argument size,
it comes with a considerable degradation to prover and verifier efficiency, as
both the prover and the verifier incur $O(N^{1-1/c})$ exponentiations. Note
that while the prover needs to compute $O(N)$ exponentiations while computing
commitment $\comoracle$, one can use multi-exponentiations to compute the same
using $O(N/\log{N})$ exponentiations which can be significant speed-up in
practice. In this section we additionally leverage homomorphic commitments
(introduced to facilitate distributed proof generation) to obtain a better
trade-off between the argument size and the number of exponentiations computed
by the prover and the verifier. Essentially, we obtain the same argument size
of $N^{1/c}$ for $c\geq 2$ while restricting the inner product arguments to
vectors of size at most $O(N^{1-2/c})$. For practically relevant lower values
of $c$, the gains in efficiency are substantial.
   

\subsection{Witness encoding with RS product code}\label{sec:witencoding}
In this section we describe a randomized encoding of the witness using product
of Reed Solomon Codes. Let $N$ be the length of the witness, and let $p,m$ and
$s$ be integers such that $N=pms$. We canonically view the
witness $\wit$ 
as $p\times m\times s$ matrix with entries $\wit[i,j,k]$ for $i\in [p]$,
$j\in [m]$ and $k\in [s]$. Let $\wit^i$ denote the (two dimensional) sub-matrix
$\wit[i,\cdot,\cdot]$ for $i\in [p]$. To obtain the encoding of
$\wit$, we use product code of two Reed Solomon codes to encode each matrix
$\wit^i$,
$i\in [p]$ as a codeword in the product code. The use of the product code is
essential to ensure soundness of the protocol with constant number of queries.
We now describe the encoding in more detail. Let $\ell := s + \bi$, where we
call $\bi$ as the {\em bounded independence} parameter. 
Throughout the remainder of the paper, let $\bm{\zeta}$, $\bm{\eta}$ and
$\bm{\alpha}$ denote distinct set of points in $\FF$ as specified:
\begin{align}\label{eq:points}
\bm{\zeta} =\{\zeta_1,\ldots,\zeta_{\ell}\},\quad 
\bm{\eta}  = \{\eta_1,\ldots,\eta_n \},\quad
\bm{\alpha} = \{\alpha_1,\ldots,\alpha_{h}\} \text{ where } h>2m. 
\end{align}

We define the interpolation domain $G$ as $G=\{(\alpha_j,\zeta_k): j\in[m],
k\in [\ell]\}$ and evaluation domain $H$ as $H=\{(\alpha_j,\eta_k): j\in [h],
k\in [n]\}$. We encode $\wit$ as follows:
\begin{enumerate}[{\rm (i)}]
\item First we embed $\wit$ into a $p\times m\times \ell$ matrix $\hat{\wit}$
where $\hat{\wit}[i,j,k]=\wit[i,j,k]$ for $k\leq s$, while the entries
$\hat{\wit}[i,j,k]$ for $k>s$ are sampled from $\FF$ uniformly at random.
\item We construct bivariate polynomials $Q^i(x,y)$ with $deg_x(Q)<m$ and
$deg_y(Q)<\ell$ such that $Q^i$ interpolates the slice
$\hat{\wit}[i,\cdot,\cdot]$ on $G$, i.e,
$Q^i(\alpha_j,\zeta_k)=\hat{\wit}[i,j,k]$. 
\item Let $\ewit$ denote the $p\times h\times n$ matrix, where the slice
$\ewit[i,\cdot,\cdot]$ consists of evaluations of $Q^i$ on $H$, i.e,
$\ewit[i,j,k]=Q^i(\alpha_j,\eta_k)$ for $i\in [p], j\in [h]$ and $k\in [n]$.
Then $\ewit$ is a randomized encoding of $\wit$.
\end{enumerate}
We denote the above computation as $\ewit\sample \enc(\wit)$, where $\enc(\wit)$
denotes the random variable denoting the encodings of $\wit$. It is easily seen
that $\ewit\in \rsc{\eta}{\ell}\oplus \rsc{\alpha}{m}$.\smallskip

\noindent{\em Efficiently computing the encoding}: Although the previous
description of the encoding involves the bivariate polynomials, 
the prover does not explicitly need to compute the bivariate polynomials to
construct the encoding. We describe an efficient method to construct the
encoding. Given an $m\times \ell$
matrix $\matx$, the prover first computes polynomials $p_j$ for $j\in
[m]$ as $p_j(y) := \ifft(\matx[j,\cdot], \bm{\zeta})$. Then it constructs a $m\times n$
matrix $\maty$, where the $j^{th}$ row of $\maty$ is evaluation of $p_j$ on the set
$\bm{\eta}$, i.e, $\maty[j,\cdot] := \fft(p_j, \bm{\eta})$. Next, the prover constructs
polynomials $q_k$ for $k\in [n]$ by interpolating the column $\maty[\cdot,k]$ on
$\bm{\alpha}^0 = (\alpha_1,\ldots,\alpha_m)$, i.e, $q_k(x) := \ifft(\maty[\cdot,k],
\bm{\alpha}^0)$. It obtains the encoding $\enc(\matx)$ as the $h\times n$ matrix
$\matz$ whose columns are evaluations of polynomials $q_k$ on the set $\bm{\eta}$, i.e,
$\matz[\cdot,k]=\fft(q_k,\bm{\alpha})$. The above computation involves
$O(mn\log(mn))$ operations in $\FF$ for each $m\times \ell$ matrix. Thus, computing $\enc(\wit)$ takes
$O(pmn\log(mn))$ which is $O(N\log{N})$. We also remark that $\maty$ is a submatrix
of $\matz$, and thus
$p_j=\ifft((\matz[j,1],\ldots,\matz[j,\ell]),(\eta_1,\ldots,\eta_{\ell}))$ for $j\in
[m]$. This allows us to consistently define polynomials $p_j$ for $m<j\leq h$ by
$p_j=\ifft((\matz[j,1],\ldots,\matz[j,\ell]),(\eta_1,\ldots,\eta_{\ell}))$.

The following property of the encoding, that we call {\em bounded independence}
is key to showing privacy properties of our protocol.
\begin{lemma}[Bounded Independence]\label{lem:boundedindependence}
Let $B\subseteq [n]$ be a set of size $\bi$. Let $\mc{U}(p,h,b)$ denote the
set of $p\times h\times b$ matrices $\matx$ such
that $\matx[i,\cdot,k]$ is a codeword in $\rsc{\alpha}{m}$ for all $i\in
[p],k\in [\bi]$. Then for any $p\times m\times s$ matrix $\wit$, the random
variable $\ewit_B := \{\ewit[\cdot,\cdot,B]: \ewit\sample \enc(\wit)\}$ is
distributed uniformly on $\mc{U}(p,h,b)$.
\end{lemma}
We defer the proof of the above Lemma to the Appendix.

\subsection{Constructing Oracle}\label{sec:construct_oracle} 
We deviate from prior IOP constructions
such as \cite{ligero,Aurora} in the way we construct the oracle. The prior
constructions provided oracle access to the encoding of the witness using linear
codes. We
additionally obtain a homomorphic commitment of the encoding $\enc(\wit)$ of the
witness $\wit$ and provide oracle access to the commitment. Concretely, we use a
homomorphic vector commitment scheme $\comm$ with message space $\FF^h$,
commitment space $\GG$ and randomness space $\FF$. We compute commitments
$c_{ik}=\comm(\ewit[i,.,k],\delta_{ik})$ where $\delta_{ik}$ denotes the
commitment randomness. Finally we define $p\times n$ matrix $\comoracle$ as
$\comoracle[i,k]=c_{ik}$. We provide oracle access to $\comoracle$ where for a
query $Q\subseteq [n]$, the oracle responds with columns $\comoracle[.,k]$ for
$k\in Q$.

\subsection{Codes and Matrices}\label{sec:codesandmatrices}
Throughout, let $L_1$ and $L_2$ denote the codes $\rsc{\eta}{\ell}$ and
$\rsc{\alpha}{m}$ respectively. Let $\mc{C}_1 := \ric{L_1}{h}$ and $\mc{C}_2 :=
\cic{L_2}{n}$ denote the interleaved codes of $L_1$ and $L_2$. We denote the
parity check matrices for $L_1$ and $L_2$ by $\mc{H}_1$ and $\mc{H}_2$. We also
notate the set of three dimensional $p\times h\times n$ matrices as $\mc{M}_{p,h,n}$ and
the set of two dimensional $h\times n$ matrices as $\mc{M}_{h\times n}$. We
assume standard distance metrics on the sets $\mc{M}_{p,h,n}$ and $\mc{M}_{h,n}$
as discussed in Section \ref{sec:prelims}. 

\subsection{Proximity Protocols}\label{sec:proximityprotocols}
In this section we introduce the notion of {\em well formed} encodings and
describe protocols to check that an encoding is close to a well formed encoding.
Let $\mc{W}$ denote the subset of $\mc{M}_{p,h,n}$
consisting of matrices $U$ such that $U[i,\cdot,\cdot]\in L_1\oplus L_2$ for all $i\in [p]$. 
Let $\mc{W}_1$ denote the set of matrices
$U$ in $\mc{M}_{p,h,n}$ such that the $n$-length vector $U[i,j,\cdot]$ is a
codeword in $L_1$ for all $i,j$. Similarly let $\mc{W}_2$ denote the set of
matrices $U$ such that the $h$-length vector $U[i,\cdot,k]$ is a codeword in
$L_2$ for all $i,k$. It can be seen that $\mc{W}=\mc{W}_1\cap \mc{W}_2$. For $U^\ast\in \mc{M}_{p,h,n}$ define
$d_i(U^\ast,\mc{W}_i)=\min\{\Delta_i(U^\ast,U):U\in \mc{W}_i\}$ for $i=1,2$.
In this section we present an IPCP for proximity that allows a prover to convince a verifier that
the oracle $\comoracle$ opens to a three dimensional matrix $\ewit\in \mc{W}$. To accomplish the above, we need several tools which we discuss next.
 
\subsubsection{Membership in Product Code:}
We describe a protocol for checking the membership of a matrix in the  product of
the linear codes $L_1$ and $L_2$, given commitments to its columns. 
Assume that $U$ is an $h\times n$ matrix, purported to be a codeword in
$L_1\oplus L_2$. Let $\bar{U}$ denote the $h\times \ell$ matrix consisting of
the first $\ell$ columns of $U$. We note that for $U\in L_1\oplus L_2$, we must
have $U=\bar{U}\mc{T}$ for some $l\times n$ matrix $\mc{T}$ of rank $\ell$. Thus, the membership protocol involves the prover sending the column
commitments $\bm{c}=(c_1,\ldots,c_\ell)$ and prove that they correspond to a matrix
$\bar{U}$ such that $\bar{U}\mc{T}\in \mc{C}_2$ (because $\bar{U}\mc{T}\in
\mc{C}_1$ for all $\bar{U}$). We describe the complete
protocol below:
\begin{figure}[ht]
\begin{framed}
\begin{itemize}
\item {$\proximityTwoD$} $(\FF,\GG, L_1, L_2,\mathbf{c}; \bar{U})$:
\item {\bf Relation}: $\bar{U}=\open(\mathbf{c})$ and $\bar{U}\mc{T}\in \mc{C}_2$.
\begin{enumerate}[{\rm 1.}]
\item $\verifier\rightarrow \prover$: Verifier samples $\tau\sample
\FF^n$, $\delta\sample \FF^{h-m}$ and sends them to the prover.
\item $\prover\leftrightarrow \verifier$ compute: $\mu=\mc{T}\tau$,
$\mathsf{cm} = \sum_{i\in [\ell]} \mu_ic_i$, $x=\mc{H}_2\delta$.
\item $\prover$ computes: $z=\bar{U}\mu$.
\item $\prover$ and $\verifier$ run the subprotocol:
	\begin{itemize}
	\item $b=\innerproduct(\FF,\GG,\bm{g},x,\mathsf{cm},0;z)$
	\end{itemize}
\item $\verifier$ accepts if $b=1$.
\end{enumerate}
\end{itemize}
\end{framed}
\caption{Protocol 1}
\label{fig:protocol1}
\end{figure}

In the above,
$\innerproduct(\FF,\GG,\bm{g},x,\mathsf{cm},v;z)$ denotes an interactive
protocol for proving the relation $\innp{x}{z}=v$ and $\open(\mathsf{cm})=z$,
where $\GG$ denotes the commitment group and $\bm{g}$ denotes the generators for
vector commitment. We now prove the correctness of the membership protocol.

\begin{lemma}[Completeness]\label{lem:proximity2d_complete}
For $\bar{U}$ such that $\bar{U}\mc{T}\in \mc{C}_2$, the protocol $\proximityTwoD$ accepts.
\end{lemma}
\begin{proof}
Observe that $\bar{U}\mc{T}\in \mc{C}_2 \Leftrightarrow (\bar{U}\mc{T})^T\mc{H}_2=\bm{0}$, or
$\mc{T}^T\bar{U}^T\mc{H}_2=\bm{0}$. Thus for any $\tau,\delta$ we have
$\tau^T\mc{T}^T\bar{U}^T\mc{H}_2\delta=0$. The preceeding identity reduces to
$\innp{x}{z}=0$ for  $z=\bar{U}\mc{T}\tau$ and
$x=\mc{H}_2\delta$. Further,
$\comm(z)=\sum_{i\in [\ell]}\mu_ic_i=\mathsf{cm}$ for $\mu=\mc{T}\tau$. The
completeness property of the inner product protocol now guarentees that it
accepts.
\end{proof}
 
\begin{lemma}[Soundness]\label{lem:proximity2d_sound}
For every bounded prover $P^\ast$ and every $\bm{c}\in \GG^n$, there exists an
expected polynomial time extractor $\extr$ with
rewinding access to the transcript oracle $\mc{O}=\langle P^\ast(\bm{c},\cdot),V(\bm{c},\cdot)\rangle$
such that:
\begin{align*}
\condprob{
\begin{array}{l}
\bar{U} = \open(\bm{c}) \wedge \\
\bar{U}\mc{T}\in \mc{C}_2
\end{array}
}{
\begin{array}{l}
\sigma\sample \gen(\secparam) \\
\bar{U}\sample \extr^{\mc{O}}(\bm{c},\sigma)
\end{array}}
\geq 
\condprob{\langle P^\ast(\bm{c},\sigma),\verifier(\bm{c},\sigma)\rangle =
1}{\sigma\sample \gen(\secparam)} - \kappa_{2d}(\secpar)
\end{align*}
for a negligible function $\kappa_{2d}$.
\end{lemma}
\begin{proof}
The extractor $\extr$ starts by emulating the verifier in the protocol
$\proximityTwoD$. At the step 4, it uses the extractor $\extr_{ip}$ for the
inner product protocol to extract the witness $z$ for the $\innerproduct$
subprotocol. If the initial transcript rejects, $\extr$ fails with output
$\bot$. Otherwise, it rewinds transcript to step (1) till it finds $\ell$
additional accepting transcripts. Let $\tau^i,\delta^i$ denote the random
vectors in step 1, in the $i^{th}$ accepting transcript (we let $i=0$ denote the
initial transcript). Similarly, let $x^i$, $\mathsf{cm}^i$ denote the values of
vectors $x$ and $\mathsf{cm}$ in the $i^{th}$ accepting transcript, while $z^i$
denotes the witness extracted by the inner product extractor $\extr_{ip}$
corresponding to $x^i$ and $\mathsf{cm}^i$. If the inner product extractor
$\extr_{ip}$ fails with $z^i=\bot$ for any $i\in [\ell]$, the extractor $\extr$
fails with output $\bot$. From the inner product extractions we have the
following:
\begin{align*}
\begin{array}{cccc}
\comm(z^1)=&  \mu^1_1c_1+ & \hdots & +\mu^1_{\ell}c_{\ell} \\
\vdots & \vdots & \ddots & \vdots \\
\comm(z^l)=& \mu^{\ell}_1c_1+ & \hdots & +\mu^{\ell}_{\ell}c_{\ell} 
\end{array}
\end{align*}
Let $\Lambda$ denote the $\ell\times \ell$ matrix with $\Lambda[i,j]=\mu^i_j$.
Since $\mc{T}$ is a rank $\ell$ matrix, we see that $\Lambda$ is an invertible
matrix for random choices of vectors $\tau^i$, except with probability
$1/|\FF|$. Let $\Omega$ be the $\ell\times \ell$ matrix such that
$\Omega\Lambda=I_{\ell}$. Define $U_k = \sum_{i\in [\ell]}\Omega[k,i]z^i$ for
$k\in [\ell]$. Then we have,
\begin{align*}
\comm(U_k) &= \sum_{i\in [\ell]}\Omega[k,i]\comm(z^i)  \\
	&= \sum_{i\in [\ell]}\Omega[k,i]\sum_{j\in [\ell]}\mu^i_jc_j \\
	&= \sum_{j\in [\ell]}\big(\sum_{i\in [\ell]}\Omega[k,i]\mu^i_j\big)c_j \\
	&= \sum_{j\in [\ell]}\big(\sum_{i\in [\ell]}\Omega[k,i]\Lambda[i,j]\big)c_j
\\
	&= c_k \text{ (using $\Omega\Lambda=I_{\ell})$ }
\end{align*}
Thus $\bar{U}=(U_1,\ldots,U_{\ell})$ satisfies $\open(U)=\bm{c}$. Now we
consider the probability that $\bar{U}\mc{T}\in \mc{C}_2$. Let $A$ denote the event
that the first transcript accepts. Let $B\subseteq A$ be the event that
$(\bar{U}\neq\bot)\cap (\bar{U}\mc{T}\in \mc{C}_2)$. We have,
\begin{align*}
\prob{B} &= \prob{A} - \prob{A\cap \neg B} \\
	&\geq \prob{A} - \prob{A\cap (\bar{U}=\bot)} - \prob{A\cap
(\bar{U}\mc{T}\not\in \mc{C}_2)} \\
	&= \prob{A} - \prob{A\cap (\bar{U}=\bot)} - \prob{A\cap
(\mc{T}^T\bar{U}^T\mc{H}_2\neq 0)} \\
	&\geq \prob{A} - \prob{A\cap (\bar{U}=\bot)} -
\condprob{\tau^T\mc{T}^T\bar{U}^T\mc{H}_2\delta=
0}{\mc{T}^T\bar{U}^T\mc{H}_2\neq 0} \\
	&\geq \prob{\langle P^\ast(\bm{c},\sigma),\verifier(\bm{c},\sigma)\rangle=1}
- \big(\ell.\kappa_{ip}(\secpar)+1/|\FF|\big) - 2/|\FF|
\end{align*} 
In the above, we bound the probability $\condprob{\tau^T\mc{T}^T\bar{U}^T\mc{H}_2\delta=
0}{\mc{T}^T\bar{U}^T\mc{H}_2\neq 0}$ by $2/|\FF|$ as $\tau$ and $\delta$ are
distributed uniformly and independently of the extracted witness $\bar{U}$. The
probability $\prob{A\cap (\bar{U}=\bot)}$ is bound in terms of the probability
of inner product extractor returning an invalid witness or $\Lambda$ being
singular which is at most $\ell.\kappa_{ip}(\secpar)+1/|\FF|$. The
statement of the lemma now holds by setting
$\kappa_{2d}(\secpar):=\ell.\kappa_{ip}(\secpar) + 3/|\FF|$.
\end{proof}

\subsubsection{Proximity to Well Formed Oracle}: We now describe the protocol
that allows a prover to prove that oracle $\comoracle$ opens to a three
dimensional matrix $\ewit\in \mc{W}$ (well formed encodings). To minimize communication, the key idea is that the verifier chooses
$r\sample \FF^p$ and asks the prover to send commitment to the two dimensional
matrix $\tilde{U}:=\sum_{i\in [p]}r_i\ewit[i,\cdot,\cdot]$. Thereafter we use the protocol
$\proximityTwoD$ to check that $\tilde{U}\in L_1\oplus L_2$. The soundness of the overall
protocol follows from the fact that if $\ewit$ is far from a well formed
encoding, with high probability $\tilde{U}$ is far from $L_1\oplus L_2$.
Additionally, we also have to ascertain that the column commitments to
$\tilde{U}$ are consistent with $\comoracle$ with minimal communication. The
protocol description follows:
\begin{figure}[h!]
\begin{framed}
\begin{itemize}
\item {$\proximityThreeD(\FF,L_1,L_2,e,[\pi];\ewit)$}
\item {\bf Relation}: $\ewit=\open(\pi)$, $\ewit\in \mc{W}$.
\item {\bf Oracle Setup}: Prover computes $\comoracle$ from $\ewit$ as in
Section \ref{sec:construct_oracle} and sets
$\pi := \comoracle$ as the oracle.
\begin{enumerate}[{1.}]
\item $\verifier\rightarrow \prover$: Verifier samples $r\sample \FF^p$ and
sends $r$ to $\prover$.
\item $\prover$ computes: 
	\begin{itemize}
	\item $\tilde{U}=\sum_{i\in [p]}r_i\ewit[i,\cdot,\cdot]$.
	\item $\tilde{c}_k = \sum_{i\in [p]}r_i\comoracle[i,k]$ for $k\in [\ell]$.
	\end{itemize}
\item $\prover\rightarrow \verifier$: Prover sends
$\tilde{\bm{c}}=(\tilde{c}_1,\ldots,\tilde{c}_\ell)$ to the verifier.
\item $\prover \text{ and } \verifier$: Prover and verifier run the subprotocol:
	\begin{itemize}
	\item $b=\proximityTwoD(\FF,L_1,L_2,\tilde{\bm{c}};\tilde{U})$
	\end{itemize}
\item $\verifier$ queries: Verifier samples $Q\subseteq [n]$ of size
$t$ and makes oracle queries for positions in $Q$.
\item Oracle Answers: The oracle responds with columns $\pi[.,k]$ for
$k\in Q$.
\item $\verifier$ checks: The verifier checks $\sum_{i\in
[p]}r_i\pi[i,k]=\sum_{i\in [\ell]}\mc{T}[i,k]\tilde{c}_i$ for $k\in Q$ (the matrix $\mc{T}$ as defined earlier).
\item $\verifier$ accepts if the check passes and $b=1$.
\end{enumerate}
\end{itemize}
\end{framed}
\caption{Proximity Protocol for 3D encoding}
\label{fig:prox3d}
\end{figure}

\begin{lemma}[Completeness]\label{lem:proximity3d_complete}
For $\ewit\in\mc{W}$, the protocol $\proximityThreeD$ accepts.
\end{lemma}
\begin{proof}
The assertion follows from the fact that $\ewit\in \mc{W}$ and
$\ewit=\open(\comoracle)$ implies $\tilde{U}\in L_1\oplus L_2$ and
$\tilde{U}=\open(\tilde{\mathbf{c}})$, and from the completeness of the protocol
$\proximityTwoD$.
\end{proof}

\begin{lemma}[Soundness]\label{lem:proximity3d_sound}
For every bounded prover $P^\ast$ and every oracle $\pi\in \FF^{p\times n}$,
there exists a polynomial time extractor $\extr$ with rewinding access to
transcript oracle $\mc{O}=\langle P^\ast(\cdot),\verifier^{\pi}(\cdot)\rangle$
such that:
\begin{align*}
\condprob{
\begin{array}{l}
\ewit=\open(\pi) \wedge \\
\ewit\in \mc{W}_2\wedge \\
d_1(\ewit,\mc{W}_1)\leq e
\end{array}
}{
\begin{array}{l}
\sigma\sample \gen(\secparam)\\
\ewit\sample \extr^{\mc{O}}(\sigma)
\end{array}
}\geq \condprob{\langle
P^\ast(\sigma),\verifier^\pi(\sigma)\rangle=1}{\sigma\sample
\gen(\secparam)}-s_{3d}(\secpar)
\end{align*}
for some negligible function $s_{3d}$. Note that in the above, $\extr$ can
rewind and proceed with fresh queries to the oracle $\pi$. 	
\end{lemma}
\begin{proof}
As before the extractor $\extr$ emulates the verifier in the protocol
$\proximityThreeD$. In case the first transcript is accepting, the extractor
rewinds the prover sufficiently many times to obtain a tree of accepting transcripts with $p$ distinct
choices of the randomness $r$ in step (1) and $\theta := tn$ different values of $Q$
on step (5). Let $r^{1},\ldots,r^{p}$ denote the values of $r$ in step (1)
and let $\tilde{\mathbf{c}}^{1},\ldots,\tilde{\mathbf{c}}^{p}$ denote the corresponding
commitment vectors in step (3). Similarly, let $Q^{uv}$ denote the $v^{th}$
choice of $Q$ corresponding to $u^{th}$ value of $r$ for $u\in [p]$ and $v\in
[\theta]$. We do not consider the initial transcript as part of the tree of
transcripts. We notice that we have $\cup_{v\in [\theta]}Q^{uv}=[n]$ for all
$u\in [p]$, except with probability at most $pn(1-1/n)^{nt}\leq pne^{-t}$. At
step (4), $\extr$ uses extractor $\extr_{2d}$ for the protocol $\proximityTwoD$
to extract $h\times \ell$ matrix $W^{u}$ for $u\in [p]$. The extractor $\extr$ fails with output $\bot$
if $\extr_{2d}$ fails in any of its invocations. By the property of $\extr_{2d}$
we have that $\open(\tilde{\bm{c}}^u)=W^u$ and $W^u\in L_1\oplus L_2$ for all
$u\in [p]$. We construct the witness $\ewit$ by solving for each $h$-length
vector $\ewit[i,\cdot,k]$ for $i\in [p], k\in [n]$ according to
\eqref{eq:extraction3d}. Let $T_1,\ldots,T_n$ denote the columns of matrix
$\mc{T}$. 
\begin{align}\label{eq:extraction3d}
\text{For each $k\in [n]$ we have:}  \nonumber \\
\begin{array}{cccc}
r^1_1\ewit[1,\cdot,k]+ &\hdots & +r^1_p\ewit[p,\cdot,k] &= W^1T_k \\
\vdots & \ddots & \vdots & \vdots \\
r^p_1\ewit[1,\cdot,k]+ &\hdots & +r^p_p\ewit[p,\cdot,k] &= W^pT_k 
\end{array}
\end{align}
Let $\Lambda$ denote the $p\times p$ matrix with $\Lambda[i,j]=r^i_j$. We may
assume that $\Lambda$ is invertible, except with probability $1/|\FF|$. Let
$\Omega$ be such that $\Omega\Lambda = I_p$. It can be seen that the system of
equations \eqref{eq:extraction3d} is satisfied by setting $\ewit[i,\cdot,k]=\sum_{j\in
[p]}\Omega[i,j]W^jT_k$ for $i\in [p],k\in [n]$. First we prove that
$\comm(\ewit[i,\cdot,k])=\pi[i,k]$ for all $i$ and $k$. Indeed,
\begin{align*}
\comm(\ewit[i,\cdot,k]) & =\sum_{j\in [p]}\Omega[i,j]\comm(W^jT_k) \\
	& = \sum_{j\in [p]}\Omega[i,j]\sum_{a\in [\ell]}\mc{T}[a,k]\comm(W^j[.,a]) \\
	& = \sum_{j\in [p]}\Omega[i,j]\sum_{a\in
[\ell]}\mc{T}[a,k]\tilde{\bm{c}}^j_a \\
	& = \sum_{j\in [p]}\Omega[i,j]\sum_{a\in [p]}r^j_a\pi[a,k] \text{ (using check
(7)) } \\
	& = \sum_{a\in [p]} \big(\sum_{j\in [p]}\Omega[i,j]\Lambda[j,a]\big)\pi[a,k]
\\
	& = \pi[i,k]
\end{align*}

Note that the columns
$\ewit[i,\cdot,k]$ are linear combinations of the columns of extracted matrices
$W^u, u\in [p]$ which are codewords in the code $L_2$. Thus, each column
$\ewit[i,\cdot,k]$ in the extracted witness $\ewit$ is a codeword in $L_2$. Thus
 $\ewit\in \mc{W}_2$. Next, we bound the probability that
$d_1(\ewit,\mc{W}_1)\leq e$. To do so, we define the
following events of interest:
\begin{itemize}
\item $A$: denotes the event that the first transcript is accepting. By
definition, $\prob{A}$ is the accepting probability $\prob{\langle
P^\ast(\sigma),\verifier(\sigma)\rangle=1}$.
\item $B$: denotes the sub-event of $A$ when the extracted opening $\ewit$ to the
commitment oracle $\pi$ is valid, i.e $d_1(\ewit,\mc{W}_1)\leq e$. 
\item $F$: denotes the event that $\extr$ fails with output $\bot$. This
happens when one of the invocations subprotocol extractor $\extr_{2d}$ fails, or
unlikely events that the matrix $\Lambda$ is singular, or that $\theta=tn$
repetitions of the random query locations $Q$ fail to cover the set of indices
$[n]$. As discussed in the proof, we can bound $\prob{F}$ by
$p\kappa_{2d}(\secpar) + pne^{-t} + 1/|\FF|$. 
\end{itemize}
Using an analysis similar to the one in the proof of Lemma
\ref{lem:proximity2d_sound}, we have:
\begin{equation}\label{eq:probeq1}
\prob{B}\geq \prob{A} - \prob{F} - \condprob{A}{d_1(\ewit,\mc{W}_1)>e}   
\end{equation}
Let $\tilde{\bm{c}}=(\tilde{c}_1,\ldots,\tilde{c}_\ell)$ denote the vector sent
by the prover in step (3). We consider the $n$-length vector $C_{adv}$
defined by $C_{adv}[k]=\sum_{i\in [\ell]}\mc{T}[i,k]\tilde{c}_i$ for $k\in [n]$. Let
$C_{hon}$ denote the honestly computed vector defined by $C_{hon}[k]=\sum_{i\in
[p]}r_i\pi[i,k]$. Note that for honest oracle $\pi\in\mc{W}$ and honest prover
we would have $C_{adv}=C_{hon}$. Let $\varepsilon := \Delta(C_{adv},C_{hon})$ denote the
hamming distance between the two vectors. Now we can write
$\condprob{A}{d_1(\ewit,\mc{W}_1)>e}$ as:
\begin{align}\label{eq:probeq3}
\condprob{A}{d_1(\ewit,\mc{W}_1)>e} &\leq \max(\condprob{A}{d_1(\ewit,\mc{W}_1)>e,
\varepsilon \leq e},\condprob{A}{d_1(\ewit,\mc{W}_1)>e, \varepsilon > e})
\end{align}
The above follows from the identity $\condprob{A}{X}\leq
\max(\condprob{A}{X_1},\condprob{A}{X_2})$ for $X=X_1\uplus X_2$. Next we note
that for $\varepsilon > e$, the check in step 7, succeeds with probability at most
$(n-e)^t/n^t=(1-e/n)^t$. Thus $\condprob{A}{d_1(\ewit,\mc{W}_1)>e,\varepsilon > e}\leq
(1-e/n)^t$. Next we bound $\condprob{A}{d_1(\ewit,\mc{W}_1)>e,\varepsilon\leq e}$.
With probability at least $1-\kappa_{2d}(\secpar)$, the extractor $\extr_{2d}$
produces a witness $\bar{U}$ such that $\bar{U}\mc{T}\in L_1\oplus L_2$, and
$\bar{U}=\open(\tilde{\bm{c}})$.  Let
$U_{adv} = \bar{U}\mc{T}$ denote the codeword in $L_1\oplus L_2$. We note that
$U_{adv}=\open(C_{adv})$. Define $U_{hon}=\sum_{i\in [p]}r_i\ewit[i,.,.]$. Note
that $U_{hon}=\open(C_{hon})$ by homomorphism of the commitment scheme. Since
$\varepsilon=d(C_{adv},C_{hon})\leq e$, we must have:
\begin{enumerate}[{\rm (i)}]
\item $\Delta_1(U_{adv},U_{hon})\leq e$ or,
\item There exists an index $j\in [n]$ such that $C_{adv}[j]=C_{hon}[j]$, but
their corresponding openings $U_{adv}[j]$ and $U_{hon}[j]$ are different. This
constitutes breakage to the binding property of the commitment scheme $\comm$. 
\end{enumerate}
Assuming $\Delta_1(U_{adv},U_{hon})\leq e$, we have $d_1(U_{hon},\mc{C}_1)\leq
e$. From the above, we can now write:
\begin{equation}\label{eq:probeq4}
\condprob{A}{d_1(\ewit,\mc{W}_1)>e,\varepsilon\leq e}\leq
\condprob{d_1(U_{hon},\mc{C}_1)\leq e}{d_1(\ewit,\mc{W}_1)>e} + \mc{B}(\secpar)
\end{equation}
Since $U_{hon}=\sum_{i\in [p]}r_i\ewit[i,\cdot,\cdot]$, from Lemma
\ref{lem:3dcompression}, we have $\condprob{d_1(U_{hon},\mc{C}_1)\leq
e}{d_1(\ewit,\mc{W}_1)>e}<d_1/|\FF|$ where $d_1$ is the minimum distance of the
code $L_1$. Thus, Equation \eqref{eq:probeq3} gives us
\begin{equation}\label{eq:probeq5}
\condprob{A}{d_1(\ewit,\mc{W}_1)>e}\leq \max\left\{\left(1-\frac{e}{n}\right)^t,
\frac{d_1}{|\FF|}+\kappa_{2d}(\secpar) + \mc{B}(\secpar)\right\}
\end{equation}
From Equations \eqref{eq:probeq1} and \eqref{eq:probeq5} we see that the
statement of the Lemma holds for 
\[\kappa_{3d}(\secpar) := (p+1)\kappa_{2d}(\secpar) + pne^{-t} +
\left(1-\frac{e}{n}\right)^t + \frac{d_1+1}{|\FF|} + \mc{B}(\secpar) \]
\end{proof}

\subsection{Linear Check Protocol}
In this section, we describe an IPCP that allows a prover to prove knowledge of
witness $\wit\in \FF^N$ satisfying a linear constraint of the form $A\wit = b$
for some $A\in \FF^{M\times N}$ and $b\in \FF^M$. As before we veiw $\wit$ as
$p\times m\times \ell$ matrix where $N=pm\ell$. As desribed previously in Sections
\ref{sec:witencoding} and \ref{sec:construct_oracle}, we obtain $\ewit :=
\enc(\wit)$ and $\comoracle := \comm(\ewit)$. We present the full protocol in
Figure \ref{fig:linearcheck}. Below we summarize the key ideas in the protocol.
\smallskip

\noindent {\em Probabilistic Reduction}: To check $A\wit = b$, the verifier samples
random $r\sample \FF^M$ and asks the prover to prove $r^TA\wit = r^Tb$ instead.
\smallskip

\noindent {\em Reduction to Polynomial Identity}: Both prover and verifier view the
vector $r^TA\in \FF^N$ as a $p\times m\times \ell$ matrix $R$ and interpolate
polynomials $R^i(x,y)$ for $i\in [p]$ with $deg_x(R^i)<m$ and $deg_y(R^i)<\ell$
satisfying $R^i(\alpha_j,\zeta_k)=R[i,j,k]$. Let $Q^i$, $i\in [p]$ denote the
polynomials used in interpolating (and encoding) witness $\wit$. Then, 
$\wit[i,j,k]=Q^i(\alpha_j,\zeta_k)$. The check $\innp{R}{\wit}=r^Tb$ reduces to
$\sum_{i,j,k}R^i(\alpha_j,\zeta_k).Q^i(\alpha_j,\zeta_k)=r^Tb$ where $i,j$ and
$k$ run over indices in $[p],[m]$ and $[\ell]$ respectively. In principle, the
prover can send the degree $2\ell$ polynomial
$p(\cdot):=\sum_{i=1}^p\sum_{j=1}^mR^i(\alpha_j,\cdot)Q^i(\alpha_j,\cdot)$ and
the verifier can check $\sum_{k\in [\ell]} p(\zeta_k)=r^Tb$. 
\smallskip

\noindent {\em Reduction to Inner Product}: Let $p(\bm{\zeta})$ denote the vector of
evaluations of $p$ on points in $\bm{\zeta}$. Let $\overline{\bm{\eta}}$ denote
the points $(\eta_1,\ldots,\eta_{2\ell})$. The check $\sum_{k\in
[\ell]}p(\zeta_k)=r^Tb$ can be written as $\innp{1^\ell}{p(\bm{\zeta})}=r^Tb$. 
Let $p_j$ denote the polynomial $\sum_{i\in
[p]}R^i(\alpha_j,\cdot).Q^i(\alpha_j,\cdot)$ for $j\in [h]$. Note that
$p=\sum_{j\in [m]}p_j$. We see that there exists a $2\ell\times \ell$ matrix
$\Phi$ such that $p(\bm{\zeta})=\Phi p(\overline{\bm{\eta}})$. We now describe
how to compute $p(\overline{\bm{\eta}})$ from ``tamper resistant'' structures
(such as codewords). Define $h\times n$ matrix $P$ by $P[j,k]=p_j(\eta_k)$. Note
that the matrix $P$ is in the product code of codes $\rsc{\eta}{2\ell}$ and
$\rsc{\alpha}{2m}$. Let $\bar{P}$ denote the matrix consisting of the first
$2\ell$ columns of $P$ and let $c_1,\ldots,c_{2\ell}$ be the commitments of the
columns of $\bar{P}$. Now it can be seen that:
\begin{align}
p(\overline{\bm{\eta}}) = \begin{bmatrix} p(\eta_1) \\ \vdots \\
p(\eta_{2\ell}) \end{bmatrix} = 
	{\begin{bmatrix}
	p_1(\eta_1) & \hdots & p_1(\eta_{2\ell}) \\
	\vdots & \ddots & \vdots \\
	p_m(\eta_1) & \hdots & p_m(\eta_{2\ell}) \\
	\vdots & \ddots & \vdots \\
	p_h(\eta_1) & \hdots & p_h(\eta_{2\ell})
	\end{bmatrix}}^T
	\begin{bmatrix}
	1^m \\
	0^{h-m}
	\end{bmatrix}=\bar{P}^T\begin{bmatrix} 1^m \\ 0^{h-m}\end{bmatrix}
\end{align}
From the above we have, 
\begin{align}\label{eq:necessarycondlin}
\innp{1^\ell}{p(\bm{\zeta})} = \left\langle 1^\ell, \Phi\bar{P}^T\begin{bmatrix}
1^m \\ 0^{h-m} \end{bmatrix}\right\rangle = {\begin{bmatrix} 1^m \\ 0^{h-m}
\end{bmatrix}}^T\bar{P}\Phi^T[1^\ell]
\end{align}
Let $\varphi=(\varphi_1,\ldots,\varphi_{2\ell})$ denote the vector
$\Phi^T[1^\ell]$. Then, check $\sum_{k\in [\ell]}p(\zeta_k)=r^Tb$ reduces to
proving the inner product $\langle (1^m,0^{h-m}),\bar{P}\varphi\rangle=r^Tb$. Given
commitments $c_1,\ldots,c_{2\ell}$ we can compute commitment to the vector
$\bar{P}\varphi$ and then run the
protocol
$\innerproduct(\GG,\bm{g},x, \mathsf{cm},v;z)$ with $x=(1^m, 0^{h-m})$,
$z=\bar{U}\varphi$, $v=r^Tb$ and $\mathsf{cm}=\sum_{k\in [\ell]}\varphi_kc_k$.
The
advantage of the above is that $P$ has ``tamper resistant'' structure of being a
product codeword (which we can check given commitments $c_1,\ldots,c_{2\ell}$),
and we can establish if it is correctly derived from encoded witness $\ewit$ by
checking consistency at a few locations.\smallskip

\noindent{\em Checking Consistency with Oracle}: Note that a correctly computed
$P$ in the previous step satisfies $P[j,k]=\sum_{i\in
[p]}R^i(\alpha_j,\eta_k).\ewit[i,j,k]$. The verifier samples $t$ pairs $(j_u,k_u)$ for $u\in
[t]$ uniformly from $[h]\times [n]$ and asks the prover to provide vectors
$\ewit[\cdot,j_u,k_u]$ and $\pi[\cdot,k_u]$ for all $u\in [t]$. The prover and
verifier then run inner product protocols to check:
\begin{enumerate}[{\rm (i)}]
\item $P[j_u,k_u]=\langle P[\cdot,k_u], e_{j_u}\rangle=\sum_{i\in
[p]}R^i(\alpha_{j_u},\eta_{k_u}).\ewit[i,j_u,k_u]$ for $u\in [t]$.
\item Check that $\ewit[i,j_u,k_u]$ is consistent with oracle $\pi$ by verifying
$\innp{\ewit[i,\cdot,k_u]}{e_{j_u}}=\ewit[i,j_u,k_u]$. Note that the commitment
$\pi[i,k_u]$ for $\ewit[i,\cdot,k_u]$ is obtained as part of oracle answer. As
we shall see we can check the consistency of entire column $\ewit[\cdot,j_u,k_u]$
using one inner product check.
\end{enumerate}

\begin{figure}[h!]
\centering
\begin{framed}
\begin{itemize}
\item {$\linearcheck(\FF,\GG,L_1,L_2,A\in \FF^{M\times N},b\in \FF^M,[\pi];\wit)$}:
\item {\bf Relation}: $\exists \wit,\ewit$ s.t $\ewit=\open(\pi)$,
$\ewit=\enc(\wit)$ and $A\wit = b$.
\item {\bf Oracle Setup}: The prover $\prover$ computes $\ewit = \enc(\wit)$ and
$\comoracle = \comm(\ewit)$ as in Sections \ref{sec:witencoding} and
\ref{sec:construct_oracle}. The prover sets $\pi := \comoracle$ as the oracle.
\begin{enumerate}[{\rm 1.}]
\item $\verifier\rightarrow\prover$: $\verifier$ samples $r\sample \FF^N$ and
sends it to $\prover$.
\item $\prover\longleftrightarrow\verifier$: Both $\prover$ and $\verifier$
compute polynomials $R^i$, $i\in [p]$ such that
$R^i(\alpha_j,\zeta_k)=r[i,j,k]$. 
\item $\prover$ computes:
	\begin{enumerate}
	\item Polynomials $p_j(\cdot) := \sum_{i\in
[p]}R^i(\alpha_j,\cdot).Q^i(\alpha,\cdot)$ for $j\in [h]$.
	\item An $h\times n$ matrix $P$ such that $P[j,k]=p_j(\eta_k)$.
	\item Commitments $c_1,\ldots,c_{2\ell}$ to the first $2\ell$
columns of $P$.
	\end{enumerate}
\item $\prover\rightarrow\verifier$: The prover sends $c_1,\ldots,c_{2\ell}$ to
the verifier.
\item $\verifier\rightarrow\prover$: $\verifier$ samples $(j_u,k_u)\sample [h]\times
[n]$ for $u\in [t]$ and sends $Q=\{(j_u,k_u):u\in [t]\}$ to $\prover$.
\item $\prover\rightarrow\verifier$: The prover sends vectors
$X_u=\ewit[\cdot,j_u,k_u]$ for $u\in [t]$ to $\verifier$.
\item Oracle Queries: $\verifier$ queries the oracle $\pi$ with $\{k_u:u\in
[t]\}$. 
\item Oracle Answers: The oracle replies with columns $\pi[\cdot,k_u]$, $u\in
[t]$.
\item $\prover\longleftrightarrow\verifier$: Both $\prover$ and $\verifier$
compute $\varphi := \Phi^T[1^\ell]$ and $\mathsf{cm} := \sum_{k\in
[2\ell]}\varphi_kc_k$.
\item $\prover$ and $\verifier$ run the subprotocol:
	\begin{itemize}
	\item $b_{\rm 2d} = \proximityTwoD(\FF,\GG,\dashL_1,\dashL_2,\bm{c};\bar{P})$
where $\bm{c}=(c_1,\ldots,c_{2\ell})$ and $\bar{P}$ is the submatrix of $P$
consisting of first $2\ell$ columns. Here $\dashL_1=\rsc{\eta}{2\ell}$ and
$\dashL_2=\rsc{\alpha}{2m}$.
	\end{itemize}
\item $\prover$ and $\verifier$ run the subprotocol:
	\begin{itemize}
	\item $b = \innerproduct(\GG,\bm{g},x,\mathsf{cm},v;z)$
with $x=(1^m,0^{h-m})$, $v=r^Tb$ and $z=\bar{P}\varphi$.
	\end{itemize}
\item $\prover$ and $\verifier$ compute: For all $u\in [t]$ $c_{k_u} =
\sum_{a\in 2\ell}T[a,k_u]c_a$, where $T$ is the matrix such that $P=\bar{P}T$.
\item $\prover$ and $\verifier$ run inner product subprotocols for each $u\in
[t]$:
	\begin{itemize}
	\item $s_u=\innerproduct(\GG,\bm{g},x,c_{k_u},v;P[\cdot,k_u])$ with
$x=e_{j_u}$, $v=\sum_{i\in [p]}R^i(\alpha_{j_u},\eta_{k_u})X_u$.
	\end{itemize}
\item $\prover$ and $\verifier$ run aggregate inner product protocols for each
$u\in [t]$:
	\begin{itemize}
	\item
$a_u=\agginnerproduct(\GG,\bm{g},e_{j_u},\pi[\cdot,k_u],X_u;\ewit[\cdot,\cdot,k_u])$
	\end{itemize}
\item $\prover$ and $\verifier$ run the subprotocol: 
	\begin{itemize}
	\item $b_{\rm prox} = \proximityThreeD(\FF,L_1,L_2,e,[\pi];U)$
	\end{itemize}
\item The verifier accepts if all the subprotocols accept.
\end{enumerate}
\end{itemize}

\begin{itemize}
\item $\agginnerproduct(\FF,\GG,\bm{g},x,\bm{c}\in \GG^n,\bm{v}\in \FF^n;W\in
\FF^{m\times n})$:
\item {\bf Relation}: $\forall i\in [n]$: $W[i,\cdot]=\open(\bm{c}[i])$,
$\innp{x}{W[i,\cdot]}=v[i]$. 
\begin{enumerate}
\item $\verifier\rightarrow\prover$: Verifier samples $\delta\in \FF^n$ and
sends it to the prover.
\item $\prover\leftrightarrow\verifier$ compute: $\mathsf{cm}=\sum_{i\in
[n]}\delta_i\bm{c}[i]$, $V=\sum_{i\in [n]}\delta_i\bm{v}[i]$
\item $\prover$ and $\verifier$ run the subprotocol:
	\begin{itemize}
	\item $b=\innerproduct(\FF,\GG,\bm{g},\delta,\mathsf{cm},V;\bm{v}^TW)$
	\end{itemize}
\item $\verifier$ accepts if $b=1$.
\end{enumerate}
\end{itemize}
\end{framed}
\caption{Linear Check Protocol}
\label{fig:linearcheck}
\end{figure}

In Figure \ref{fig:linearcheck}, the protocol $\agginnerproduct$ denotes the protocol for veryfying inner
products of several commited vectors with a common vector. The completeness of
the linear check protocol can be easily verified. We provide the proof for its
soundness.
\begin{lemma}[Soundness]\label{lem:linercheck_sound}
For all polynomially bounded provers $P^\ast$ and all $\pi\in \GG^{p\times n}$,
$A\in \FF^{M\times N}, b\in \FF^M$, there exists an expected polynomial time
extractor $\extr$ with rewinding access to transcript oracle $\mc{O}=\langle
P^\ast(\cdot),\verifier^\pi(\cdot)\rangle$ such that:
\begin{align*}
\condprob{A\wit = b}{
\begin{array}{c}
\sigma\sample \gen(\secparam) \\
\wit\sample \extr^{\mc{O}}(\bm{x},\sigma)
\end{array}}\geq
\condprob{\innp{P^\ast(\bm{x},\sigma)}{\verifier^\pi(\bm{x},\sigma)}=1}
{\sigma\sample\gen(\secparam)}-s_{lc}(\secpar)
\end{align*}
for negligible function $s_{lc}$. In tha above $\bm{x} := (A,b,M,N)$.
\end{lemma}
\begin{proof}
We describe an extractor $\extr$ which outputs $\wit$ such that $U=\enc(\wit)$
and $\open(\pi)=U$. The extractor $\extr$ uses the extractor $\extr_{3d}$ for
the protocol $\proximityThreeD$ to extract the witness $\ewit$ which opens to
the oracle $\pi$. Note that, with high probability ($1-\kappa_{3d}(\secpar)$),
the extracted witness $\ewit$ satisfies $d_1(\ewit,\mc{W}_1)<e$ and $\ewit\in
\mc{W}_2$. It follows that for each slice $\ewit^i:=\ewit[i,\cdot,\cdot]$ for $i\in [p]$,
we have $\ewit^i\in \mc{C}_2$ and $d_1(\ewit^i,\mc{C}_1)<e$. Let $E\subseteq
[n]$ denote the indices of the {\em planes} where $\ewit$ differs from its closest
neighbor in $\mc{W}_1$. Since $e<d_1/2$, $E$ also denotes the set of columns
where slices $\ewit^i$ differ from their closest neighbors in $\mc{C}_1$. We
decode each slice seperately. Applying Lemma \ref{lem:bicdecoding} for each
slice, we have codewords $W^i\in L_1\oplus L_2$ for each $i\in [p]$ such that
$W^i[\cdot,k]=\ewit^i[\cdot,k]$ for all $k\not\in E$. Let $Q^i$, $i\in [p]$ be
the unique polynomials with $deg_x(Q^i)<m$ and $deg_y(Q^i)<\ell$ such that
$Q^i(\alpha_j,\eta_k)=W^i[j,k]$ for $(j,k)\in [h]\times [n]$. We define the
witness $\wit$ by $\wit[i,j,k] := Q^i(\alpha_j,\zeta_k)$ for $i\in [p],j\in
[m],k\in [\ell]$. The extractor $\extr$ outputs $\wit$. In case, the subprotocol extractor
$\extr_{3d}$ outputs $\ewit$ such that $d_1(\ewit,\mc{W}_1)>e$, the extractor
$\extr$ fails with output $\wit := \bot$. Let $\ewit_{\rm hon} := \enc(\wit)$
denote the encoding of $\wit$. Observe that we have $d_1(\ewit,\ewit_{\rm
hon})<e$. Let $\mc{S}$ denote the event that the
first transcript succeeds. As before, the key step to ensure soundness is to
upper bound the probability $\prob{\mc{S}\cap (A\wit\neq b)}\leq
\condprob{\mc{S}}{A\wit\neq b}\leq \condprob{\mc{S}}{r^TA\neq r^Tb}+1/|\FF|$
where $r\sample \FF^N$ denotes the message sent by $\verifier$ in Step 1. Let
$P_{\rm hon}$ denote the matrix $P$ which is correctly computed from $\ewit_{\rm
hon}$ in
Step 3. Let $c_1,\ldots,c_{\ell}$ be the commitments sent (possibly,
adverserial) by the prover to the verifier in Step 4. Let $\bar{P}_{\rm adv}$ be the
witness extracted using the extractor $\extr_{2d}$ for the subprotocol in Step
10. Let $P_{\rm adv}$ denote the matrix $\bar{P}_{\rm adv}T$. Then with overwhelming
probability ($1-\kappa_{2d}(\secpar)$), $P_{\rm adv}\in \dashL_1\oplus \dashL_2$. Observe
that if $P_{\rm hon}=P_{\rm adv}$, then $r^TA\neq r^Tb$ implies that
$\bar{P}=\bar{P}_{\rm adv}$ does not satisfy Equation
\eqref{eq:necessarycondlin} and thus the subprotocol in Step 11 succeeds with
probability at most $\kappa_{ip}(\secpar)$, or $\extr$ succeeds in finding
distinct openings to the commitment in subprotocol in Step 11. Assume then that $P_{\rm hon}\neq
P_{\rm adv}$. Again, from subprotocol in Step 14, we conclude that $X_u =
\ewit[\cdot,j_u,k_u]$, except with probability $\kappa_{agg}(\secpar)$, or
$\extr$ outputs two openings to one of the commitments $\pi[j_u,k_u]$ for $u\in
[t]$. Similarly, assuming $\extr$ does not break binding of the commitment
scheme, the witnesses extracted for inner product protocols in Step 13, are the
columns $P_{\rm adv}[\cdot,k_u]$ for $u\in [t]$. Thus, with overwhelming probability, the inner product check in Step 13 is
equivalent to checking the following for all $u\in [t]$:
\begin{equation}\label{eq:check1}
P_{\rm adv}[j_u,k_u]=\sum_{i\in
[p]}R^i(\alpha_{j_u},\eta_{k_u})\ewit[i,j_u,k_u]
\end{equation}
For $u\in [t]$, let $\mc{E}_u$ denote the event that the above equation holds
for $u$. For $k_u\not\in E$, we have $\ewit[\cdot,\cdot,k_u]=\ewit_{\rm
hon}[\cdot,\cdot,k_u]$ and thus the right hand side in \eqref{eq:check1} equates
to $P_{\rm hon}[j_u,k_u]$. Now, $P_{\rm adv}$ and $P_{\rm hon}$ differ in at
least $\dashD_1$ columns, where $\dashD_1$ denotes the minimum distance of the
code $\dashL_1$. Let $E'$ denote the column indices where $P_{\rm adv}$ and
$P_{\rm hon}$ differ. For $k_u\in E'\backslash E$, the check succeeds if the
distinct codewords $P_{\rm adv}[\cdot,k_u]$ and $P_{\rm hon}[\cdot,k_u]$ agree
at position $j_u$. Since $(j_u,k_u)$ are sampled uniformly and independently
(also independent of extracted witness $\wit$), we have:
\begin{align}\label{eq:probeq6}
\prob{\mc{E}_u} &\leq \frac{n-\dashD_1+e}{n} +
\frac{\dashD_1-e}{n}.\frac{h-\dashD_2}{h}
\nonumber \\
	&\leq \frac{2\ell+e}{n} + \frac{n-2\ell-e}{n}.\frac{2m}{h} \nonumber \\
	& = \frac{2m}{h} +
\left(1-\frac{2m}{h}\right)\left(\frac{2\ell+e}{n}\right)
\end{align}
For initial transcript to accept, all the $t$ checks should succeed, and thus we
have:
\begin{align}\label{eq:probeq7}
\prob{\mc{S}\cap (A\wit\neq b)}&\leq
\left(\frac{2m}{h}+\left(1-\frac{2m}{h}\right)\left(\frac{2\ell+e}{n}\right)\right)^t
+ \kappa_{3d}(\secpar) + \mc{B}(\secpar) +
\frac{O(|C|)}{|\FF|} \nonumber \\
&\leq \left(1-\frac{e}{n}\right)^t +
\left(\frac{2m}{h}+\left(1-\frac{2m}{h}\right)\left(\frac{2\ell+e}{n}\right)\right)^t
+ \frac{O(|C|)}{|\FF|} + \mc{B}(\secpar)
\end{align}
Thus the statement of the lemma holds for $\kappa_{lc}(\secpar) := (1-e/n)^t +
(2m/h + (1-2m/h)(2\ell/n + e/n))^t+O(|C|)/|\FF|+\mc{B}(\secpar)$.
\end{proof}

\subsection{Quadratic Check Protocol}
We now describe the IPCP which allows a prover to prove knowledge of vectors
$\wit_x$, $\wit_y$ and $\wit_z$ in $\FF^N$, satisfying $\wit_x\circ \wit_y =
\wit_z$. Once again, the protocol requires the prover to construct encodings
$\ewit_x=\enc(\wit_x)$, $\ewit_y=\enc(\wit_y)$ and $\ewit_z=\enc(\wit_z)$ as
described in Section \ref{sec:witencoding}. Thereafter, the prover uses
commitment scheme $\comm$ to commit to these encodings as $\comoracle_x =
\comm(\ewit_x)$, $\comoracle_y = \comm(\ewit_y)$ and $\comoracle_z = \comm(\ewit_z)$. 
The prover forms the oracle $\pi\in \GG^{3p\times n}$ by vertically stacking the
$p\times n$ matrices $\comoracle_x,\comoracle_y$ and $\comoracle_z$. As before,
for a query $Q\subseteq [n]$, the oracle answers with columns $\pi[\cdot,k]$ for
$k\in Q$. The columns returned by the oracle can be parsed into constituent columns 
$\comoracle_x[\cdot,k]$, $\comoracle_y[\cdot,k]$ and $\comoracle_z[\cdot,k]$
canonically. We again discuss the key ingredients of the protocol.\smallskip

\noindent{\em Probabilistic Reduction}: Let $Q^i_x,Q^i_y$ and $Q^i_z, i\in [p]$ be the
polynomials interpolating the $i^{th}$ slices of $\wit_x$, $\wit_y$ and $\wit_z$
 on $G$ respectively. Then for vectors $\wit_x,\wit_y,\wit_z$ satisfying
$\wit_x\circ \wit_y=\wit_z$, the polynomials $Q^i=Q^i_x\cdot Q^i_y - Q^z_i$ interpolate
$\bm{0}^{m\times \ell}$ on $G$ for all $i\in [p]$. This can be probabilistically
checked by checking that the polynomial $F := \sum_{i\in [p]}r_iQ^i$ interpolates
$\bm{0}^{m\times \ell}$ on $G$ for randomly sampled $r\in \FF^p$. Once again, we
ask the prover to ``commit'' to $F$ using a tamper resistant structure, like a codeword,
which enables the verifier to check the aforementioned condition, as well as to
ensure that the commitment is consistent with oracle replies and prior
messages.\smallskip

\noindent{\em Reduction to Inner Products}: The prover computes the matrix
$h\times n$ matrix $P$ given by $P[j,k]=F(\alpha_j,\eta_k)$. It commits to $P$
using commitments $(c_1,\ldots,c_{2\ell})$ to the first $2\ell$ columns of $P$.
Note that each row of $P$ commits to univariate component polynomials
$F(\alpha_j,\cdot)$ of $F$ via their evaluations of $\bm{\eta}$. To check that
$F$ interpolates $\bm{0}^{m\times \ell}$ on $G$, the verifier checks that
$p(\cdot) := \sum_{j\in [m]}\gamma_jF(\alpha_j,\cdot)$ interpolates $\bm{0}^{\ell}$ on
$\bm{\zeta}$ for randomly sampled $\gamma=(\gamma_1,\ldots,\gamma_m)\in \FF^m$.
Again, the verifier checks $p(\bm{\zeta})=\bf{0}^{\ell}$ via the inner product
check $\innp{\tau}{p(\bm{\zeta})}$ for a random $\tau\in \FF^{\ell}$. As in the
linear check protocol, using $p(\bm{\zeta})=\Phi p(\overline{\bm{\eta}})$, we
get the following inner product check
$\innp{(\gamma,0^{h-m})}{\bar{P}\varphi}=0$ where $\varphi=\Phi^T\tau$. Again,
the commitment to the vector $\bar{P}\varphi$ can be homomorphically computed
from $c_1,\ldots,c_{2\ell}$. \smallskip

\noindent{\em Checking consistency with Oracle}: As in the linear check, the
verifier uniformly and independently samples $(j_u,k_u)\in [h]\times [n]$ for
$u\in [t]$, and queries the oracle $\pi$ for columns $\pi[\cdot,k_u]$. Let
$\pi_x[\cdot,k_u]$, $\pi_y[\cdot,k_u]$ and $\pi_z[\cdot,k_u]$ denote the parse
of $\pi[\cdot,k_u]$ into commitments corresponding to $\ewit_x,\ewit_y$ and
$\ewit_z$ respectively. Further, the verifier asks prover for vectors
$\ewit_x[\cdot,j_u,k_u]$, $\ewit_y[\cdot,j_u,k_u]$ and $\ewit_z[\cdot,j_u,k_u]$
for $u\in [t]$. The verifier then checks the following:
\begin{enumerate}[{\rm (i)}]
\item For all $u\in [t]$: $P[j_u,k_u]=\sum_{i\in
[p]}r_i(\ewit_x[i,j_u,k_u]\cdot\ewit_y[i,j_u,k_u]-\ewit_z[i,j_u,k_u])$.
\item Checks that vectors $\ewit_x[\cdot,j_u,k_u]$ are consistent with
commitments $\pi_x[\cdot,k_u]$ as in linear check protocol. Similar checks are
made for $\ewit_y[\cdot,j_u,k_u]$ and $\ewit_z[\cdot,j_u,k_u]$.
\end{enumerate}
We present the full protocol in Figure \ref{fig:quadcheck}. The completeness of
the protocol can again be verified by direct calculation. We state the soundness
of the protocol below:
\begin{lemma}[Soundness]\label{lem:quadcheck_sound}
For all polynomially bounded provers $P^\ast$ and all $\pi\in \GG^{3p\times n}$,
there exists an expected polynomial time extractor $\extr$ with rewinding access
to the transcript oracle $\mc{O}=\innp{P^\ast(\cdot)}{\verifier^{\pi}(\cdot)}$
such that:
\begin{align*}
\condprob{\wit_x\circ\wit_y=\wit_z}{
\begin{array}{c}
\sigma\sample \gen(\secparam) \\
(\wit_x,\wit_y,\wit_z)\sample \extr^{\mc{O}}(\sigma)
\end{array}
}\geq \condprob{\innp{P^\ast(\sigma)}{\verifier^{\pi}(\sigma)}=1}{\sigma\sample
\gen(\secparam)} - \kappa_{qd}(\secpar)
\end{align*}
for some negligible function $\kappa_{qd}$.
\end{lemma}
\begin{proof}
The proof is similar to the proof of the linear check protocol. Using similar
arguments, one can show that the above Lemma holds with:
\begin{equation*}
\kappa_{qd}(\secpar) := \left(1-\frac{e}{n}\right)^t +
\left(\frac{2m}{h}+\left(1-\frac{2m}{h}\right)\left(\frac{2\ell+e}{n}\right)\right)^t
+ \frac{O(|C|)}{|\FF|} + \mc{B}(\secparam)
\end{equation*}
\end{proof}

\subsection{Zero Knowledge}
We now prove protocols $\linearcheck$ and $\quadcheck$ to be honest verifier zero knowledge by
designing simulators for them. We will infact simulate ``extended'' view of the
verifier. This will help us in proving the privacy of our protocol in
distributed setting (in particular, the protocol specific messages received by
the aggregator do not {\em leak}). Consider the view of the verifier in the
protocol $\linearcheck$. We start by specifying the extended views of various
subprotocols. We use $\vert$ to seperate components in extended view which are
not part of verifier's view in the protocol. In our descriptions of the views of
the protocols we will use $\sigma$ to denote setup information such as
description of the field $\FF$, group $\GG$, codes $L_1,L_2$ etc. From Figure
\ref{fig:protocol1}, we have:
\begin{align}
\View^{\rm M2D}_{\verifier}(\sigma,\bm{c};\bar{U}) &\equiv
	\big\{\tau,\delta,\underline{\bar{U}\mu},\View^{IP}_{\verifier}(\sigma,\cdots;\bar{U}\mu)\big\}
\end{align}
In the above we have $\mu=\mc{T}\tau$, while $\ldots$ denote the entries which are
computed in terms of other entries in the view. For the protocol
$\proximityThreeD$ we have (see Figure \ref{fig:prox3d}).
\begin{align}
\View^{\rm P3D}_{\verifier}(\sigma,[\pi];\ewit)& \equiv
\big\{r,\tilde{\bm{c}}=(\tilde{c}_1,\ldots,\tilde{c}_{\ell}),Q,\{\pi[\cdot,k]\}_{k\in
Q}, \nonumber \\
	&\quad \View^{\rm M2D}_{\verifier}(\sigma,\bm{\tilde{c}};\tilde{U})\big\}
\nonumber \\
	&\equiv
\big\{r,\bm{\tilde{c}},\tau,\delta,Q,\{\pi[\cdot,k]\}_{k\in Q},\underline{\tilde{U}\mu},\View^{IP}_{\verifier}(\sigma,\cdots)\big\}
\end{align}
In the above $\tilde{U}=\sum_{i\in [p]}r_i\ewit[i,\cdot,\cdot]$ and
$\mu=\mc{T}\tau$. Now we assemble the extended view for the linear check
protocol from its messages, and those of constituent subprotocols:

\begin{align}
\View^{\rm LC3D}_{\verifier}(\sigma,A,b;\wit)&\equiv \nonumber \\
&\big\{r,c_1,\ldots,c_{2\ell},\{j_u,k_u\}_{u\in [t]},
\underline{\{\ewit[\cdot,\cdot,k_u]\}_{u\in [t]}},\{\pi[\cdot,k_u]\}_{u\in [t]},
\nonumber \\
& \{\tau, \delta, \mu=\mc{T}\tau, \underline{\bar{P}\mu}, \View^{\rm
IP}(\sigma,\cdots)\}, \nonumber \\
& \{\underline{\bar{P}\varphi}, \View^{\rm IP}(\sigma,\cdots)\}, \nonumber \\
& \{r',\tilde{\bm{c}},\tau',\delta',\mu':=\mc{T}\tau',\underline{\tilde{U}\mu'},
	\View^{\rm IP}(\sigma,\cdots)\}\big\}
\end{align}


	


We use indentation to denote subprotocol components of
the view.
\begin{itemize}
\item $\View^{\rm LC3D}_{\verifier}(\FF,\GG,A,b) \equiv$
\begin{enumerate}[{\rm 1.}]
\item $r_1\in \FF^N$ (step 1).
\item $(c_1,\ldots,c_{2\ell})\in \GG^{2\ell}$ in step 4.
\item $Q=\{(j_u,k_u):u\in [t]\}$ in step 5.
\item Instead of $\{\ewit[\cdot,j_u,k_u]\}_{u\in [t]}$, we consider extended
view $\{\ewit[\cdot,\cdot,k_u]: u\in [t]\}$ in step 6.
\item $\{\pi[\cdot,k_u]:u\in [t]\}$ as part of oracle response in step 8.
\item $\View^{\rm Mem2D}_{\verifier}(c_1,\ldots,c_{2\ell})\equiv$
	\begin{enumerate}[{\rm 1.}]
	\item $\tau_1,\delta_1$ where $\tau\in \FF^n$ and $\delta\in \FF^{h-m}$.
	\item $z_1=\bar{P}\mu$ for $\mu_1=\mc{H}_2\delta_1$. Note that $z_1$ is not part
of the verifier's view, but we consider it as part of extended view.
	\item $\View^{\rm ip}_{\verifier}(\FF,\GG,x_1,\mathsf{cm}_1,0;z_1)$ where
$\mathsf{cm}_1$ can be computed from other variables in the view.
	\end{enumerate}
\item $\View^{\rm ip}_{\verifier}(\FF,\GG,x_2,\mathsf{cm}_2,v_2;\bar{P}\varphi)$,
$z_2=\bar{P}\varphi$ in step 11. We consider $z_2=\bar{P}\varphi$ as part of extended view, as
it is not part of verifier's view.
\item $\{\View^{\rm ip}(\FF,\GG,x_3,\mathsf{cm}_3,v_3;P[\cdot,k_u]\}_{u\in
[t]}$ in step 13. We note that the witnesses $P[\cdot,k_u]$ can be computed from
$r_1$ and
$\ewit[\cdot,\cdot,k_u]$.
\item $\{\View^{\rm
aggip}_{\verifier}(\FF,\GG,x_4,\pi[\cdot,k_u],\ewit[\cdot,j_u,k_u];\ewit[\cdot,\cdot,k_u])\}_{u\in
[t]}$.
\item $\View^{\rm prox3D}_{\verifier}(\FF,\GG,L_1,L_2,e,[\pi];\ewit)\equiv$
	\begin{enumerate}[{\rm 1.}]
	\item We consider $Q_2 = \{k_u:u\in [t]\}$ as we multiplex the oracle
access between the main protocol and subprotocols.
	\item $\tilde{\bm{c}} = (\tilde{c}_1,\ldots,\tilde{c}_\ell)$.
	\end{enumerate}

\end{enumerate}
\end{itemize}



\subsection{Extension to DIZK}


\begin{figure}[h!]
\centering
\begin{framed}
\begin{itemize}
\item $\quadcheck(\FF,\GG,L_1,L_2,[\pi];\wit_x,\wit_y,\wit_z)$:
\item {\bf Relation}: $\exists (\wit_x,\wit_y,\wit_z,\ewit_x,\ewit_y,\ewit_z)$
s.t. $(\ewit_x,\ewit_y,\ewit_z)=\open(\pi)$, $\ewit_{a}=\enc(\wit_a)$ for $a\in
\{x,y,z\}$ and $\wit_x\circ \wit_y = \wit_z$.
\item {\bf Oracle Setup}: The prover $\prover$ computes $\ewit_a=\enc(\wit_a)$
and $\comoracle_a=\comm(\ewit_a)$ for $a\in \{x,y,z\}$. It sets $\pi :=
[\comoracle_x||\comoracle_y||\comoracle_z]$ where the notation denotes vertical
stacking of the matrices. 
\begin{enumerate}[{\rm 1.}]
\item $\verifier\rightarrow\prover$: Verifier samples $r\sample\FF^p$ and sends
it to $\prover$.
\item $\prover$ computes:
	\begin{itemize}
	\item polynomials $p_j(\cdot):=\sum_{i\in
[p]}r_i\big(Q^i_x(\alpha_j,\cdot)Q^i_y(\alpha_j,\cdot)-Q^i_z(\alpha_j,\cdot)\big)$
for $j\in [h]$.
	\item $h\times n$ matrix $P$ such that $P[j,k]=p_j(\eta_k)$.
	\item commitments $c_1,\ldots,c_{2\ell}$ to the first $2\ell$ columns of
$P$.
	\end{itemize}
\item $\prover\rightarrow\verifier$: The prover sends $c_1,\ldots,c_{2\ell}$ to
the verifier.
\item $\verifier\rightarrow\prover$: $\verifier$ samples $(j_u,k_u)\sample
[h]\times [n]$ for $u\in [t]$. The verifier also samples $\tau\sample
\FF^{\ell}$. It sends $Q=\{(j_u,k_u):u\in [t]\}$ and $\tau$ to $\prover$.
\item $\prover\rightarrow\verifier$: The prover sends vectors
$X_u=\ewit_x[\cdot,j_u,k_u],Y_u=\ewit_y[\cdot,j_u,k_u],Z_u=\ewit_z[\cdot,j_u,k_u]$
to the verifier, for all $u\in [t]$.
\item Oracle Queries: $\verifier$ queries the oracle $\pi$ with $\{k_u: u\in
[t]\}$.
\item Oracle Response: The oracle responds with columns $\pi[\cdot,k_u]$ for
$u\in [t]$.
\item $\prover\leftrightarrow\verifier$: Both $\prover$ and $\verifier$ compute
$\varphi := \Phi^T\tau$ and $\mathsf{cm}:= \sum_{k\in [2\ell]}\phi_kc_k$.
\item $\prover$ and $\verifier$ run the subprotocol:
	\begin{itemize}
	\item $b_{\rm
2d}=\proximityTwoD(\FF,\GG,\dashL_1,\dashL_2,\bm{c};\bar{P})$ where
$\bm{c}=(c_1,\ldots,c_{2\ell})$ and $\bar{P}$ is the submatrix of $P$ consisting
of the first $2\ell$ columns. Here $\dashL_1=\rsc{\eta}{2\ell}$ and
$\dashL_2=\rsc{\alpha}{2m}$.
	\end{itemize}
\item $\prover$ and $\verifier$ run the subprotocol:
	\begin{itemize}
	\item $b=\innerproduct(\FF,\GG,\bm{g},x,\mathsf{cm},v;z)$
with $x=(\gamma,0^{h-m})$, $v=0$ and $z=\bar{P}\varphi$.
	\end{itemize}
\item $\prover$ and $\verifier$ compute: For all $u\in [t]$ $c_{k_u} =
\sum_{a\in 2\ell}T[a,k_u]c_a$, where $T$ is the matrix such that $P=\bar{P}T$.
\item $\prover$ and $\verifier$ run inner product subprotocols for each $u\in
[t]$:
	\begin{itemize}
	\item $s_u=\innerproduct(\GG,\bm{g},x,c_{k_u},v;P[\cdot,k_u])$ with
$x=e_{j_u}$, $v=\sum_{i\in [p]}r_i(X_u[i]\cdot Y_u[i] - Z_u[i])$.
	\end{itemize}
\item $\prover$ and $\verifier$ run aggregate inner product protocols for each
$u\in [t]$:
	\begin{itemize}
	\item
$a_{1u}=\agginnerproduct(\GG,\bm{g},e_{j_u},\pi_x[\cdot,k_u],X_u;\ewit_x[\cdot,\cdot,k_u])$
	\item
$a_{2u}=\agginnerproduct(\GG,\bm{g},e_{j_u},\pi_y[\cdot,k_u],Y_u;\ewit_y[\cdot,\cdot,k_u])$
	\item
$a_{3u}=\agginnerproduct(\GG,\bm{g},e_{j_u},\pi_z[\cdot,k_u],Z_u;\ewit_z[\cdot,\cdot,k_u])$
	\end{itemize}
\item $\prover$ and $\verifier$ run the subprotocol: 
	\begin{itemize}
	\item $b_{\rm prox} =
\proximityThreeD(\FF,L_1,L_2,e,[\pi];[\ewit_x||\ewit_y||\ewit_z])$
	\end{itemize}
\item The verifier accepts if all the subprotocols accept.
\end{enumerate}
\end{itemize}
\end{framed}
\caption{Quadratic Check Protocol}
\label{fig:quadcheck}
\end{figure}



%\end{enumerate}
   



\subsection{Non-interactive}
IOP to NIROP
