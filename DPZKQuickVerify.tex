%\newcommand{\enc}{\mathsf{Enc}}
\section{DPZKQuickVerify} \label{sec:quickverify}
While the construction of the previous section leads to smaller argument size,
it comes with a considerable degradation to prover and verifier efficiency, as
both the prover and the verifier incur $O(N^{1-1/c})$ exponentiations. Note
that while the prover needs to compute $O(N)$ exponentiations while computing
commitment $\comoracle$, one can use multi-exponentiations to compute the same
using $O(N/\log{N})$ exponentiations which can be significant speed-up in
practice. In this section we additionally leverage homomorphic commitments
(introduced to facilitate distributed proof generation) to obtain a better
trade-off between the argument size and the number of exponentiations computed
by the prover and the verifier. Essentially, we obtain the same argument size
of $N^{1/c}$ for $c\geq 2$ while restricting the inner product arguments to
vectors of size at most $O(N^{1-2/c})$. For practically relevant lower values
of $c$, the gains in efficiency are substantial.
   
We start by arranging the witness vector $x\in \FF^N$ as a $3$-dimensional
array. Let $p,m$ and $\ell$ be integers such that $N=pm\ell$. We view $x$ as
$p$ matrices, each of size $m\times \ell$, i.e, we write $x = (x_1|\cdots|x_p)$
where $x_i\in \FF^{m\times \ell}$ for all $i\in [p]$. We will use the notation
$x[i,j,k]$ to denote the entry $x_i[j,k]$. To obtain encoding of
$x$, we use product code of two Reed Solomon codes to encode each matrix $x_i$,
$i\in [p]$ as a codeword in the product code. The use of the product code is
essential to ensure soundness of the protocol with constant number of queries.
We now describe the encoding in more detail.

\subsection{Witness encoding with RS product code}
We first choose the following sets of distinct points in $\FF$:
\begin{align}\label{eq:points}
\bm{\zeta} =\{\zeta_1,\ldots,\zeta_{\ell}\},\quad 
\bm{\eta}  = \{\eta_1,\ldots,\eta_n \},\quad
\bm{\alpha} = \{\alpha_1,\ldots,\alpha_{2m}\}. 
\end{align}

Next, we define interpolation domain $G$ as $G=\{(\alpha_j,\zeta_k): j\in[m],
k\in [\ell]\}$ and evaluation domain $H$ as $H=\{(\alpha_j,\eta_k): j\in [2m],
k\in [n]\}$. We encode an $m\times \ell$ matrix $a$ by interpolating a
bivariate polynomial $Q^a(x,y)$ with $\deg_x(Q)<m$ and $\deg_y(Q)<\ell$
satisfying $Q^a(\alpha_j,\zeta_k)=a[j,k]$ for $j\in [m],k\in [\ell]$. We define
the encoding $\enc(a)$ of $a$ as the $2m\times n$ matrix $b$ consisting of
evaluations of $Q^a$ on $H$, i.e, $b[j,k]=Q^a(\alpha_j,\eta_k)$ for $j\in
[2m],k\in [n]$. It can be seen that $\enc(a)$ is a codeword in the product code
$\rsc{\eta}{\ell}\oplus \rsc{\alpha}{m}$.  
 
 
We describe how to use homomorphic commitment of RS-encoded oracle to reduce
argument size and verifier's complexity. Let $x\in \FF^N$ be the witness
vector. Let $p,m,\ell$ be positive integers such that $pm\ell > N$. We choose the interpolation domain $G\subseteq \FF\times \FF$ as
$G=\{(\alpha_j,\zeta_k): j\in [m], k\in [\ell]\}$ for distinct points
$\zeta_1,\ldots,\zeta_\ell$ and $\alpha_1,\ldots,\alpha_m$ in $\FF$. Define $n_1=\sigma_1\ell$ and
$n_2=\sigma_2 m$ where $\sigma_1,\sigma_2 > 1$ are constants. We now define the
evaluation domain $H=\{(\beta_j,\eta_k): j\in [n_2],k\in
[n_1]\}$ where %$\beta$'s and $\eta$'s are distinct among themselves and from%
where $\beta$ should be chosen in such a way that $\beta_j=\alpha_j \forall j\in[m]$ and $\eta$'s are distinct among themselves and from
coordinates in $G$.\smallskip
\pnote{$\alpha$ and $\beta$ should be same and should we mention that $\zeta$ and $\eta$ should be chosen in such a way that FFT can be done.}
\noindent{\em RS Encoding with bivariate polynomials}:
We first write the witness $x=(x_1|\cdots|x_p)$ where each $x_i\in
\FF^{m\ell}$.
For each $i\in [p]$ we construct bivariate polynomial $Q^i(.,.)$ which
interpolates the matrix $x_i$ on $G$, i.e, $Q^i(\alpha_j,\zeta_k)=x_i[j,k]$.
Let $\mc{U}^i\subseteq \FF^{n_1n_2}$ denote the matrix of evaluations of $Q^i$
on $H$, i.e, $\mc{U}^i[j,k]=Q^i(\beta_j,\eta_k)$ for $j\in [n_1]$, $k\in
[n_2]$. Finally we define $\rsoracle=(\mc{U}^1|\cdots|\mc{U}^p)$. Note that
$\rsoracle[i,j,k]=Q^i(\beta_j,\eta_k)$ for all $i$, $j$ and $k$.\smallskip

\noindent{\em Commitment Oracle}: We commit the oracle $\rsoracle$ using
homomorphic vector commitment scheme which allows us to effectively provide
access to ``derived'' oracles, such as those obtained by suitable linear
operations on the oracle. Assume $\FF$ is a prime field and $\comm$ is a
commitment scheme over $\FF^{n_2}$ with randomness space $\FF$ and commitment
space a group $\GG$ with independent generators $g_1,\ldots,g_{n_2}$ and $h$.
For $i\in [p], k\in [n_1]$ define $c_{ik}=\comm(\rsoracle[i,.,k],\delta_{ik})$,
where $X[i,.,k]$ denotes the $n_2$-length vector $(X[i,1,k],\ldots,X[i,n_2,k])$
and $\delta_{ik}$ denotes the commitment randomness. We define oracle
$\comoracle$ as $\comoracle[i,k]=c_{ik}$ for $i\in [p],k\in [n_1]$.
\pnote{ambiguity in $n_1, n_2, l$ and $m$. We aren't we committing along $m$ i.e. $n_2$ direction? then $(\beta_j, \eta_k)$ such that $j\in[n_1], k\in[n_2]$ }
\subsubsection{Bivariate Interleaved Code(BIC)}
Let $Q(x,y)\in \FF[x,y]$ be a bivariate polynomial with $deg_x(Q) < m$ and
$\deg_y(Q) < \ell$. Then the evaluations of $Q$ on $H$ form an $n_2\times n_1$
matrix whose rows are codewords in a Reed-Solomon code, which we call $L_1$ and columns
are codewords in a Reed-Solomon code which we call $L_2$. In other words, the
evaluations of $Q$ on $H$ forms a codeword in the interleaved codes $L_1^{n_2}$
and $L_2^{n_1}$. Let $\Delta_1$ and $\Delta_2$ denote the distance function on
the codes $L_1^{n_2}$ and $L_2^{n_1}$ respectively, and let $d_1$ and $d_2$
denote the minimum distances for the codes $L_1^{n_2}$ and $L_2^{n_1}$
respectively. We have the following:
\begin{lemma}\label{lem:bicdecoding}
Let $U^\ast\in \FF^{n_2\times n_1}$ be such that $\Delta_1(U^\ast,L_1^{n_2})<e$
and $\Delta_2(U^\ast,L_2^{n_1})<e$ for $e < \min(d_1,d_2)/2$. Then there exists
(unique) 
$U\in L_1^{n_2}\cap L_2^{n_1}$ such that $\Delta_1(U^\ast,U)<e$ and
$\Delta_2(U^\ast,U)<e$.
\end{lemma}
\begin{proof}
Let $U_1\in L_1^{n_2}$, $U_2\in L_2^{n_1}$ be such that
$\Delta_1(U^\ast,U_1)<e$ and $\Delta_2(U^\ast,U_2)<e$. We show that $U_1=U_2$
to prove the lemma. Let $J_1,J_2$ and $J_3$ form a partition of the set $[n_2]$
where $J_1$ contains row indices where $U^\ast$ and $U_2$ differ, and $J_2,J_3$
form a partition of $[n_2]\backslash J_1$ with $|J_2|=m$. Similarly let
$K_1,K_2,K_3$ be subsets of $[n_1]$, where $K_1$ contains column indices where
$U^\ast$ and $U_1$ differ, and $K_2,K_3$ for a partition of $[n_1]\backslash
K_1$ with $|K_2|=\ell$. Let $Q\in \FF[x,y]$ be the unique polynomial with
$deg_x(Q)<m$ and $deg_y(Q)<\ell$ such that for all $(j,k)\in J_2\times K_2$,
$Q(\beta_j,\eta_k)=U[j,k]=U_1[j,k]=U_2[j,k]$. Define $U^Q$ by
$U^Q[j,k]=Q(\beta_j,\eta_k)$ for $j\in [n_2]$ and $i\in [n_1]$. We note the
following:
\begin{enumerate}[{\rm 1.}]
\item $U_1,U_2,U^\ast$ are identical on $(j,k)\in (J_2\cup J_3)\times (K_2\cup
K_3)$. Further $U^Q$ is identical with the other three on $(J_2\times K_2)$.
\item Now consider $U_2$ and $U^Q$. Since both the matrices have columns as
codewords in $L_2$, and the columns corresponding to indices in $K_2$ are
identical on positions in $J_2$, by the distance property of the Reed-Solomon
code $L_1$, entire columns with indices in $K_2$ are identical in $U_2$ and
$U^Q$, i.e, $U_2[.,k]=U^Q[.,k]$ for $k\in K_2$.
\item Since $U_2$ and $U^\ast$ are identical on all rows with indices in
$J_2\cup J_3$, from the above we conclude $U^\ast[j,k]=U^Q[j,k]$ for $(j,k)\in
(J_2\cup J_3)\times K_2$.
\item Now we observe that $U^\ast$ and $U_1$ are identical on $(J_2\cup
J_3)\times K_2$, and thus from the above, $U^Q[j,k]=U_1[j,k]$ for $(j,k)\in
(J_2\cup J_3)\times K_2$.
\item Finally, we notice that rows in $U_1$ and $U^Q$ are codewords in $L_1$,
and the rows corresponding to indices in $J_2\cup J_3$ are identical on
positions in $K_2$. Again, using the distance property of Reed-Solomon codes we
conclude $U_1$ and $U^Q$ have identical rows for indices in $J_2\cup J_3$. 
\item The above implies $\Delta_2(U^Q,U_1)\leq e < d_2$ and hence $U^Q=U_1$.
Similarly we can show $U^Q=U_2$. Thus $U^Q$ satisfies $\Delta_1(U^\ast,U^Q)<e$
and $\Delta_2(U^\ast,U^Q)<e$. Further since $e < \min(d_1,d_2)/2$, we see that
$U^Q$ is unique such codeword. This completes the proof.
\end{enumerate}
\end{proof}

For a $U^\ast\in \FF^{n_2\times n_1}$ such that
$\max(\Delta_1(U^\ast,L_1^{n_2}),\Delta_2(U^\ast,L_2^{n_1}))<e$ where $e <
\min(d_1,d_2)/2$, we define $\decode(U^\ast)$ to be the unique codeword in
$L_1^{n_2}\cap L_2^{n_1}$ satisfying the property in the Lemma
\ref{lem:bicdecoding}. 

\subsubsection{Proximity Protocol for BIC}\label{sec:proximitybic}
We describe a protocol for ``proximity'' of a purported codeword to bivariate
interleaved code. Let $U\in \FF^{n_2\times n_1}$ denote the purported codeword and let
$e<\min(d_1,d_2)/3$ denote the proximity parameter. In its first message the
prover computes commitments $c_1,\ldots,c_{n_1}$ to the columns of $U$ and
sends it to verifier. Thereafter the prover and the verifier interact as
follows:
\begin{enumerate}[{\rm 1.}]
\item $\prover\rightarrow \verifier$: Commitments $c_1,\ldots,c_{n_1}$ to the
columns of $U$.
\item $\verifier\rightarrow \prover$: Verifier samples $\gamma\sample
\FF^{n_2}$ and $\tau\sample \FF^{n_1}$ and sends to the prover.
\item $\prover\rightarrow \verifier$: The prover computes $w_1=\gamma^TU$ and
$w_2=U\tau$. It computes commitment $\mathsf{cm}_1$ to the
vector $w_1$ and sends it to the verifier (the commitment to $w_2$ can be computed by the
verifier). 
\item $\verifier\rightarrow \prover$: Verifier samples subset $Q_1\subseteq
[n_1]$ of size $t$ and sends it to the prover.
\item $\prover\rightarrow\verifier$: The prover sends $w_1[k]$ for $k\in Q_1$.
\item The prover and the verifier run the subprotocols to check:
  \begin{itemize}
  \item $w_1\in L_1$ and $w_1=\gamma^TU$.
  \item $w_2\in L_2$ and $w_2=U\tau$.
  \end{itemize}
\end{enumerate}
We now describe the subprotocols used in the above protocol.
Let $H_1\in \FF^{n_1\times (n_1-\ell)}$ and $H_2\in \FF^{n_2\times (n_2-m)}$
denote the parity check matrices for the codes $L_1$ and $L_2$
respectively. For the first subprotocol, given the vector commitments
$c_1,\ldots,c_{n_1}$ to the columns of $U$ and commitment $\mathsf{cm}_1$ for
the vector $w_1$ (note that the vector is only revealed on positions in $Q_1$), the verifier checks the following inner products:
\begin{itemize}
\item $\innp{\gamma}{U[.,k]}=w_1[k]=\innp{w_1}{e_k}$ for all $k\in Q_1$.
\item $\innp{w_1}{H_1[k]}=0$ for all $k\in [n_1-\ell]$.
\end{itemize}
The first set of inner products, probabilistically check the relation
$\gamma^TU=w_1$ by checking it only on the index set $Q_1$. As we shall see,
this is sufficient to verify the desired relation with high probability. The
second check verifies membership of the $w_1$ in $L_1$ by checking
$w_1^TH_1=\bm{0}$. The former check reduces with high probability to inner
product checks (i) $\innp{\gamma}{\sum_k
\delta_kU[.,k]}=\innp{\delta}{w_1|_{Q_1}}$ and
$\innp{w_1}{\sum_k\delta_ke_k}=\innp{\delta}{w_1|_{Q_1}}$ for a randomly
$\delta\sample \FF^t$. Note that
commitments to all the vectors required in above inner products are available
to the verifier. The check $\innp{w_1}{H_1[k]}=0$ for $k\in [n_1-\ell]$
similarly reduces to a single inner product check $\innp{w_1}{H_1s}=0$ for a
random $s\sample \FF^{n_1-\ell}$. 

Next we check $w_2\in L_2$ and $w_2=U\tau$. The verifier homomorphically
computes commitment $\mathsf{cm}_2$ to $U\tau$ and uses this as the commitment
for $w_2$ in the inner product protocols to enforce $w_2=U\tau$ (with high
probability). The check $w_2\in L_2$ is done as in the previous case, since we
know the commitment to $w_2$.

\begin{lemma}\label{lem:soundbic}
For any prover $P^\ast$ that succeeds in the above protocol, there exists
extractor $\mc{E}$ with rewinding access to $P^\ast$ which extracts an
$e$-close oracle $U$ with overwhelming probability.
\end{lemma}
\begin{proof}
For any $\ppt$ adversary $\adv$, let $\advantage{com}{\adv,\comm}$,
$\advantage{ip}{\adv,{\rm ip}}$ denote $\adv$'s advantage against the
binding property of the commitment scheme $\comm$ and the soundness of the
inner product protocol respectively. Let
$c_1,\ldots,c_{n_1},\mathsf{cm},w_1|_{Q_1}$ be the prover's messages
$\gamma,\tau,\delta,s,Q_1$ be verifier's challenges in an accepting transcript.
Then running the ``extractor'' $\mc{E}$ for the inner product protocols (with
rewinding oracle access to $P^\ast$), the adversary $\adv$ extracts witnesses
$w'_1,w''_1,w'_2$ and $u,u_1,\ldots,u_{n_1}$ such that:

\begin{itemize}
\item $\innp{w'_1}{\sum_k\delta_ke_k}=\innp{\delta}{w_1|_{Q_1}}$ and
$\comm(w'_1)=\mathsf{cm}_1$.
\item $\innp{w''_1}{H_1s}=0$ and $\comm(w''_1)=\mathsf{cm}_1$.
\item $\innp{\gamma}{u}=\innp{\delta}{w_1|_{Q_1}}$ and $\comm(u)=\sum_{k\in
Q_1}\delta_kc_k$ (using additive notation for commitments).
\item $\comm(u_k)=c_k$ for $k\in [n_1]$. We assume the extractability of
columns $u_k$'s corresponding to commitments $c_k$'s because by rewinding
sufficient times the extractor can extract openings for different linear
combinations of $u_k$'s, and use those to extract individual openings.
\item $w^{'T}_2H_2 = \bm{0}$ and $\comm(w'_2)=\sum_{k\in n_1}\tau_kc_k$.
\end{itemize}
In the event that the adversary $\adv$ does not break the binding property of
the commitment scheme or the soundness of the inner product protocols, we must
have $w'_1=w''_1=w$(say), $u=\sum_{k\in Q_1} \delta_ku_k$. Now with very high
probability (because challenges $\delta,\gamma,s$ were random) we must have:
$w\in L_1$, $w|_{Q_1}=w_1|_{Q_1}$ and $\innp{\gamma}{u_k}=w_1[k]=w[k]$ for all
$k\in Q_1$. Similarly $w_2=\sum_{k\in [n_1]}\tau_ku_k$ and $w_2\in L_2$. From
Lemma \ref{lem:proximitytest}, with overwhelming probability the oracle
$U=[u_1,\ldots,u_{n_1}]$ is $e$-close to both the interleaved codes.  
\end{proof}

\subsubsection{Linear Check}
We now describe a protocol to check that a purported commitment oracle
$\comoracle$ encodes witness $x$ satisfying the constraint $Ax=0$ for a public
matrix $A$. As before we assume $x\in \FF^N$ and $A\in \FF^{N\times N}$ and
$N=pm\ell$ for some positive integers $p,m$ and $\ell$. We further assume that
the prover has RS-encoded oracle $\rsoracle$ which opens to the commitment
$\comoracle$ and is $e$-close to the interleaved codes $L_1^{pm}$ and
$L_2^{pn_1}$. The prover and the verifier interact as follows:
\begin{enumerate}[{\rm 1.}]
\item $\verifier\rightarrow\prover$: The verifier sends a random $r\sample
\FF^N$ and random $\tau\sample \FF^{n_1}$ to the prover.
\item $\prover\rightarrow\verifier$: The prover computes as follows:
\begin{itemize}
\item interpolates bivariate polynomials $R^i:i\in [p]$ such that the polynomial $R^i$ interpolates the
vector $(r_{(i-1)mn+1},\ldots,r_{imn})$ for $i\in [p]$. 
\item computes polynomials $p_j(.)=\sum_{i\in [p]}R^i(\alpha_j,.)Q^i(\alpha_j,.)$ for
$j\in [n_2]$. 
\item evaluates the polynomials $p_j$ on the set
$\bm{\eta}=\{\eta_1,\ldots,\eta_{n_1}\}$. Let $P$ denote the $n_2\times n_1$
matrix whose $j^{th}$ row is the evaluation of the polynomial $p_j$ on the set
$\eta$. 
\item computes commitments $d_1,\ldots,d_{2\ell}$ to the first
$2\ell$ columns of $P$.
\end{itemize}
\begin{equation}
P := \begin{bmatrix}
p_1(\eta_1) & \cdots & p_1(\eta_{2\ell}) & \vline & \cdots &
p_1(\eta_{n_1}) \\
\vdots & \ddots & \vdots & \vline & \ddots & \vdots \\
p_{n_2}(\eta_1) & \cdots & p_{n_2}(\eta_{2\ell}) & \vline & \cdots &
p_{n_2}(\eta_{n_1})
\end{bmatrix}
\end{equation}
Note that there exists a $2\ell\times n_1$ matrix $T$ such that $P'T = P$ where $P'$ denotes
the submatrix of $P$ consisting of first $2\ell$ columns. Thus the commitments
to other columns of $P$ can be computed from $d_1,\ldots,d_{2\ell}$ using
homomorphism.
The prover sends the commitments $d_1,\ldots,d_{2\ell}$ and the polynomial
$p(x)=\sum_{j\in[m]} p_j(x)$ to the verifier.
\item $\verifier\rightarrow\prover$: The verifier samples $t$ distinct indices
$k_1,\ldots,k_t$ from the set $[n_1]$. It also picks $t$ indices
$j_1,\ldots,j_t$ from the set $[n_2]$ independently at random. Finally the
verifier sends the pairs $\{(j_u,k_u):u\in [t]\}$ to the prover.
\item $\prover\rightarrow\verifier$: The prover sends $t$ ``tubes''
$\rsoracle[.,j_u,k_u]$ for $u\in [t]$ to the verifier. Recall that
$\rsoracle[.,j_u,k_u]$ denotes the $p$-length vector
$(\rsoracle[1,j_u,k_u],\ldots,\rsoracle[p,j_u,k_u])$. The prover also sends the
columns $\comoracle[.,k_u]$ for $u\in [t]$ of the oracle $\comoracle$. 
\item The verifier proceeds as:
\begin{itemize}
\item It checks $\sum_{k\in [\ell]}p(\zeta_k)=0$.
\item It runs a proximity protocol to check that $P$ is $e$-close to
a bivariate interleaved code corresponding to Reed-Solomon codes of degrees
$2\ell$ and $2m$ respectively.
\item Checks that $p=\sum_{j\in n_2}p_j$.
\item It checks $P[j,k]=\sum_{i\in [p]}R^i(\beta_j,\eta_k)\rsoracle[i,j,k]$ for
$(j,k)\in \{(j_u,k_u):u\in [t]\}$.
\item It checks consistency of the openings $\rsoracle[.,j_u,k_u]$ with
commitment oracle $\comoracle$ for $u\in [t]$. 
\end{itemize}
\item The verifier accepts if all the above checks succeed.
\end{enumerate}
We now describe in detail each of verifier's checks in the final step of the
above interaction.\smallskip

\noindent{\em Checking proximity of matrix $P$}: Note that an honestly computed
matrix $P$ in the above protocol forms a bivariate interleaved codewords where
the rows correspond to evaluation of polynomials of degree $<2\ell$ and columns
correspond to evaulations of polynomials of degree $<2m$. Using matrix $T$ the
verifier can homomorphically compute the commitments to the columns of
purported matrix $P$ and then check proximity using the proximity protocol
described in Section \ref{sec:proximitybic}. Here we describe an optimized
version where the verifier need not compute all the column commitments of $P$. 
We consider the protocol of Section \ref{sec:proximitybic}, where the prover
sends commitments $d_1,\ldots,d_{2\ell}$ in its first message (instead of $n_1$
commitments). The prover and verifer proceed exactly as the proximity protocol.
In testing the proximity to the interleaved code along rows, the verifier needs
to compute the commitment to the vector $\sum_{k\in Q_1}\delta_kU[.,k]$. The
verifier computes the commitment as $\sum\lambda_kd_k$ where
$(\lambda_1,\ldots,\lambda_t)^T = T|_{Q_1}\delta$. Similarly for computing
commitment for the vector $w_2=P\tau$, for random $\tau\sample \FF^{n_1}$, the
verifier computes the commitment to $w_2$ as $\sum_{k\in
[2\ell]}\gamma_kd_k$ where $(\gamma_1,\ldots,\gamma_{2\ell})^T=T\tau$. Note
that naively computing commitments to all the columns would have required
$O(\ell m)$ cryptographic operations, while in the current scheme we only need
$O(m)$ cryptographic operations.\smallskip

\noindent{\em Checking consistency of $p$ with $P$}: To check that $p=\sum_{j\in
n_2}p_j$, the verifier evaluates $p$ on $\eta_1,\ldots,\eta_{2\ell}$ to obtain the
evaluation vector $\bar{p}$. The verifier now needs to verify
$\bar{p}=\bm{1}^TP'$ where $P'$ denotes the submatrix consisting of the first
$2\ell$ columns of $P$, which probabilistically reduces to inner product check
$\innp{\bm{1}}{P's}=\innp{\bar{p}}{s}$ for a randomly sampled $s\sample
\FF^{2\ell}$. For the inner product protocol, the verifier can homomorphically compute the commitment to the
vector $P's$ given $d_1,\ldots,d_{2\ell}$.\smallskip

\noindent{\em Checking consistency of $P$ with $\rsoracle$}: The checks
$P[j,k]=\sum_{i\in [p]} R^i(\beta_j,\eta_k)\rsoracle[i,j,k]$ probabilistically
verify the computation of $P$ from the $\rsoracle$ by probing a few locations
$(j_u,k_u)$ for $u\in [t]$. Since $P[j,k]=\innp{P[.,k]}{e_j}$, and the verifier
can compute commitment for $P[.,k]$ the required checks can be accomplished by
running $t$ instances of the inner product arguments.\smallskip


\noindent{\em Checking consistency of openings of $\rsoracle$ with
$\comoracle$}: Consider $(j,k)\in \{(j_u,k_u):u\in [t]\}$. To check the
consistency of the opened tube $\rsoracle[.,j,k]$, verifier checks
$\innp{\rsoracle[i,.,k]}{e_j}=\rsoracle[i,j,k]$ for all $i\in [p]$. This can be
checked probabilistically by randomly sampling $v\in \FF^p$ and checking
$\innp{\sum_{i\in [p]}v_i\rsoracle[i,.,k]}{e_j}=\innp{v}{\rsoracle[.,j,k]}$.
The commitment to the vector $\sum_{i\in [p]}v_i\rsoracle[i,.,k]$ can be
computed homomorphically as $\sum_{i\in [p]}v_i\comoracle[i,j]$. Similar
consistency check can be done for all $t$ tubes.

\begin{lemma}\label{lem:linchecksound}
Let $\rsoracle$ be an RS-encoded oracle where $U^\ast=\decode(\rsoracle)$ is
an encoding of $x$ s.t $Ax\neq 0$. Then any bounded prover $\pdv^\ast$ which
commits $\rsoracle$ as $\comoracle$ succeeds in the linear check protocol with
negligible proabability.
\end{lemma}
\begin{proof}
To simplify the proof, we assume that the prover $\pdv^\ast$ does not violate the
binding property of the commitment scheme $\comm$, i.e, it opens appropriate
homomorphic combinations of the committed vectors and does not break the
soundness of the inner product protocols. The verifier checks the
following in the linear check protocol:
\begin{enumerate}
\item Openings $\rsoracle[.,j,k]$ are consistent with $\comoracle$ for
$(j,k)\in \{(j_u,k_u):u\in [t]\}$.
\item The matrix $P$ satisfies $\Delta_1(P,L_1^{n_2})<e$ and
$\Delta_2(P,L_2^{n_1})<e$.
\item The matrix $P$ is correctly computed from the oracle $\rsoracle$ and
vector $r\in \FF^N$.
\item The polynomial $p$ is correctly computed from the matrix $P$.
\item The polynomial $p$ satisfies $\sum_{k\in \ell}p(\zeta_k)=0$.
\end{enumerate}
By assumption that prover does not know two openings to a commitment, the
openings $\rsoracle[.,j,k]$ in the first check are honest. Let $P^\ast$ denote
honestly computed matrix from $U^\ast$ and $p^\ast$ denote honestly computed
polynomial from $P^\ast$. Since $P$ satisfies the proximity checks, with
overwhelming probability Lemma \ref{lem:bicdecoding} implies that there exists bivariate codeword $\bar{P}$ such that
$\Delta_1(P,\bar{P})<e$ and $\Delta_2(P,\bar{P})<e$. We consider two cases,
viz, $\bar{P}=P^\ast$ and $\bar{P}\neq P^\ast$ and show that $\pdv^\ast$
succeeds with negligible probability in both the cases. 

First, assume that $\bar{P}=P^\ast$. Thus we have $\Delta_1(P,P^\ast)<e$. If
the polynomial $p$ sent by $\pdv^\ast$is the same as the polynomial $p^\ast$, we have $\sum_{k\in
[\ell]} p(\zeta_k) = \sum_{k\in [\ell]} p^\ast(\zeta_k)\neq 0$ as $U^\ast$
encodes $x$ such that $Ax\neq 0$. Thus $\pdv^\ast$ fails if $p=p^\ast$. Assume,
then that $p\neq p^\ast$. Let $K$ denote the column indices where $P$ and
$P^\ast$ agree. By assumption, $|K|>n_1-e$. For all $k\in K$ we have
$p(\eta_k)=p^\ast(\eta_k)$. Since the polynomials $p$ and $p^\ast$ are of
degree $<2\ell$, this is a contradiction when $n_1-e\geq 2\ell$. Thus an
adverserial prover $\pdv^\ast$ fails when $\bar{P}=P^\ast$.

Now consider the case when $\bar{P}\neq P^\ast$. Then, by the distance
properties of the codes $L_1^{n_2}$ and $L_2^{n_1}$ and Lemma
\ref{lem:bicdecoding}, we must have $\Delta_1(P,P^\ast)>n_1-e$ or
$\Delta_2(P,P^\ast)>n_2-e$. Without loss of generality, assume the
former. Let $E_u$ denote the event $\pdv^\ast$ succeding on query $(j_u,k_u)$
for $u\in [t]$. Since $P$ and $P^\ast$ differ in at least $n_1-e$ columns
and $P$ and $\bar{P}$ differ in at most $e$ columns, we conclude that $\bar{P}$
and $P^\ast$ differ in at least $n_1-2e$ columns. Let $X$ denote the indices of
the $n_1-2e$ columns where $P$ and $\bar{P}$ agree, while $P^\ast$ differs from
them. For $k_u\in X$,  $\pdv^\ast$ succeeds if
$$P[j_u,k_u]=\bar{P}[j_u,k_u]=P^\ast[j_u,k_u]=\sum_{i\in
[p]}R^i(\beta_{j_u},\eta_{k_u})\rsoracle[i,j_u,k_u].$$
Since the columns of $\bar{P}$ and $P^\ast$ are evaluations of polynomials of
degree $<2m$, the above succeeds with probability $2m/n_2$. Thus we have:
\begin{align*}
\prob{E_u}\leq \frac{2e}{n_1}+\frac{n_1-2e}{n_1}.\frac{2m}{n_2}
\end{align*}
The probability that the verifier succeeds on all queries is then:
\begin{align}
\prob{\bigwedge_{u\in [t]}E_u}\leq
\left(\frac{2e}{n_1}+\frac{n_1-2e}{n_1}.\frac{2m}{n_2}\right)^t.
\end{align}
The above probability is negligible in $\secpar$ for $t=O(\secpar)$. This completes the
proof of soundness of the linear check.
\end{proof}


\subsubsection{Quadratic Check}\label{sec:quadcheck}
We now describe the interactive oracle protocol for checking the relation
$x\circ y = z$ for vectors $x,y,z\in \FF^N$. Let $\rsoracle_x,\rsoracle_y$ and
$\rsoracle_z$ denote the encodings of vectors $x$, $y$ and $z$ respectively via
the bivariate code. Let $\comoracle_x,\comoracle_y$ and $\comoracle_z$ denote
the respecitve commitment oracles. The prover and the verifier interact as
follows:

\begin{enumerate}[{\rm 1.}]
\item $\verifier\rightarrow\prover$: The verifier sends a challenge $r\sample
\FF^p$ to the prover.
\item $\prover\rightarrow\verifier$: The prover computes as follows:
  \begin{itemize}
  \item For $j\in [n_2]$, $p_j(.)=\sum_{i\in [p]}
r_i(Q^i_x(\alpha_j,.).Q^i_y(\alpha_j,.)-Q^i_z(\alpha_j,.))$.
  \item Constructs $n_2\times n_1$ matrix $P$, where the $j^{th}$ row of $P$
consists of evaluations of the polynomial $p_j$ on the points
$\eta_1,\ldots,\eta_{n_1}$.
  \item Computes commitments $d_1,\ldots,d_{2\ell}$ to the first $2\ell$
columns of $P$.
  \end{itemize}
The prover sends the commitments $d_1,\ldots,d_{2\ell}$ to the verifier.

\item $\verifier\rightarrow\prover$: The verifier sends $\gamma\in \FF^m$ and
$t$ randomly sampled pairs $\{(j_u,k_u),u\in [t]\}$ from $[n_2]\times [n_1]$. 

\item $\prover\rightarrow\verifier$: The prover sends the polynomial
$p(.)=\sum_{j\in [m]}\gamma_j.p_j(.)$, the tubes $\rsoracle_a[.,j_u,k_u]$,
 the columns $\comoracle_a[.,k_u]$ for $a\in\{x,y,z\}$ and $u\in [t]$.

\item The verifier proceeds as:
  \begin{itemize}
  \item Checks that $p(\zeta_k)=0$ for all $k\in [l]$.
  \item Checks that $P$ is $e$-close to bivariate interleaved code with
corresponding Reed-Solomon codes of dimensions $2\ell$ and $2m$ respectively.
  \item Checks that $p=\sum_{j\in [m]}\gamma_jp_j$.
  \item Checks that $P[j,k]=\sum_{i\in
[p]}r_i(\rsoracle_x[i,j,k].\rsoracle_y[i,j,k]-\rsoracle_z[i,j,k]$ for $(j,k)\in
\{(j_u,k_u):u\in [t]\}$.
  \item Checks the consistency of openings $\rsoracle_a[i,j_u,k_u]$ for $a\in
\{x,y,z\}$ and $u\in [t]$ with the commitment oracles $\comoracle_a$.
  \end{itemize}
The verifier accepts if all the checks succeed.

\end{enumerate}


\begin{lemma}\label{lem:quadhecksound}
Let $\rsoracle = [\rsoracle_x,\rsoracle_y,\rsoracle_z]$ be an RS-encoded oracle where $U^\ast=\decode(\rsoracle)$ is
an encoding of $[x,y,z]$ s.t $x\circ y\neq z$. Then any bounded prover $\pdv^\ast$ which
commits $\rsoracle$ as $\comoracle$ succeeds in the quadratic check protocol with
negligible proabability.
\end{lemma}


\subsection{Non-interactive}
IOP to NIROP
