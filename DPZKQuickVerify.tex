%\newcommand{\enc}{\mathsf{Enc}}
\subsection{Witness Encoding}\label{sec:witencoding}
We start by describing a randomized encoding of the prover witness $\wit\in \FF^N$. Let $p,m$ and
$s$ be integers such that $N=pms$. We canonically view the
witness $\wit$ 
as $p\times m\times s$ matrix with entries $\wit[i,j,k]$ for $i\in [p]$,
$j\in [m]$ and $k\in [s]$. The encoding is specified by an independence 
parameter $\bi$, integers $\ell := s+\bi$, $h>2m$, $n>2\ell$, and sequences
$\bm{\zeta},\bm{\eta},\bm{\alpha}$ of distinct points in $\FF$ with cardinality 
$\ell,n,h$ respectively. We write $\bm{\zeta}=(\zeta_1,\ldots,\zeta_\ell)$,
$\bm{\eta}=(\eta_1,\ldots,\eta_n)$ and $\bm{\alpha}=(\alpha_1,\ldots,\alpha_h)$. 
Next we define the interpolation domain $G$ as $G=\{(\alpha_j,\zeta_k): j\in[m],
k\in [\ell]\}$ and evaluation domain $H$ as $H=\{(\alpha_j,\eta_k): j\in [h],
k\in [n]\}$. Finally, we encode $\wit$ as follows:
\begin{enumerate}[{\rm (i)}]
\item First we embed $\wit$ into a $p\times m\times \ell$ matrix $\hat{\wit}$
where $\hat{\wit}[i,j,k]=\wit[i,j,k]$ for $k\leq s$, while the entries
$\hat{\wit}[i,j,k]$ for $k>s$ are sampled from $\FF$ uniformly at random.
\item We construct bivariate polynomials $Q^i(x,y)$ with $deg_x(Q)<m$ and
$deg_y(Q) $ $<\ell$ such that $Q^i$ interpolates the slice
$\hat{\wit}[i,\cdot,\cdot]$ on $G$, i.e,
$Q^i(\alpha_j,\zeta_k)=\hat{\wit}[i,j,k]$. 
\item Let $\ewit$ denote the $p\times h\times n$ matrix, where the slice
$\ewit[i,\cdot,\cdot]$ consists of evaluations of $Q^i$ on $H$, i.e,
$\ewit[i,j,k]=Q^i(\alpha_j,\eta_k)$ for $i\in [p], j\in [h]$ and $k\in [n]$.
Then $\ewit$ is a randomized encoding of $\wit$.
\end{enumerate}
We denote the above computation as $\ewit\sample \enc(\wit)$, where $\enc(\wit)$
denotes the random variable denoting the encodings of $\wit$. It is easily seen
that $\ewit[i,\cdot,\cdot]\in \rsc{\eta}{n,\ell}\otimes \rsc{\alpha}{h,m}$. We remark that the above
encoding can be computed using $O(N\log N)$ field operations (see Appendix for
details).
%%  Computing the encoding in O(Nlog N) time: Move to Appendix
%\noindent{\em Efficiently computing the encoding}: Although the previous
%description of the encoding involves the bivariate polynomials, 
%the prover does not explicitly need to compute the bivariate polynomials to
%construct the encoding. We describe an efficient method to construct the
%encoding. Given an $m\times \ell$
%matrix $\matx$, the prover first computes polynomials $p_j$ for $j\in
%[m]$ as $p_j(y) := \ifft(\matx[j,\cdot], \bm{\zeta})$. Then it constructs a $m\times n$
%matrix $\maty$, where the $j^{th}$ row of $\maty$ is evaluation of $p_j$ on the set
%$\bm{\eta}$, i.e, $\maty[j,\cdot] := \fft(p_j, \bm{\eta})$. Next, the prover constructs
%polynomials $q_k$ for $k\in [n]$ by interpolating the column $\maty[\cdot,k]$ on
%$\bm{\alpha}^0 = (\alpha_1,\ldots,\alpha_m)$, i.e, $q_k(x) := \ifft(\maty[\cdot,k],
%\bm{\alpha}^0)$. It obtains the encoding $\enc(\matx)$ as the $h\times n$ matrix
%$\matz$ whose columns are evaluations of polynomials $q_k$ on the set $\bm{\eta}$, i.e,
%$\matz[\cdot,k]=\fft(q_k,\bm{\alpha})$. The above computation involves
%$O(mn\log(mn))$ operations in $\FF$ for each $m\times \ell$ matrix. Thus, computing $\enc(\wit)$ takes
%$O(pmn\log(mn))$ which is $O(N\log{N})$. We also remark that $\maty$ is a submatrix
%of $\matz$, and thus
%$p_j=\ifft((\matz[j,1],\ldots,\matz[j,\ell]),(\eta_1,\ldots,\eta_{\ell}))$ for $j\in
%[m]$. This allows us to consistently define polynomials $p_j$ for $m<j\leq h$ by
%$p_j=\ifft((\matz[j,1],\ldots,\matz[j,\ell]),(\eta_1,\ldots,\eta_{\ell}))$.
%%
The encoding $\enc$ satisfies the following {\em bounded independence} property:
\begin{lemma}[Bounded Independence]\label{lem:boundedindependence}
Let $B\subseteq [n]$ be a set of size $\bi$. Let $\mc{U}(p,h,b)$ denote the
set of $p\times h\times b$ matrices $\matx$ such
that $\matx[i,\cdot,k]$ is a codeword in $\rsc{\alpha}{m}$ for all $i\in
[p],k\in [\bi]$. Then for any $p\times m\times s$ matrix $\wit$, the random
variable $\ewit_B := \{\ewit[\cdot,\cdot,B]: \ewit\sample \enc(\wit)\}$ is
distributed uniformly on $\mc{U}(p,h,b)$.
\end{lemma}
We defer the proof of the above Lemma to the Appendix.

\subsection{Oracle Construction}\label{sec:construct_oracle} 
Unlike prior IOP constructions such as \cite{ligero, aurora}, we additionally
obtain a homomorphic commitment on the encoded witness $\enc(\wit)$ and provide
oracle access to the commitment. Concretely, we use a
homomorphic vector commitment scheme $\comm$ with message space $\FF^h$,
commitment space $\GG$ and randomness space $\FF$. We compute commitments
$c_{ik}=\comm(\ewit[i,\cdot,k],\delta_{ik})$ where $\delta_{ik}$ denotes the
commitment randomness. Finally we define $p\times n$ matrix $\comoracle$ as
$\comoracle[i,k]=c_{ik}$. We provide oracle access to $\comoracle$ where for a
query $Q\subseteq [n]$, the oracle responds with columns $\comoracle[\cdot,k]$ for
$k\in Q$.

\subsection{Codes and Matrices}\label{sec:codesandmatrices}
Throughout, let $L_1$ and $L_2$ denote the codes $\rsc{\eta}{n,\ell}$ and
$\rsc{\alpha}{h,m}$ respectively. Let $\mc{C}_1 := \ric{L_1}{h}$ and $\mc{C}_2 :=
\cic{L_2}{n}$ denote the interleaved codes of $L_1$ and $L_2$. We denote the
parity check matrices for $L_1$ and $L_2$ by $\mc{H}_1$ and $\mc{H}_2$. We also
notate the set of three dimensional $p\times h\times n$ matrices as $\mc{M}_{p,h,n}$ and
the set of two dimensional $h\times n$ matrices as $\mc{M}_{h\times n}$. We
assume standard distance metrics on the sets $\mc{M}_{p,h,n}$ and $\mc{M}_{h,n}$
as discussed in Section \ref{sec:prelims}. 

\subsection{Proximity Protocol}\label{sec:proximityprotocols}
In this section we introduce {\em well-formed} encodings and
describe a proximity protocol to check that an encoding is well formed.
Let $\mc{W}$ denote the subset of $\mc{M}_{p,h,n}$
consisting of matrices $U$ such that $U[i,\cdot,\cdot]\in L_1\otimes L_2$ for all $i\in [p]$. 
Let $\mc{W}_1$ denote the set of matrices
$U$ in $\mc{M}_{p,h,n}$ such that the $n$-length vector $U[i,j,\cdot]$ is a
codeword in $L_1$ for all $i,j$. Similarly let $\mc{W}_2$ denote the set of
matrices $U$ such that the $h$-length vector $U[i,\cdot,k]$ is a codeword in
$L_2$ for all $i,k$. It can be seen that $\mc{W}=\mc{W}_1\cap \mc{W}_2$. For $U^\ast\in \mc{M}_{p,h,n}$ define
$d(U^\ast,\mc{W}_i)=\min\{\Delta_i(U^\ast,U):U\in \mc{W}_i\}$ for $i=1,2$.
Our goal is to construct an IPCP for proximity that allows a prover to convince a verifier that
the oracle $\comoracle$ opens to a three dimensional matrix $\ewit\in \mc{W}$.
We first need a protocol to check the membership of an $h\times n$ matrix in the
product code $L_1\otimes L_2$.\smallskip

\noindent{\em Membership in Product Code:}
Assume that $U$ is an $h\times n$ matrix, purported to be a codeword in
$L_1\oplus L_2$. Let $\overline{U}$ denote the $h\times \ell$ matrix consisting of
the first $\ell$ columns of $U$. We note that for $U\in L_1\oplus L_2$, we must
have $U=\overline{U}\mc{T}$ for some $l\times n$ matrix $\mc{T}$ of rank $\ell$. Thus, the membership protocol involves the prover sending the column
commitments $\bm{c}=(c_1,\ldots,c_\ell)$ and prove that they correspond to a matrix
$\overline{U}$ such that $\overline{U}\mc{T}\in \mc{C}_2$ (because $\overline{U}\mc{T}\in
\mc{C}_1$ for all $\overline{U}$). Let $\bm{\omega}=(\omega_1,\ldots,\omega_\ell)$ denote 
the randomness used to compute the commitments. We first discuss the protocol
informally. Proving $\overline{U}\mc{T}\in \mc{C}_2$ is equivalent to proving
$(\overline{U}\mc{T})^T\mc{H}_2=\bm{0}$. The verifier can probabilistically
check this by sending random $\tau\sample \FF^n$ and $\delta\sample \FF^{h-m}$
and have the prover prove, $\tau^T(\overline{U}\mc{T})^T\mc{H}_2\delta=0$ which
can be written as $\innp{x}{z}=0$ for $x=\mc{H}_2\delta$ and
$z=\overline{U}\mc{T}\tau$. Since the vector $x$ is public, and the vector $z$
is a linear combination of columns of $\overline{U}$, it's commitment can be
computed from column commitments of $\overline{U}$. Thus, the protocol reduces
to the inner product argument. In the actual protocol, we additionally allow the
prover to randomize $z$ by adding a random codeword $u_0\in L_2$, and commit to
$u_0$ before the verifier's message. This precludes the need for the inner
product argument to be zero knowledge. Throughout our protocols, the witnesses
to the inner product protocols are randomized, which enables us to reduce prover
interaction during distributed proof computation. 

The complete protocol appears in Figure \ref{fig:protocol1}. In the
Figure \ref{fig:protocol1}, $\innerproduct(\FF,\GG,\bm{g},x,\mathsf{cm},v;z,\omega)$ denotes 
an interactive protocol for proving the relation $\innp{x}{z}=v$ and 
$\open(\mathsf{cm})=(z,\omega)$, where $\GG$ denotes the commitment group and 
$\bm{g}$ denotes the generators for vector commitment. 
\begin{figure}[ht]
\begin{framed}
\begin{itemize}
\item {$\proximityTwoD$} $(\FF,\GG, \ell, L_1, L_2,\mathbf{c}; \overline{U},\bm{\omega})$:
\item {\bf Relation}: $\overline{U}=\open(\mathbf{c})$ and $\overline{U}\mc{T}\in \mc{C}_2$.
\begin{enumerate}[{\rm 1.}]
\item $\prover\rightarrow\verifier$: $\prover$ samples a random codeword $u_0\in
L_2$, and computes $d_0=\comm(u_0,\nu_0)$ for $\nu_0\sample \FF$. It sends $d_0$ to $\verifier$.
\item $\verifier\rightarrow \prover$: Verifier samples $\tau\sample
\FF^n$, $\delta\sample \FF^{h-m}$ and sends them to the prover.
\item $\prover\leftrightarrow \verifier$ compute: $\mu=\mc{T}\tau$,
$\mathsf{cm} = d_0+\sum_{i\in [\ell]} \mu_ic_i$, $x=\mc{H}_2\delta$.
\item $\prover$ computes: $z=u_0+\overline{U}\mu$, $\nu=\nu_0+\sum_{i\in [\ell]}\mu_k\omega_k$.
\item $\prover$ and $\verifier$ run the subprotocol:
	\begin{itemize}
	\item $b=\innerproduct(\FF,\GG,\bm{g},x,\mathsf{cm},0;z,\nu)$
	\end{itemize}
\item $\verifier$ accepts if $b=1$.
\end{enumerate}
\end{itemize}
\end{framed}
\caption{Membership Protocol for Product Code}
\label{fig:protocol1}
\end{figure}

We state the correctness of the protocol, deferring the formal proofs to
Appendix.  
\begin{lemma}[Completeness]\label{lem:proximity2d_complete}
For $\overline{U}$ such that $\overline{U}\mc{T}\in \mc{C}_2$, the protocol $\proximityTwoD$ accepts.
\end{lemma}

%\begin{proof}
%For the honest prover, we have:
%\begin{align*}
%\innp{x}{z} &= \innp{\mc{H}_2\delta}{u_0+\overline{U}\mc{T}\tau} \\
%	&= (u_0+\overline{U}\mc{T}\tau)^T\mc{H}_2\delta \\
%	&= u_0^T\mc{H}_2\delta + \tau^T(\overline{U}\mc{T})^T\mc{H_2}\delta \\
%	&= 0 + 0 \text{ as $u_0^T\mc{H}_2=\bm{0}$ and $(\overline{U}\mc{T})^T\mc{H}_2=\bm{0}$ }
%\end{align*}
%It can also be seen that $\mathsf{cm}=\comm(z,\omega)$ and hence by the completeness of the inner product protocol, the verifier accepts.
%\end{proof}
 
\begin{lemma}[Soundness]\label{lem:proximity2d_sound}
For every bounded prover $P^\ast$ and every $\bm{c}\in \GG^\ell$, there exists an
expected polynomial time extractor $\extr$ with
rewinding access to the transcript oracle $\mc{O}=\langle P^\ast(\bm{c},\cdot),V(\bm{c},\cdot)\rangle$
such that $\extr$ either breaks the commitment binding, or outputs a valid
witness with overwhelming probability whenever $P^\ast$ succeeds, i.e,
{\small
\begin{align*}
\condprob{
\begin{array}{l}
\overline{U} = \open(\bm{c}) \wedge \\
\overline{U}\mc{T}\in \mc{C}_2
\end{array}
}{
\begin{array}{l}
\sigma\sample \gen(\secparam) \\
\overline{U}\sample \extr^{\mc{O}}(\bm{c},\sigma)
\end{array}}
\geq \epsilon(P^\ast) - \kappa_{2d}(\lambda)
\end{align*}
}
where $\epsilon(P^\ast)=\condprob{\langle
P^\ast(\bm{c},\sigma),\verifier(\bm{c},\sigma)\rangle = 1}{\sigma\sample
\gen(\secparam)}$ and $\kappa_{2d}$ is negligible in $\lambda$.
\end{lemma}

We now proceed with the construction of the proximity protocol
that allows a prover to prove that a matrix of vector commitments $\pi := \comoracle$ opens to a three
dimensional matrix $\ewit\in \mc{W}$, given oracle access to it. To minimize communication, the key idea is that the verifier chooses
$r\sample \FF^p$ and asks the prover to commit to the two dimensional
matrix $\tilde{U}:=\sum_{i\in [p]}r_i\ewit[i,\cdot,\cdot]$ by sending
commitments $\tilde{c}_1,\ldots,\tilde{c}_\ell$ to the columns of $\tilde{U}$.
Thereafter, we use the protocol $\proximityTwoD$ to check the commitments
correspond to some $U$ such that $U\in L_1\oplus L_2$. To prevent the prover
from sending arbitrary commitments, the verifier checks the consistency of the
commitments with the oracle $\pi$ by querying $t$ columns of the oracle
using a query $Q\subseteq [n]$. For each $k\in Q$, the verifier checks
$\tilde{c}_k = \sum_{a\in [\ell]}\mc{T}[a,k]\tilde{c}_a=\sum_{i\in [p]}r_i\pi[i,k]$. The soundness relies on the fact
that if the oracle $\pi$ opens to encoding $\ewit$ which is far from a well
formed encoding, by Proposition \ref{lem:3dcompression}, with high probability
$\tilde{U}\not\in L_1\oplus L_2$. Thus, an adverserial prover is forced to cheat
by sending several ``inconsistent'' commitments, in which case it fails the
consistency check with overwhelming probability. The complete protocol appears
in Figure \ref{fig:prox3d}. The completeness of the protocol can be directly
verified. We state the soundness property, while deferring the detailed proof to
Appendix.
\begin{figure}[h!]
\begin{framed}
\begin{itemize}
\item {$\proximityThreeD(\FF,\GG,L_1,L_2,[\pi];\ewit)$}
\item {\bf Relation}: $\ewit=\open(\pi)$, $\ewit\in \mc{W}$.
\item {\bf Oracle Setup}: Prover computes $\comoracle$ from $\ewit$ as in
Section \ref{sec:construct_oracle} and sets
$\pi := \comoracle$ as the oracle.
\begin{enumerate}[{1.}]
\item $\verifier\rightarrow \prover$: Verifier samples $r\sample \FF^p$ and
sends $r$ to $\prover$.
\item $\prover$ computes: 
	\begin{itemize}
	\item $\tilde{U}=\sum_{i\in [p]}r_i\ewit[i,\cdot,\cdot]$.
	\item $\tilde{c}_k = \sum_{i\in [p]}r_i\comoracle[i,k]$ for $k\in [\ell]$.
	\end{itemize}
\item $\prover\rightarrow \verifier$: Prover sends
$\tilde{\bm{c}}=(\tilde{c}_1,\ldots,\tilde{c}_\ell)$ to the verifier.
\item $\prover \text{ and } \verifier$: Prover and verifier run the subprotocol:
	\begin{itemize}
	\item $b=\proximityTwoD(\FF,\GG,\ell,L_1,L_2,\tilde{\bm{c}};\tilde{U})$
	\end{itemize}
\item $\verifier$ queries: Verifier samples $Q\subseteq [n]$ of size
$t$ and makes oracle queries for positions in $Q$.
\item Oracle Answers: The oracle responds with columns $\pi[.,k]$ for
$k\in Q$.
\item $\verifier$ checks: The verifier checks $\sum_{i\in
[p]}r_i\pi[i,k]=\sum_{i\in [\ell]}\mc{T}[i,k]\tilde{c}_i$ for $k\in Q$ (the matrix $\mc{T}$ as defined earlier).
\item $\verifier$ accepts if the check passes and $b=1$.
\end{enumerate}
\end{itemize}
\end{framed}
\caption{Proximity Protocol for 3D encoding}
\label{fig:prox3d}
\end{figure}

%\begin{lemma}[Completeness]\label{lem:proximity3d_complete}
%For $\ewit\in\mc{W}$, the protocol $\proximityThreeD$ accepts.
%\end{lemma}
%\begin{proof}
%The assertion follows from the fact that $\ewit\in \mc{W}$ and
%$\ewit=\open(\comoracle)$ implies $\tilde{U}\in L_1\oplus L_2$ and
%$\tilde{U}=\open(\tilde{\mathbf{c}})$, and from the completeness of the protocol
%$\proximityTwoD$.
%\end{proof}

\begin{lemma}[Soundness]\label{lem:proximity3d_sound}
For every bounded prover $P^\ast$ and every oracle $\pi\in \FF^{p\times n}$ and 
proximity parameter $e<d_1/3$,
there exists a polynomial time extractor $\extr$ with rewinding access to
transcript oracle $\mc{O}=\langle P^\ast(\cdot),\verifier^{\pi}(\cdot)\rangle$
such that $\extr$ either breaks the commitment binding, or outputs a valid witness with
overwhelming probability whenever $P^\ast$ succeeds, i.e, 
{\small
\begin{align*}
\condprob{
\begin{array}{l}
\ewit=\open(\pi) \wedge \\
\ewit\in \mc{W}_2\wedge \\
d(\ewit,\mc{W}_1)\leq e
\end{array}
}{
\begin{array}{l}
\sigma\sample \gen(\secparam)\\
\ewit\sample \extr^{\mc{O}}(\sigma)
\end{array}
}\geq \epsilon(P^\ast)-\kappa_{3d}(\secpar)
\end{align*}
}
where, as before $\epsilon(P^\ast)$ denotes $P^\ast$'s success probability and $\kappa_{3d}$ is a negligible function. Note that in the above, $\extr$ can
rewind and proceed with fresh queries to the oracle $\pi$. 	
\end{lemma}

\subsection{Linear Check Protocol}
In this section, we describe an IPCP that allows a prover to prove knowledge of
witness $\wit\in \FF^N$ satisfying a linear constraint of the form $A\wit = b$
for some $A\in \FF^{M\times N}$ and $b\in \FF^M$. As before we veiw $\wit$ as
$p\times m\times s$ matrix where $N=pms$. As desribed previously in Sections
\ref{sec:witencoding} and \ref{sec:construct_oracle}, we obtain $\ewit\sample 
\enc(\wit)$ and $\comoracle\sample \comm(\ewit)$. We present the full protocol in
Figure \ref{fig:linearcheck}. Below we summarize the key ideas in the protocol.

\noindent {\em Reduction to Polynomial Identity}: To check $A\wit=b$, the verifier 
samples random $r\sample \FF^M$ and asks the prover to prove $r^TA\wit=r^Tb$.
 Both prover and verifier view the
vector $r^TA\in \FF^N$ as a $p\times m\times \ell$ matrix $R$ and interpolate
polynomials $R^i(x,y)$ for $i\in [p]$ with $deg_x(R^i)<m$ and $deg_y(R^i)<s$
satisfying $R^i(\alpha_j,\zeta_k)=R[i,j,k]$. Let $Q^i$, $i\in [p]$ denote the
polynomials used in interpolating (and encoding) witness $\wit$. Then, 
$\wit[i,j,k]=Q^i(\alpha_j,\zeta_k)$. The check $\innp{R}{\wit}=r^Tb$ reduces to
$\sum_{i,j,k}R^i(\alpha_j,\zeta_k).Q^i(\alpha_j,\zeta_k)=r^Tb$ where $i,j$ and
$k$ run over indices in $[p],[m]$ and $[s]$ respectively. In principle, the
prover can send the degree $\ell+s$ polynomial
$p(\cdot):=\sum_{i=1}^p\sum_{j=1}^mR^i(\alpha_j,\cdot)Q^i(\alpha_j,\cdot)$ and
the verifier can check $\sum_{k\in [s]} p(\zeta_k)=r^Tb$. 

\noindent {\em Reduction to Inner Product}: Let $\overline{\bm{\zeta}}$ denote the vector $(\zeta_1,\ldots,\zeta_s)$ and let $p(\overline{\bm{\zeta}})$ denote the vector of
evaluations of $p$ on points in $\overline{\bm{\zeta}}$. Similarly, let $\overline{\bm{\eta}}$ denote
the points $(\eta_1,\ldots,\eta_{2\ell})$. The check $\sum_{k\in
[s]}p(\zeta_k)=r^Tb$ can be written as $\innp{1^s}{p(\overline{\bm{\zeta}})}=r^Tb$. 
Let $p_j$ denote the polynomial $\sum_{i\in
[p]}R^i(\alpha_j,\cdot).Q^i(\alpha_j,\cdot)$ for $j\in [h]$. Note that
$p=\sum_{j\in [m]}p_j$. We see that there exists a $2\ell\times s$ matrix
$\Phi$ such that $p(\overline{\bm{\zeta}})=\Phi p(\overline{\bm{\eta}})$. 
We now describe
how to compute $p(\overline{\bm{\eta}})$ from ``tamper resistant'' structures
such as codewords. Define $h\times n$ matrix $P$ by $P[j,k]=p_j(\eta_k)$. Note
that the matrix $P$ is in the product code of codes $\rsc{\eta}{s+\ell}$ and
$\rsc{\alpha}{2m}$. Let $\overline{P}$ denote the matrix consisting of the first
$2\ell$ columns of $P$ and let $c_1,\ldots,c_{2\ell}$ be the commitments of the
columns of $\overline{P}$. Now it can be seen that:
\begin{align}
p(\overline{\bm{\eta}}) = 
\begin{bmatrix} p(\eta_1) \hdots p(\eta_{2\ell}) \end{bmatrix}^T = 
%	{\begin{bmatrix}
%	p_1(\eta_1) & \hdots & p_1(\eta_{2\ell}) \\
%	\vdots & \ddots & \vdots \\
%	p_m(\eta_1) & \hdots & p_m(\eta_{2\ell}) \\
%	\vdots & \ddots & \vdots \\
%	p_h(\eta_1) & \hdots & p_h(\eta_{2\ell})
%	\end{bmatrix}}^T
	\overline{P}^T\begin{bmatrix}
	1^m\ 0^{h-m}
	\end{bmatrix}^T
\end{align}
From the above we have, 
\begin{align}\label{eq:necessarycondlin}
\innp{1^s}{p(\overline{\bm{\zeta}})} = \left\langle 1^s, \Phi\overline{P}^T\begin{bmatrix}
1^m \  0^{h-m} \end{bmatrix}^T\right\rangle = {\begin{bmatrix} 1^m \ 0^{h-m}
\end{bmatrix}}^T\overline{P}\Phi^T[1^s]
\end{align}
Let $\varphi=(\varphi_1,\ldots,\varphi_{2\ell})$ denote the vector
$\Phi^T[1^s]$. Then, check $\sum_{k\in [s]}p(\zeta_k)=r^Tb$ reduces to
proving the inner product $\langle (1^m,0^{h-m}),\overline{P}\varphi\rangle=r^Tb$. Given
commitments $c_1,\ldots,c_{2\ell}$ we can compute commitment to the vector
$\overline{P}\varphi$ and use the inner product protocol argument.
In the actual protocol, the prover will randomize
the final vector $\overline{P}\varphi$ as $\beta P_0 + \overline{P}\varphi$ using a random codeword
 $P_0\in L_2$ satisfying $\sum_{j\in [m]} P_0[j]=0$. In the distributed setting, this 
randomization allows the provers to reveal the witness used for the inner product protocol to the aggregator, allowing the aggregator to complete the protocol with the verifier, without 
further interaction with the provers.

\noindent{\em Checking Consistency with Oracle}: Note that a correctly computed
$P$ in the previous step satisfies $P[j,k]=\sum_{i\in
[p]}R^i(\alpha_j,\eta_k).\ewit[i,j,k]$. Ofcourse, an adverserial prover can provide commitments
an arbitrary matrix $P$. However, since the matrix $P$ can be tested for membership in 
the product codeword, a cheating adversary is forced to commit to a matrix that differs 
substantially from an honestly computed $P$, due to the distance property of the codes. 
Such an adversary will fail with overwhelming probability in establishing the consistency of 
the matrix $P$ with the oracle as we now describe: To check consistency, the verifier 
samples $t$ pairs $(j_u,k_u)$ for $u\in
[t]$ uniformly from $[h]\times [n]$ and asks the prover to provide vectors
$X_u=\ewit[\cdot,j_u,k_u]$ and $\pi[\cdot,k_u]$ for all $u\in [t]$. The prover and
verifier then run inner product protocols to check:
\begin{enumerate}[{\rm (i)}]
\item $\langle P[\cdot,k_u], e_{j_u}\rangle=\sum_{i\in
[p]}R^i(\alpha_{j_u},\eta_{k_u})X_u[i]$ for $u\in [t]$. Note that for in the honest case, $X_u[i]=\ewit[i,j_u,k_u]$, and the identity holds.
\item For all $u\in [t]$, check  that $X_u$ is consistent with oracle $\pi$ by verifying
$\innp{\ewit[i,\cdot,k_u]}{e_{j_u}}=X_u[i]$  Note that the commitment
$\pi[i,k_u]$ for $\ewit[i,\cdot,k_u]$ is obtained as part of oracle answer. Moreover, we can aggregate inner product checks for vector $X_u$ into one inner product check.
\end{enumerate}
The complete linear check protocol is described in Figure \ref{fig:linearcheck}. 
In Figure \ref{fig:linearcheck}, the protocol $\agginnerproduct$ denotes the protocol 
for veryfying inner products of several commited vectors with a common vector. 
The completeness of the linear check protocol can be easily verified. We sketch the proof for its
soundness, leaving the detailed proof to the Appendix.

\begin{lemma}[Soundness]\label{lem:linercheck_sound}
For all polynomially bounded provers $P^\ast$ and all $\pi\in \GG^{p\times n}$,
$A\in \FF^{M\times N}, b\in \FF^M$, there exists an expected polynomial time
extractor $\extr$ with rewinding access to transcript oracle $\mc{O}=\langle
P^\ast(\cdot),\verifier^\pi(\cdot)\rangle$ such that $\extr$ either breaks the 
commitment binding or outputs a witness with overwhelming probability whenever 
$P^\ast$ succeeds, i.e,
{\small
\begin{align*}
\condprob{\begin{array}{c}
\ewit=\open(\pi)\wedge A\wit=b \\
\text{ where } \wit=\dec(\ewit)
\end{array}
}{
\begin{array}{c}
\sigma\sample \gen(\secparam) \\
\ewit\sample \extr^{\mc{O}}(\bm{x},\sigma)
\end{array}}\geq
\epsilon(P^\ast)-\kappa_{lc}(\secpar)
\end{align*}
}
where $\epsilon(P^\ast):= \condprob{\langle P^\ast(\bm{x},\sigma),\verifier^pi(\bm{x},\sigma)\rangle=1}{\sigma\sample \gen(\secparam)}$ denotes the success probability of $P^\ast$, $\kappa_{lc}$ denotes a negligible function, and $\bm{x}$ denotes the tuple $(A,b,M,N)$.
\end{lemma}
\begin{proof}[Proof-Sketch]
Suppose the oracle $\pi$ commits to $\ewit$ such that $\wit=\dec(\ewit)$ does
not satisfy $A\wit=b$.  In a formal proof, $\ewit$ would be the ``extracted''
witness which opens to the oracle $\pi$. The proximity check ensures that for
$e<d_1/3$, $d(\ewit,\mc{W}_1)<e$ and $\ewit\in \mc{W}_2)$ with probability $\approx 1-(1-e/n)^t$.
Let $\ewit_{\rm hon}$ an encoding of $\wit$ such that $d_1(\ewit,\ewit_{\rm
hon})<e$ (see the detailed proof in the Appendix for existence of such an
encoding). Let $P_{\rm hon}$ denote honestly computed $P$ matrix from
$\ewit_{\rm hon}$. If the adverserial prover commits to a matrix $P_{\rm adv}$
such that $P_{\rm adv}=P_{\rm hon}$, it fails the inner product check, as
$r^TAw\neq r^Tb$. If it commits to $P_{\rm adv}\neq P_{\rm hon}$, it fails the
consistency checks with overwhelming probability. To see this consider the
adversarial provers' success probability for the query point $(j_u,k_u)$. Let
$E\subseteq [n]$ denote the indices of planes where $\ewit$ and $\ewit_{\rm
hon}$ differ. The prover opens the vector $X_u=\ewit[\cdot,j_u,k_u]$ (unless it breaks the
soundness of inner product protocol, or binding of the commitment scheme). For
$k_u\not\in E$, we see that to succeed in the consistency check we must have: 
\[ P_{\rm adv}[j_u,k_u]=\sum_{i=1}^p
R^i(\alpha_{j_u},\eta_{k_u})\ewit[i,j_u,k_u]=P_{\rm hon}[j_u,k_u] \]
Let $E'$ be the column indices where $P_{\rm adv}$ and $P_{\rm hon}$ differ.
Then the above check succeeds if (i) $k_u\not\in E'\backslash E$, or (ii) $j_u$
is the common root of distinct $m$ degree polynomials corresponding to columns
$P_{\rm adv}[\cdot,k_u]$ and $P_{\rm adv}[\cdot,k_u]$. In either case, adversary
fails with constant probability, and hence it's success probability is
negligible over $t=O(\secpar)$ checks.
\end{proof}


\subsection{Quadratic Check Protocol}
We now describe the IPCP which allows a prover to prove knowledge of vectors
$\wit_x$, $\wit_y$ and $\wit_z$ in $\FF^N$, satisfying $\wit_x\circ \wit_y =
\wit_z$. Once again, the protocol requires the prover to construct encodings
$\ewit_x=\enc(\wit_x)$, $\ewit_y=\enc(\wit_y)$ and $\ewit_z=\enc(\wit_z)$ as
described in Section \ref{sec:witencoding}. Thereafter, the prover uses
commitment scheme $\comm$ to commit to these encodings as $\comoracle_x =
\comm(\ewit_x)$, $\comoracle_y = \comm(\ewit_y)$ and $\comoracle_z = \comm(\ewit_z)$. 
The prover forms the oracle $\pi\in \GG^{3p\times n}$ by vertically stacking the
$p\times n$ matrices $\comoracle_x,\comoracle_y$ and $\comoracle_z$. As before,
for a query $Q\subseteq [n]$, the oracle answers with columns $\pi[\cdot,k]$ for
$k\in Q$. The columns returned by the oracle can be parsed into constituent columns 
$\comoracle_x[\cdot,k]$, $\comoracle_y[\cdot,k]$ and $\comoracle_z[\cdot,k]$
canonically. We again discuss the key ingredients of the protocol.

\noindent{\em Probabilistic Reduction}: Let $Q^i_x,Q^i_y$ and $Q^i_z, i\in [p]$ be the
polynomials interpolating the $i^{th}$ slices of $\wit_x$, $\wit_y$ and $\wit_z$
 as in Section \ref{sec:witencoding}. Then for vectors $\wit_x,\wit_y,\wit_z$ satisfying
$\wit_x\circ \wit_y=\wit_z$, the polynomials $Q^i=Q^i_x\cdot Q^i_y - Q^z_i$ interpolate
$\bm{0}^{m\times s}$ on the set $\{(\alpha_j,\zeta_k):j\in [m],k\in [s]\}$ for all $i\in [p]$. This can be probabilistically
checked by checking that the polynomial $F := \sum_{i\in [p]}r_iQ^i$ interpolates
$\bm{0}^{m\times s}$ on the above set for randomly sampled $r\in \FF^p$. Once again, we
ask the prover to ``commit'' to $F$ using a tamper resistant structure, like a codeword,
which enables the verifier to check the aforementioned condition, as well as to
ensure that the commitment is consistent with oracle replies and prior
messages.

\noindent{\em Reduction to Inner Products}: The prover computes 
$h\times n$ matrix $P$ given by $P[j,k]=F(\alpha_j,\eta_k)$. It commits to $P$
using commitments $(c_1,\ldots,c_{2\ell})$ to the first $2\ell$ columns of $P$.
Note that each row of $P$ commits to univariate component polynomials
$F(\alpha_j,\cdot)$ of $F$ via their evaluations of $\bm{\eta}$. To check that
$F$ interpolates $\bm{0}^{m\times s}$ on the points
$\{(\alpha_j,\zeta_k)\}_{j\in [m],k\in [s]}$, the verifier checks that
$p(\cdot) := \sum_{j\in [m]}\gamma_jF(\alpha_j,\cdot)$ interpolates $\bm{0}^s$ on
$\overline{\bm{\zeta}}$ for randomly sampled $\gamma=(\gamma_1,\ldots,\gamma_m)\in \FF^m$.
Again, the verifier checks $p(\overline{\bm{\zeta}})=\bm{0}^s$ via the inner product
check $\innp{\tau}{p(\overline{\bm{\zeta}})}=0$ for a random $\tau\in \FF^s$. As in the
linear check protocol, using $p(\overline{\bm{\zeta}})=\Phi p(\overline{\bm{\eta}})$, we
get the following inner product check
$\innp{(\gamma,0^{h-m})}{\overline{P}\varphi}=0$ where $\varphi=\Phi^T\tau$. 
The commitment to the vector $\overline{P}\varphi$ can be homomorphically computed
from $c_1,\ldots,c_{2\ell}$.

\noindent{\em Checking consistency with Oracle}: As in the linear check, the
verifier uniformly and independently samples $(j_u,k_u)\in [h]\times [n]$ for
$u\in [t]$, and queries the oracle $\pi$ for columns $\pi[\cdot,k_u]$. Let
$\pi_x[\cdot,k_u]$, $\pi_y[\cdot,k_u]$ and $\pi_z[\cdot,k_u]$ denote the parse
of $\pi[\cdot,k_u]$ into commitments corresponding to $\ewit_x,\ewit_y$ and
$\ewit_z$ respectively. Further, the verifier asks prover for vectors
$\ewit_x[\cdot,j_u,k_u]$, $\ewit_y[\cdot,j_u,k_u]$ and $\ewit_z[\cdot,j_u,k_u]$
for $u\in [t]$. The verifier then checks the following:
\begin{enumerate}[{\rm (i)}]
\item For all $u\in [t]$: $P[j_u,k_u]=\sum_{i\in
[p]}r_i(\ewit_x[i,j_u,k_u]\cdot\ewit_y[i,j_u,k_u]-\ewit_z[i,j_u,k_u])$.
\item Checks that vectors $\ewit_x[\cdot,j_u,k_u]$ are consistent with
commitments $\pi_x[\cdot,k_u]$ as in linear check protocol. Similar checks are
made for $\ewit_y[\cdot,j_u,k_u]$ and $\ewit_z[\cdot,j_u,k_u]$.
\end{enumerate}
We present the full protocol in Figure \ref{fig:quadcheck}. The completeness of
the protocol can again be verified by direct calculation. We state the soundness
of the protocol below:

\begin{lemma}[Soundness]\label{lem:quadcheck_sound}
For all polynomially bounded provers $P^\ast$ and all $\pi\in \GG^{3p\times n}$,
there exists an expected polynomial time extractor $\extr$ with rewinding access
to the transcript oracle $\mc{O}=\innp{P^\ast(\cdot)}{\verifier^{\pi}(\cdot)}$
such that either $\extr$ breaks the commitment binding, or it outputs a witness
with overwhelming probability whenever $P^\ast$ succeeds, i.e,
{\small
\begin{align*}
\condprob{
\begin{array}{c}
{[}\ewit_x||\ewit_y||\ewit_z{]}=\open(\pi)\wedge \\
\wit_z=\wit_x\circ\wit_y
\end{array}
}{
\begin{array}{c}
\sigma\sample \gen(\secparam) \\
{[}\ewit_x||\ewit_y||\ewit_z{]}\sample \extr^{\mc{O}}(\sigma)\\
\wit_a=\dec(\ewit_a), a\in \{x,y,z\}
\end{array}
}\geq \epsilon(P^\ast) - \kappa_{\rm qd}(\secpar)
\end{align*}
}
for some negligible function $\kappa_{qd}$. In the above, $\epsilon(P^\ast)$
denotes the success probability of the prover $P^\ast$ as before.
\end{lemma}
\begin{proof}
The proof is similar to the proof of the linear check protocol. Using similar
arguments, one can show that the above Lemma holds with:
{\small
\begin{equation*}
\kappa_{qd}(\secpar) := \left(1-\frac{e}{n}\right)^t +
\left(\frac{2m}{h}+\left(1-\frac{2m}{h}\right)\left(\frac{2\ell+e}{n}\right)\right)^t
+ \frac{O(|C|)}{|\FF|}
\end{equation*}
}
\end{proof}

\subsection{Zero Knowledge}
We now prove protocols $\linearcheck$ and $\quadcheck$ to be honest verifier zero knowledge by
designing simulators for them. We infact simulate ``extended'' view of the
verifier which includes
the witnesses for inner product protocols consisting of the committed vector 
and commitment randomness. It is clear then, that the simulation can be
completed by running the inner product argument on these simulated witness
vectors. We describe the view of the verifier in the linear check protocol with
the aforementioned extensions. We decompose the view as:

\noindent {\bf Verifier Randomness}: Vector $r\in \FF^N$ in Step 1,
$\{j_u,k_u\}_{u\in [t]}$, $\beta\in \FF_\ast$ in Step 5, $\tau,\delta$ as
part of $\proximityTwoD$ subprotocol in Step 10, $\rho\sample \FF^p$ as the
random vector for compressing in subprotocol $\proximityThreeD$ in Step 15,
$\tilde{\tau},\tilde{\delta}$ for the second invocation of $\proximityTwoD$ from within
$\proximityThreeD$. We
do not include the query positions as part of the subprotocol $\proximityThreeD$
as we assume that the same query positions sampled in Step 5 are used there.
Summarizing, the verifier randomness consists of $r,\{j_u,k_u\}_{u\in
[t]},\beta,\tau,\delta,\rho,\tilde{\tau},\tilde{\delta}$.

\noindent {\bf Commitments}: Commitment $c_0$ to the random codeword sampled in Step
3(d), commitments $c_1,\ldots,c_{s+\ell}$ to the first $s+\ell$ columns of the
matrix $P$, commitment $d_0$ for random vector $u_0$ used in $\proximityTwoD$
subprotocol in Step 10, commitments $\tilde{c}_1,\ldots,\tilde{c}_{\ell}$ as
part of $\proximityThreeD$ protocol in Step 15, and commitment $\tilde{d}_0$ to
the random codeword in the invocation of $\proximityTwoD$ from within
$\proximityThreeD$ in step 15. Additionally, the view contains commitments
$\pi[\cdot,k_u]$ for $u\in [t]$ as part of oracle query response. Summarizing,
the view consists of commitments $c_0,c_1,\ldots,c_{s+\ell},d_0$, 
$\tilde{c}_1,\ldots,\tilde{c}_{\ell},\tilde{d}_0,\{\pi[\cdot,k_u]\}_{u\in [t]}$

\noindent {\bf Commitment Randomness}: We include randomness used to compute certain
commitments as part of the extended view. We include $\nu=\nu_0+\sum_{a\in
[s+\ell]}\mu_a\omega_a$ for the vector $z$ in the subprotocol
$\proximityTwoD$ in Step 10 (here $\mu=\mc{T}\tau$),
$\omega=\beta\omega_0+\sum_{a\in [s+\ell]}\varphi_ac_a$ for inner product in
Step 11, $\chi_u=\sum_{a\in [s+\ell]}T[a,k_u]c_a$ for $u\in [t]$ for the inner
products in Step 13, $\{O[\cdot,k_u]\}_{u\in [t]}$ for aggregate inner product
arguments in Step 14, $\tilde{\nu}=\tilde{\nu}_0+\sum_{a\in
[\ell]}\tilde{\mu}_a\tilde{c}_a$ for the vector $\tilde{z}$ in the
$\proximityTwoD$ protocol called as part of $\proximityThreeD$ protocol in Step
15. Summarizing, the view includes $\nu,\omega,\{\chi_u\}_{u\in
[t]},\{O[\cdot,k_u]\}_{u\in [t]},\tilde{\nu}$.

\noindent {\bf Witness related vectors}: We describe various vectors derived from
witness encoding provided to the verifier. Vectors $X_u=\ewit[\cdot,j_u,k_u]$
for $u\in [t]$ in Step 6, the vector $z=u_0 + \overline{P}\mu$ ($\mu=\mc{T}\tau$) as
part of view of the subprotocol $\proximityTwoD$ in Step 10, the vector
$z'=\beta P_0+\overline{P}\varphi$ as the witness to the inner product check in Step
11, vectors $P[\cdot,k_u]$ for $u\in [t]$ as witnesses to inner product checks
in Step 13, matrices $\ewit[\cdot,\cdot,k_u]$ for $u\in [t]$ as witnesses to
aggregate inner product checks in Step 14, and finally the vector
$\tilde{z}=\tilde{u}_0 + \sum_{a\in [\ell]}\tilde{\mu}_a\tilde{c}_a$ as part of
protocol $\proximityTwoD$ from within $\proximityThreeD$ in Step 15. We drop
$\{X_u\}_{u\in [t]}$ and $\{P[\cdot,k_u]\}_{u\in [t]}$ from the view as these
can be derived from $\ewit[\cdot,\cdot,k_u]$ and $r$. Thus, the vectors in the
view consist of: $z,z',\{\ewit[\cdot,\cdot,k_u]\}_{u\in [t]},\tilde{z}$.

Next we describe a simulator that outputs a view indistinguishable from the
above view.

\noindent{\bf Simulator}: The simulator outputs $r$, $\{j_u,k_u\}_{u\in [t]}$,
$\beta$, $\tau,\delta$, $\rho$, $\tilde{\tau},\tilde{\delta}$ by uniformly and
independently sampling them from their respective domains, as in the honest
execution of the protocol. Simulator also outputs $z,\tilde{z}$ uniformly from
$L_2$, and $z'$ uniformly from $\dashL_2$ satisfying $\sum_{j\in [m]}z'[j]=0$ . It outputs
$\ewit[\cdot,\cdot,k_u]$ uniformly such that each plane has columns as codewords
in $L_2$. 
Next, the simulator outputs $\omega,\nu,\tilde{\nu}$
and $\chi_1,\ldots,\chi_t$, $\{O[\cdot,k_u]\}_{u\in [t]}$ choosing them randomly and
independently from $\FF$. Finally, the simulator outputs
$c_0,d_0,\ldots,c_{s+\ell}$ and $\tilde{d}_0,\tilde{c}_1,\ldots,\tilde{c}_\ell$ choosing 
them uniformly from $\GG$ subject the following constraints:
$d_0 + \sum_{a=1}^{s+\ell}\mu_ac_a = \comm(z,\nu)$,
$c_0 + \sum_{a=1}^{s+\ell}\varphi_ac_a = \comm(z',\omega)$,
$\sum_{a=1}^{s+\ell}T[a,k_u]c_a = \comm(P[\cdot,k_u],\chi_u)$ for $u\in [t]$,
$\sum_{a=1}^{\ell}\mc{T}[a,k_u]\tilde{c}_a = \comm\big(\sum_{i\in
[p]}\tilde{U}[\cdot,k_u],\tilde{O}[\cdot, k_u]\big)$ for $u\in [t]$,
$\beta\tilde{d}_0 + \sum_{a=1}^{\ell}\tilde{\mu}_a\tilde{c}_a =
\comm(\tilde{z},\tilde{\nu})$. 

\begin{lemma}\label{lem:simlincheck}
The output of the above simulator is perfectly indistinguishable
from the extended view of the verifier in honest execution of the protocol
$\linearcheck$ for $t\leq \bi$.
\end{lemma}
We defer the proof of the correctness of the simulation to Appendix.
We omit the simulation for the quadratic check protocol, as it is very similar
to the linear check. One key difference we highlight is that we do not need to
randomize the vector $\overline{P}\varphi$, the witness in the inner product check in
Step 10 (and part of the extended view), as in the honest execution of the
protocol, $\overline{P}\varphi$ is the unique codeword $z$ of $L_2$ with $z[j]=0$ for
all $j\in [m]$. We state the lemma formally, skipping the proof.

\begin{lemma}\label{lem:simquadcheck}
There exists an efficient simulator $\simulator$ whose output is perfectly
indistinguishable from the extended view of the verifier in the honest execution
of the protocol $\quadcheck$ for $t\leq \bi$.
\end{lemma}


\subsection{Extension to DPZK}
We now describe variants of the protocols discussed previously when the witness
is shared among several provers. We assume that there are $K$ provers
$P_1,\ldots,P_K$. For $\xi\in [K]$, let $\shr{\wit}$ denote the prover
$\distprover$'s share of the witness $\wit$. We assume that the sharing is additive,
i.e, $\sum_{\xi\in [K]}\shr{\wit}=\wit$. When denoting witnesses to certain
protocols, we use the $[[\cdot]]$ to denote that the witness is additively
shared among the provers, i.e, notation $[[x]]$ in the witness list of the
protocol denotes that the provers have shares $\shr{x}$ of $x$. We assume that
there is a designated party $\Ag$ which aggregates the messages received from
provers $P_1,\ldots,P_K$ and constructs the message to be sent to the verifier
$\verifier$. The verifier's  messages are assumed to be available to every
prover through a broadcast channel. Finally, we mention that aggregator's role
is conceptual, and may be played by one of the provers. We proceed to describe
distributed versions of the key subprotocols.

\noindent{\bf Distributed Membership Test}: We describe the variant of the
protocol $\proximityTwoD$ for the case when the matrix $\overline{U}$ is shared
across several parties. The complete protocol appears in Figure
\ref{fig:distprox2d}. \smallskip

\begin{figure}[h!]
\centering
\begin{framed}
\begin{itemize}
\item $\distproxTwoD(\FF,\GG,\ell,L_1,L_2,\bm{c};[[\overline{U}]],[[\bm{\omega}]])$:
\item {\bf Relation}: $(\overline{U},\bm{\omega})=\open(\bm{c})$ and
$\overline{U}\mc{T}\in \mc{C}_2$.
\begin{enumerate}[{\rm 1.}]
\item $\distprover\rightarrow \Ag$: Samples random codeword $u^\xi_0\in L_2$ and
computes $d^\xi_0=\comm(u^\xi_0,\nu^\xi_0)$ for randomly sampled $\nu^\xi_0$.
Sends $d^\xi_0$ to $\Ag$.
\item {\color{red} $\Ag\rightarrow \verifier$: $\Ag$ computes $d_0=\sum_{\xi\in
K}d^\xi_0$ and sends $d_0$ to $\verifier$ }.
\item $\verifier\rightarrow \distprover$: Verifier samples $\tau\sample \FF^m$,
$\delta\sample \FF^{h-m}$ and sends them to $\distprover$.
\item $\Ag\leftrightarrow \verifier$ compute: $\mu=\mc{T}\tau$,
$\mathsf{cm}=d_0+\sum_{i\in [\ell]}\mu_ic_i$, $x=\mc{H}_2\delta$.
\item $\distprover$ computes: $[[z]]^\xi=u^\xi_0+[[\overline{U}]]^\xi\mu$,
$[[\nu]]_\xi=\nu^\xi_0+\sum_{i\in [\ell]}\mu_i[[\omega_i]]^\xi$.
\item {\color{red} $\Ag$ computes: $z=\combine([[z]]^\xi)$,
$\nu=\combine([[\nu]]^\xi)$}.
\item $\Ag$ and $\verifier$ run the subprotocol:
	\begin{itemize}
	\item $b=\innerproduct(\FF,\GG,\bm{g},x,\mathsf{cm},0;z,\nu)$.
	\end{itemize}
\item $\verifier$ accepts if the subprotocol accepts.
\end{enumerate}
\end{itemize}
\end{framed}
\caption{Distributed Membership Test}
\label{fig:distprox2d}
\end{figure}

\noindent{\bf Distributed Proximity Test}: We describe a protocol that allows
multiple provers, each having share of the witness, to construct commitment to
the encoded witness as in Section \ref{sec:witencoding}, and convince the
verifier that the commitment opens to a well formed encoding by providing oracle
access to the commitment. The protocol appears in Figure
\ref{fig:distprox3d}.\smallskip

\begin{figure}[h!]
\centering
\begin{framed}
\begin{itemize}
\item {$\distproxThreeD(\FF,\GG,L_1,L_2,[\pi];[[\ewit]])$}:
\item {\bf Relation}: $\ewit=\open(\pi)$, $\ewit\in \mc{W}$.
\item {\bf Oracle Setup}: 
	\begin{itemize}
	\item $\distprover\rightarrow \Ag$: Each prover computes shares $[[\comoracle]]^\xi$ from $[[\ewit]]^\xi$ as $[[\comoracle]]^\xi=\comm([[\ewit]]^\xi)$ as in Section \ref{sec:construct_oracle}. 
	\item {\color{red} $\Ag$ computes: $\comoracle :=
\combine([[\comoracle]]^\xi)$ and sets $\pi := \comoracle$ as the oracle}.
	\end{itemize}
\begin{enumerate}[{\rm 1.}]
\item $\verifier\rightarrow\distprover$: Verifier samples $r\sample \FF^p$ and
sends $r$ to $\distprover$.
\item $\distprover$ computes:
	\begin{itemize}
	\item $\shr{\tilde{U}} := \sum_{i\in [p]}r_i\shr{\ewit}[i,\cdot,\cdot]$.
	\item $\shr{\tilde{c}_k} := \sum_{i\in [p]}\shr{\comoracle}[i,k]$ for
$k\in [\ell]$.
	\item $\shr{\tilde{\omega}_k} := \sum_{i\in [p]}O^\xi[i,k]$ for
$k\in [\ell]$.
	\end{itemize}
\item $\distprover\rightarrow\Ag$: The provers send $\shr{\tilde{\bm{c}}} :=
(\shr{\tilde{c}_1},\ldots,\shr{\tilde{c}_\ell})$ to $\Ag$.
\item {\color{red} $\Ag\rightarrow\verifier$: $\Ag$ computes $\tilde{\bm{c}} :=
\combine(\shr{\tilde{\bm{c}}})$ and sends
$\tilde{\bm{c}}=(\tilde{c}_1,\ldots,\tilde{c}_\ell)$ to $\verifier$}.
\item $\Ag$ and $\verifier$ run the subprotocol:
	\begin{itemize}
	\item
$b=\distproxTwoD(\FF,\GG,\ell,L_1,L_2,\tilde{\bm{c}};\shr{\tilde{U}})$.
	\end{itemize}
\item $\verifier$ queries: $\verifier$ samples $Q\subseteq [n]$ of size $t$ and
makes oracle queries for positions in $Q$.
\item Oracle Answers: The oracle responds with columns $\pi[\cdot,k]$ for $k\in
Q$.
\item $\verifier$ checks: The verifier checks $\sum_{i\in
[p]}r_i\pi[i,k]=\sum_{i\in [\ell]}\mc{T}[i,k]\tilde{c}_i$ for $k\in Q$.
\item $\verifier$ accepts if the above check succeeds and $b=1$. 
\end{enumerate}
\end{itemize}
\end{framed}
\caption{Distributed 3D Proximity Protocol}
\label{fig:distprox3d}
\end{figure}

\noindent{\bf Distributed Linear Check}: In the distributed linear check, the
provers with shares $\shr{\wit}$ of the witness $\wit$ try to convince the
verifier that $A\wit=b$ for public matrix $A$ and a public vector $b$. In Figure
\ref{fig:distlincheck}, we present the adaptation of the protocol $\linearcheck$ to
the distributed setting. We will assume that the parties have shares of $0^h$.
Without loss of efficiency, this may be obtained as part of obtaining shares of
the witness.

\begin{figure}[h!]
\centering
\begin{framed}
\begin{itemize}
\item {$\distlinearcheck(\FF,\GG,L_1,L_2,A\in \FF^{M\times N},b\in
\FF^M,[\pi];\shr{\ewit},\shr{0^h})$}
\item {\bf Relation}: $\exists \ewit$ s.t. $\ewit=\open(\pi)$ and $A\wit = b$
for $\wit=\dec(\ewit)$.
\item {\bf Oracle Setup}: 
	\begin{itemize}
	\item $\distprover\rightarrow\Ag$: The prover $\distprover$ computes
$\shr{\comoracle} = \comm(\shr{\ewit})$ as in Section
\ref{sec:construct_oracle}. It sends $\shr{\comoracle}$ to $\Ag$. 
	\item {\color{red} $\Ag$ computes: $\comoracle := \combine(\shr{\comoracle})$ and
sets $\pi := \comoracle$}.
	\end{itemize}
\begin{enumerate}[{\rm 1.}]
\item $\verifier\rightarrow\distprover$: $\verifier$ samples $r\sample \FF^N$ and
sends it to $\distprover$.
\item $\distprover\leftrightarrow\verifier$: Provers ($\distprover$) and $\verifier$
compute polynomials $R^i$, $i\in [p]$ such that
$R^i(\alpha_j,\zeta_k)=R[i,j,k]$ where $R=r^TA$. 
\item $\distprover$ computes:
	\begin{enumerate}
	\item Polynomials $\shr{p_j}(\cdot) := \sum_{i\in
[p]}R^i(\alpha_j,\cdot).\shr{Q^i}(\alpha,\cdot)$ for $j\in [h]$. Here the
polynomial $\shr{Q^i}$ interpolates the witness share
$\shr{\wit}[i,\cdot,\cdot]$ on $G$.
	\item An $h\times n$ matrix $\shr{P}$ such that $\shr{P}[j,k]=\shr{p_j}(\eta_k)$.
	\item Commitments $\shr{c_k}=\comm(\shr{P}[\cdot,k],\shr{\omega}_k)$ for $k\in [s+\ell]$
where $\shr{\omega}_k\sample \FF$.
	\item Sample a codeword $\shr{P_0}\in \dashL_2$ s.t $\sum_{j\in
[m]}\shr{P_0}[j]=0$.
Compute $\shr{c_0}=\comm(\shr{P_0},\shr{\omega_0}$ for $\shr{\omega_0}\sample \FF$.
	\item Compute $\shr{Z} := \beta\shr{P_0} + \shr{P}\varphi + \shr{0^h}$ for
$\varphi=\Phi^T[1^s]$.
	\end{enumerate}
\item $\distprover\rightarrow\Ag$: Provers send
$\shr{c_0},\shr{c_1},\ldots,\shr{c_{s+\ell}}$ and $\shr{Z}$ to $\Ag$.

% Aggregation step
\item {\color{red} $\Ag$ computes: $(c_0,c_1,\ldots,c_{s+\ell}) :=
\combine(\shr{c_0},\shr{c_1},\ldots,\shr{c_{s+\ell}})$ and $Z :=
\combine(\shr{Z})$}.

\item $\verifier\rightarrow\distprover$: $\verifier$ samples $(j_u,k_u)\sample [h]\times
[n]$ for $u\in [t]$. It also samples $\beta\sample\FF$. The verifier sends
$Q=\{(j_u,k_u):u\in [t]\}$ and $\beta$ to provers $\distprover$.
\item $\distprover\rightarrow\Ag$: The provers sends vectors
$\shr{Y_u}=\shr{\ewit}[\cdot,\cdot,k_u]$ for $u\in [t]$ to $\Ag$.

% Aggregation step
\item {\color{red} $\Ag$ computes: 
	\begin{itemize}
	\item $Y_u=\combine(\shr{Y_u})$ for $u\in [t]$.
	\item $X_u=Y_u[j_u,\cdot]$ for $u\in [t]$.
	\item Compute $P[\cdot,k_u]$ from $R$ and $Y_u$ for $u\in [t]$.
	\end{itemize}
} 
\item Oracle Queries: $\verifier$ queries the oracle $\pi$ with $\{k_u:u\in
[t]\}$. 
\item Oracle Answers: The oracle replies with columns $\pi[\cdot,k_u]$, $u\in
[t]$.
\item $\Ag\leftrightarrow\verifier$: Both $\Ag$ and $\verifier$
compute $\varphi := \Phi^T[1^s]$ and $\mathsf{cm} := \beta c_0 + \sum_{k\in
[s+\ell]}\varphi_kc_k$.
\item $\Ag$ and $\verifier$ run the subprotocol:
	\begin{itemize}
	\item $b_{\rm 2d} =
\distproxTwoD(\FF,\GG,s+\ell,\dashL_1,\dashL_2,\bm{c};[[\overline{P}]])$
where $\bm{c}=(c_1,\ldots,c_{s+\ell})$ and $\overline{P}$ is the submatrix of $P$
consisting of the first $s+\ell$ columns. Here $\dashL_1=\rsc{\eta}{s+\ell}$ and
$\dashL_2=\rsc{\alpha}{2m}$.
	\end{itemize}
\item $\Ag$ and $\verifier$ run the subprotocol:
	\begin{itemize}
	\item $b = \innerproduct(\GG,\bm{g},x,\mathsf{cm},v;z)$
with $x=(1^m,0^{h-m})$, $v=r^Tb$ and $z=Z$.
	\end{itemize}
\item $\Ag$ and $\verifier$ compute: For all $u\in [t]$ $c_{k_u} =
\sum_{a\in 2\ell}T[a,k_u]c_a$, where $T$ is the matrix such that $P=\overline{P}T$.
\item $\Ag$ and $\verifier$ run inner product subprotocols for each $u\in
[t]$:
	\begin{itemize}
	\item $s_u=\innerproduct(\GG,\bm{g},x,c_{k_u},v;P[\cdot,k_u])$ with
$x=e_{j_u}$, $v=\sum_{i\in [p]}R^i(\alpha_{j_u},\eta_{k_u})X_u$.
	\end{itemize}
\item $\Ag$ and $\verifier$ run aggregate inner product protocols for each
$u\in [t]$:
	\begin{itemize}
	\item
$a_u=\agginnerproduct(\GG,\bm{g},e_{j_u},\pi[\cdot,k_u],X_u;\ewit[\cdot,\cdot,k_u])$
	\end{itemize}
\item $\prover$ and $\verifier$ run the subprotocol: 
	\begin{itemize}
	\item $b_{\rm prox} = \proximityThreeD(\FF,\GG,L_1,L_2,[\pi];U)$
	\end{itemize}
\item The verifier accepts if all the subprotocols accept.
\end{enumerate}
\end{itemize}
\end{framed}
\caption{Distributed Linear Check Protocol}
\label{fig:distlincheck}
\end{figure}

Our next lemma captures the fact that the aggregator $\Ag$ gains no additional
knowledge from the messages sent by the provers in the distributed protocol
$\distlinearcheck$. 

\begin{lemma}\label{lem:distlincheckzk}
For $\xi\in [K]$, let $\View^\xi_\Ag$ denote the view of the aggregator $\Ag$ in the distributed
linear check protocol consisting of messages from the prover $\distprover$ with
witness $\shr{\wit}$. Then there exists an efficient simulator $\simulator$
which outputs a view indistinguishalbe from the joint view $\langle
\View^1_\Ag,\ldots,\View^K_\Ag\rangle$ whenever $A\wit=b$ for
$\wit=\combine(\shr{\wit})$.
\end{lemma}
\begin{proof}


\end{proof}


%\end{enumerate}
   



\subsection{Non-interactive}
IOP to NIROP
