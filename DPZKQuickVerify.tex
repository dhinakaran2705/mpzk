%\newcommand{\enc}{\mathsf{Enc}}
\newcommand{\fft}{\mathsf{FFT}}
\newcommand{\ifft}{\mathsf{IFFT}}
\newcommand{\open}{\mathsf{Open}}

\section{DPZKQuickVerify} \label{sec:quickverify}
While the construction of the previous section leads to smaller argument size,
it comes with a considerable degradation to prover and verifier efficiency, as
both the prover and the verifier incur $O(N^{1-1/c})$ exponentiations. Note
that while the prover needs to compute $O(N)$ exponentiations while computing
commitment $\comoracle$, one can use multi-exponentiations to compute the same
using $O(N/\log{N})$ exponentiations which can be significant speed-up in
practice. In this section we additionally leverage homomorphic commitments
(introduced to facilitate distributed proof generation) to obtain a better
trade-off between the argument size and the number of exponentiations computed
by the prover and the verifier. Essentially, we obtain the same argument size
of $N^{1/c}$ for $c\geq 2$ while restricting the inner product arguments to
vectors of size at most $O(N^{1-2/c})$. For practically relevant lower values
of $c$, the gains in efficiency are substantial.
   
We start by arranging the witness vector $\wit\in \FF^N$ as a $3$-dimensional
 matrix. Let $p,m$ and $\ell$ be integers such that $N=pm\ell$. We view the
witness $\wit$ 
as $p\times m\times\ell$ matrix with entries $\wit[i,j,k]$ for $i\in [p]$,
$j\in [m]$ and $k\in [\ell]$. Let $\wit^i$ denote the (two dimensional) sub-matrix
$\wit[i,\cdot,\cdot]$ for $i\in [p]$. To obtain the encoding of
$\wit$, we use product code of two Reed Solomon codes to encode each matrix
$\wit^i$,
$i\in [p]$ as a codeword in the product code. The use of the product code is
essential to ensure soundness of the protocol with constant number of queries.
We now describe the encoding in more detail.

\subsection{Witness encoding with RS product code}\label{sec:witencoding}
We first choose the following sets of distinct points in $\FF$:
\begin{align}\label{eq:points}
\bm{\zeta} =\{\zeta_1,\ldots,\zeta_{\ell}\},\quad 
\bm{\eta}  = \{\eta_1,\ldots,\eta_n \},\quad
\bm{\alpha} = \{\alpha_1,\ldots,\alpha_{h}\} \text{ where } h>2m. 
\end{align}

Next, we define interpolation domain $G$ as $G=\{(\alpha_j,\zeta_k): j\in[m],
k\in [\ell]\}$ and evaluation domain $H$ as $H=\{(\alpha_j,\eta_k): j\in [h],
k\in [n]\}$. We encode an $m\times \ell$ matrix $a$ by interpolating a
bivariate polynomial $Q^a(x,y)$ with $\deg_x(Q)<m$ and $\deg_y(Q)<\ell$
satisfying $Q^a(\alpha_j,\zeta_k)=a[j,k]$ for $j\in [m],k\in [\ell]$. We define
the encoding $\enc(a)$ of $a$ as the $h\times n$ matrix $b$ consisting of
evaluations of $Q^a$ on $H$, i.e, $b[j,k]=Q^a(\alpha_j,\eta_k)$ for $j\in
[h],k\in [n]$. It can be seen that $\enc(a)$ is a codeword in the product code
$\rsc{\eta}{\ell}\oplus \rsc{\alpha}{m}$. To compute encoding of $\wit$, we
encode each submatrix $\wit^i$ as $\ewit^i=\enc(\wit^i)$ for all $i\in [p]$.
Finally we define the encoding $\ewit=\enc(\wit)$ by $\ewit[i,j,k]=\ewit^i[j,k]$
for $i\in [p], j\in [h], k\in [n]$.\medskip

\noindent{\bf Efficiently computing the encoding}: Although the above
description of the encoding of matrix $a$ involves the bivariate polynomial
$Q^a$, the prover does not explicitly need to compute the polynomial $Q^a$ to compute the
encoding, or any of the messages in the protocols we discuss. Given an $m\times \ell$
matrix $a$, the prover first computes the polynomials $p_j$ for $j\in
[m]$ as $p_j(y) := \ifft(a[j,\cdot], \bm{\zeta})$. Then it constructs a $m\times n$
matrix $X$, where the $j^{th}$ row of $X$ is evaluation of $p_j$ on the set
$\bm{\eta}$, i.e, $X[j,\cdot] := \fft(p_j, \bm{\eta})$. Next, the prover constructs
polynomials $q_k$ for $k\in [n]$ by interpolating the column $X[\cdot,k]$ on
$\bm{\alpha}^0 = (\alpha_1,\ldots,\alpha_m)$, i.e, $q_k(x) := \ifft(X[\cdot,k],
\bm{\alpha}^0)$. It obtains the encoding $\enc(a)$ as the $h\times n$ matrix
whose columns are evaluations of polynomials $q_k$ on the set $\bm{\eta}$, i.e,
$b[\cdot,k]=\fft(q_k,\bm{\alpha})$. The above computation involves
$O(mn\log(mn))$ operations in $\FF$. Thus, computing $\enc(\wit)$ takes
$O(pmn\log(mn))$ which is $O(N\log{N})$. We also remark that $X$ is a submatrix
of $b$, and thus
$p_j=\ifft((b[j,1],\ldots,b[j,\ell]),(\eta_1,\ldots,\eta_{\ell}))$ for $j\in
[m]$. This allows us to consistently define polynomials $p_j$ for $m<j\leq h$ by
$p_j=\ifft((b[j,1],\ldots,b[j,\ell]),(\eta_1,\ldots,\eta_{\ell}))$. Further, it
can be shown that $p_j(y)=Q^a(\alpha_j,y)$ for $j\in [h]$.\medskip


\subsection{Constructing Oracle}\label{sec:construct_oracle} 
We deviate from prior IOP constructions
such as \cite{Ligero2017,Aurora} in the way we construct the oracle. The prior
constructions provided oracle access to linear code encoded messages. We
additionally obtain a homomorphic commitment of the encoding $\enc(x)$ of the
witness $x$ and provide oracle access to the commitment. Concretely, we use a
homomorphic vector commitment scheme $\comm$ with message space $\FF^h$,
commitment space $\GG$ and randomness space $\FF$. We compute commitments
$c_{ik}=\comm(\ewit[i,.,k],\delta_{ik})$ where $\delta_{ik}$ denotes the
commitment randomness. Finally we define $p\times n$ matrix $\comoracle$ as
$\comoracle[i,k]=c_{ik}$. We provide oracle access to $\comoracle$ where for a
query $Q\subseteq [n]$, the oracle responds with columns $\comoracle[.,k]$ for
$k\in Q$.

\subsection{Proximity Protocols}\label{sec:proximityprotocols}
In this section we introduce the notion of {\em well formed} encodings and
describe protocols to check that an encoding is close to a well formed encoding. Let
$\mc{M}_{p,h,n}$ denote the set of $p\times h\times n$ matrices over $\FF$. For
$U,U'\in \mc{M}_{p,h,n}$ define $\Delta_1(U,U')=|\{k\in [n]: U[\cdot,\cdot,k]\neq
U'[\cdot,\cdot,k]\}|$ and $\Delta_2(U,U')=|\{j\in [h]: U[\cdot,j,\cdot]\neq
U'[\cdot,j,\cdot]\}|$. Let $\mc{W}$ denote the subset of $\mc{M}_{p,h,n}$
consisting of matrices $U$ such that $U[i,\cdot,\cdot]\in \rsc{\eta}{\ell}\oplus
\rsc{\alpha}{m}$ for all $i\in [p]$. For $U^\ast\in \mc{M}_{p,h,n}$ define
$d_i(U^\ast,\mc{W})=\min\{\Delta_i(U^\ast,U):U\in \mc{W}\}$ for $i=1,2$.
Further, we define
$d(U^\ast,\mc{W})=\min(d_1(U^\ast,\mc{W}),d_2(U^\ast,\mc{W}))$. In this
section we present an IPCP that allows a prover to convince a verifier that
the oracle $\comoracle$ opens to a three dimensional matrix $\ewit$ such that
$d(\ewit,\mc{W})<e$ for some proximity parameter
$e$. To accomplish the above, we need several tools which we discuss next.
 
\subsubsection{Membership in Product Code:}
We describe a protocol for checking the membership of a matrix in the  product of
two linear codes $L_1$ and $L_2$, given commitments to its columns. More
precisely, let $L_1$ be an $[n,\ell]$ linear code, $L_2$ be an $[h,m]$ linear
code and $\mc{M}_{h,n}$ be the set of $h\times n$ matrices over $\FF$. Let
$\Delta_1$ (resp., $\Delta_2$) be distance metrics on $\mc{M}_{h,n}$ denoting the
number of rows (resp., columns) where the matrices differ. For $U^\ast\in
\mc{M}_{h,n}$ we define $d_i(U^\ast, L_1\oplus L_2) :=
\min\{\Delta_i(U^\ast,U):U\in L_1\oplus L_2\}$ for $i=1,2$. Let $\mc{H}_1$ and $\mc{H}_2$ be the parity check matrices for the
linear codes $L_1$ and $L_2$ respectively. We also define $\mc{C}_1$ and
$\mc{C}_2$ to be the interleaved codes of $L_1$ and $L_2$, where $\mc{C}_1=\ric{L_1}{h}$
and $\mc{C}_2=\cic{L_2}{n}$.  

Assume that $U$ is an $h\times n$ matrix, purported to be a codeword in
$L_1\oplus L_2$. Let $\bar{U}$ denote the $h\times \ell$ matrix consisting of
the first $\ell$ columns of $U$. We note that for $U\in L_1\oplus L_2$, we must
have $U=\bar{U}\mc{T}$ for some $l\times n$ matrix $\mc{T}$ of rank $\ell$. Thus, the membership protocol involves the prover sending the column
commitments $\bm{c}=(c_1,\ldots,c_\ell)$ and prove that they correspond to a matrix
$\bar{U}$ such that $\bar{U}\mc{T}\in \mc{C}_2$ (because $\bar{U}\mc{T}\in
\mc{C}_1$ for all $\bar{U}$). We describe the complete
protocol below:
\begin{figure}[ht]
\begin{framed}
\begin{itemize}
\item {$\proximityTwoD$} $(\FF,\GG, L_1, L_2,\mathbf{c}; \bar{U})$:
\item {\bf Relation}: $\bar{U}=\open(\mathbf{c})$ and $\bar{U}\mc{T}\in \mc{C}_2$.
\begin{enumerate}[{\rm 1.}]
\item $\verifier\rightarrow \prover$: Verifier samples $\tau\sample
\FF^n$, $\delta\sample \FF^{h-m}$ and sends them to the prover.
\item $\prover\leftrightarrow \verifier$ compute: $\mu=\mc{T}\tau$,
$\mathsf{cm} = \sum_{i\in [\ell]} \mu_ic_i$, $x=\mc{H}_2\delta$.
\item $\prover$ computes: $z=\bar{U}\mu$.
\item $\prover$ and $\verifier$ run the subprotocol:
	\begin{itemize}
	\item $b=\innerproduct(\GG,\bm{g},x,\mathsf{cm},0;z)$
	\end{itemize}
\item $\verifier$ accepts if $b=1$.
\end{enumerate}
\end{itemize}
\end{framed}
\caption{Protocol 1}
\label{fig:protocol1}
\end{figure}

In the above,
$\mathbf{InnerProduct}(\GG,\bm{g},x,\mathsf{cm},v;z)$ denotes an interactive
protocol for proving the relation $\innp{x}{z}=v$ and $\open(\mathsf{cm})=z$,
where $\GG$ denotes the commitment group and $\bm{g}$ denotes the generators for
vector commitment. We prove the correctness of the above membership protocol.

\begin{lemma}[Completeness]\label{lem:proximity2d_complete}
For $\bar{U}$ such that $\bar{U}\mc{T}\in \mc{C}_2$, the protocol $\proximityTwoD$ accepts.
\end{lemma}
\begin{proof}
Observe that $\bar{U}\mc{T}\in L_2 \Leftrightarrow (\bar{U}\mc{T})^T\mc{H}_2=\bm{0}$, or
$\mc{T}^T\bar{U}^T\mc{H}_2=\bm{0}$. Thus for any $\tau,\delta$ we have
$\tau^T\mc{T}^T\bar{U}^T\mc{H}_2\delta=0$. The preceeding identity reduces to
$\innp{x}{z}=0$ for  $z=\bar{U}\mc{T}\tau$ and
$x=\mc{H}_2\delta$. Further,
$\comm(z)=\sum_{i\in [\ell]}\mu_ic_i=\mathsf{cm}$ for $\mu=\mc{T}\tau$. The
completeness property of the inner product protocol now guarentees that it
accepts.
\end{proof}
 
\begin{lemma}[Soundness]\label{lem:proximity2d_sound}
For every bounded prover $P^\ast$ and every $\bm{c}\in \GG^n$, there exists an
expected polynomial time extractor $\extr$ with
rewinding access to the transcript oracle $\mc{O}=\langle P^\ast(\bm{c},\cdot),V(\bm{c},\cdot)\rangle$
such that:
\begin{align*}
\condprob{
\begin{array}{l}
\bar{U} = \open(\bm{c}) \wedge \\
\bar{U}\mc{T}\not\in \mc{C}_2
\end{array}
}{
\begin{array}{l}
\sigma\sample \gen(\secparam) \\
\bar{U}\sample \extr^{\mc{O}}(\bm{c},\sigma)
\end{array}}
\geq 
\condprob{\langle P^\ast(\bm{c},\sigma),\verifier(\bm{c},\sigma)\rangle =
1}{\sigma\sample \gen(\secparam)} - \kappa_{2d}(\secpar)
\end{align*}
for a negligible function $\kappa_{2d}$.
\end{lemma}
\begin{proof}
The extractor $\extr$ starts by emulating the verifier in the protocol
$\proximityTwoD$. At the step 4, it uses the extractor $\extr_{ip}$ for the
inner product protocol to extract the witness $z$ for the $\innerproduct$
subprotocol. If the initial transcript rejects, $\extr$ fails with output
$\bot$. Otherwise, it rewinds transcript to step (1) till it finds $\ell$
additional accepting transcripts. Let $\tau^i,\delta^i$ denote the random
vectors in step 1, in the $i^{th}$ accepting transcript (we let $i=0$ denote the
initial transcript). Similarly, let $x^i$, $\mathsf{cm}^i$ denote the values of
vectors $x$ and $\mathsf{cm}$ in the $i^{th}$ accepting transcript, while $z^i$
denotes the witness extracted by the inner product extractor $\extr_{ip}$
corresponding to $x^i$ and $\mathsf{cm}^i$. If the inner product extractor
$\extr_{ip}$ fails with $z^i=\bot$ for any $i\in [\ell]$, the extractor $\extr$
fails with output $\bot$. From the inner product extractions we have the
following:
\begin{align*}
\begin{array}{cccc}
\comm(z^1)=&  \mu^1_1c_1+ & \hdots & +\mu^1_{\ell}c_{\ell} \\
\vdots & \vdots & \ddots & \vdots \\
\comm(z^l)=& \mu^{\ell}_1c_1+ & \hdots & +\mu^{\ell}_{\ell}c_{\ell} 
\end{array}
\end{align*}
Let $\Lambda$ denote the $\ell\times \ell$ matrix with $\Lambda[i,j]=\mu^i_j$.
Since $\mc{T}$ is a rank $\ell$ matrix, we see that $\Lambda$ is an invertible
matrix for random choices of vectors $\tau^i$, except with probability
$1/|\FF|$. Let $\Omega$ be the $\ell\times \ell$ matrix such that
$\Omega\Lambda=I_{\ell}$. Define $U_k = \sum_{i\in [\ell]}\Omega[k,i]z^i$ for
$k\in [\ell]$. Then we have,
\begin{align*}
\comm(U_k) &= \sum_{i\in [\ell]}\Omega[k,i]\comm(z^i)  \\
	&= \sum_{i\in [\ell]}\Omega[k,i]\sum_{j\in [\ell]}\mu^i_jc_j \\
	&= \sum_{j\in [\ell]}\big(\sum_{i\in [\ell]}\Omega[k,i]\mu^i_j\big)c_j \\
	&= \sum_{j\in [\ell]}\big(\sum_{i\in [\ell]}\Omega[k,i]\Lambda[i,j]\big)c_j
\\
	&= c_k \text{ (using $\Omega\Lambda=I_{\ell})$ }
\end{align*}
Thus $\bar{U}=(U_1,\ldots,U_{\ell})$ satisfies $\open(U)=\bm{c}$. Now we
consider the probability that $\bar{U}\mc{T}\in \mc{C}_2$. Let $A$ denote the event
that the first transcript accepts. Let $B\subseteq A$ be the event that
$(\bar{U}\neq\bot)\cap (\bar{U}\mc{T}\in \mc{C}_2)$. We have,
\begin{align*}
\prob{B} &= \prob{A} - \prob{A\cap \neg B} \\
	&\geq \prob{A} - \prob{A\cap (\bar{U}=\bot)} - \prob{A\cap
(\bar{U}\mc{T}\not\in \mc{C}_2)} \\
	&= \prob{A} - \prob{A\cap (\bar{U}=\bot)} - \prob{A\cap
(\mc{T}^T\bar{U}^T\mc{H}_2\neq 0)} \\
	&\geq \prob{A} - \prob{A\cap (\bar{U}=\bot)} -
\condprob{\tau^T\mc{T}^T\bar{U}^T\mc{H}_2\delta=
0}{\mc{T}^T\bar{U}^T\mc{H}_2\neq 0} \\
	&\geq \prob{\langle P^\ast(\bm{c},\sigma),\verifier(\bm{c},\sigma)\rangle=1}
- \big(\ell.\kappa_{ip}(\secpar)+1/|\FF|\big) - 2/|\FF|
\end{align*} 
In the above, we bound the probability $\condprob{\tau^T\mc{T}^T\bar{U}^T\mc{H}_2\delta=
0}{\mc{T}^T\bar{U}^T\mc{H}_2\neq 0}$ by $2/|\FF|$ as $\tau$ and $\delta$ are
distributed uniformly and independently of the extracted witness $\bar{U}$. The
probability $\prob{A\cap (\bar{U}=\bot)}$ is bound in terms of the probability
of inner product extractor returning an invalid witness or $\Lambda$ being
singular which is at most $\ell.\kappa_{ip}(\secpar)+1/|\FF|$. The
statement of the lemma now holds by setting
$\kappa_{2d}(\secpar):=\ell.\kappa_{ip}(\secpar) + 3/|\FF|$.
\end{proof}

\subsubsection{Proximity to Well Formed Oracle}: We now describe the protocol
that allows a prover to prove that oracle $\comoracle$ opens to a three
dimensional matrix $\ewit\in \mc{M}_{p,h,n}$ which is close to a well formed
encoding. To minimize communication, the key idea is that the verifier chooses
$r\sample \FF^p$ and asks the prover to send commitments to the two dimensional
matrix $\tilde{U}:=\sum_{i\in [p]}r_i\ewit[i,\cdot,\cdot]$, i.e,
$\tilde{U}[j,k]=\sum_{i\in [p]}r_i\ewit[i,j,k]$. Thereafter we use the protocol
$\proximityTwoD$ to check that $\tilde{U}\in L_1\oplus L_2$ where
$L_1=\rsc{\eta}{\ell}$ and $L_2=\rsc{\alpha}{m}$. The soundness of the overall
protocol follows from the fact that if $\ewit$ is far from a well formed
encoding, with high probability $\tilde{U}$ is far from $L_1\oplus L_2$.
Additionally, we also have to ascertain that the column commitments to
$\tilde{U}$ are consistent with $\comoracle$ with minimal communication. The
protocol description follows:
\begin{figure}[h!]
\begin{framed}
\begin{itemize}
\item {$\proximityThreeD(\FF,L_1,L_2,e,[\pi];\ewit)$}
\item {\bf Relation}: $\ewit=\open(\pi)$, $\ewit\in \mc{W}$.
\item {\bf Oracle Setup}: Prover computes $\comoracle$ from $\ewit$ as in
Section \ref{sec:construct_oracle} and sets
$\pi := \comoracle$ as the oracle.
\begin{enumerate}[{1.}]
\item $\verifier\rightarrow \prover$: Verifier samples $r\sample \FF^p$ and
sends $r$ to $\prover$.
\item $\prover$ computes: 
	\begin{itemize}
	\item $\tilde{U}=\sum_{i\in [p]}r_i\ewit[i,\cdot,\cdot]$.
	\item $\tilde{c}_k = \sum_{i\in [p]}r_i\comoracle[i,k]$ for $k\in [\ell]$.
	\end{itemize}
\item $\prover\rightarrow \verifier$: Prover sends
$\tilde{\bm{c}}=(\tilde{c}_1,\ldots,\tilde{c}_\ell)$ to the verifier.
\item $\prover \text{ and } \verifier$: Prover and verifier run the subprotocol:
	\begin{itemize}
	\item $b=\proximityTwoD(\FF,L_1,L_2,\tilde{\bm{c}};\tilde{U})$
	\end{itemize}
\item $\verifier$ queries: Verifier samples $Q\subseteq [n]$ of size
$t$ and makes oracle queries for positions in $Q$.
\item Oracle Answers: The oracle responds with columns $\pi[.,k]$ for
$k\in Q$.
\item $\verifier$ checks: The verifier checks $\sum_{i\in
[p]}r_i\pi[i,k]=\sum_{i\in [\ell]}\mc{T}[i,k]\tilde{c}_i$ for $k\in Q$ (the matrix $\mc{T}$ as defined earlier).
\item $\verifier$ accepts if the check passes and $b=1$.
\end{enumerate}
\end{itemize}
\end{framed}
\caption{Protocol 2}
\end{figure}

\begin{lemma}[Completeness]\label{lem:proximity3d_complete}
For $\ewit\in\mc{W}$, the protocol $\proximityThreeD$ accepts.
\end{lemma}
\begin{proof}
The assertion follows from the fact that $\ewit\in \mc{W}$ and
$\ewit=\open(\comoracle)$ implies $\tilde{U}\in L_1\oplus L_2$ and
$\tilde{U}=\open(\tilde{\mathbf{c}})$, and from the completeness of the protocol
$\proximityTwoD$.
\end{proof}

\begin{lemma}[Soundness]\label{lem:proximity3d_sound}
For every bounded prover $P^\ast$ and every oracle $\pi\in \FF^{p\times n}$,
there exists a polynomial time extractor $\extr$ with rewinding access to
transcript oracle $\mc{O}=\langle P^\ast(\cdot),\verifier^{\pi}(\cdot)\rangle$
such that:
\begin{align*}
\condprob{
\begin{array}{l}
\ewit=\open(\pi) \wedge \\
d(\ewit,\mc{W})>e
\end{array}
}{
\begin{array}{l}
\sigma\sample \gen(\secparam)\\
\ewit\sample \extr^{\mc{O}}(\sigma)
\end{array}
}\geq \condprob{\langle
P^\ast(\sigma),\verifier^\pi(\sigma)\rangle=1}{\sigma\sample
\gen(\secparam)}-s_{3d}(\secpar)
\end{align*}
for some negligible function $s_{3d}$. Note that in the above, $\extr$ can
rewind and proceed with fresh queries to the oracle $\pi$. 	
\end{lemma}
\begin{proof}
As before the extractor $\extr$ emulates the verifier in the protocol
$\proximityThreeD$. In case the first transcript is accepting, the extractor
rewinds the prover sufficiently many times to obtain a tree of accepting transcripts with $p$ distinct
choices of the randomness $r$ in step (1) and $\theta := tn$ different values of $Q$
on step (5). Let $r^{1},\ldots,r^{p}$ denote the values of $r$ in step (1)
and let $\tilde{\mathbf{c}}^{1},\ldots,\tilde{\mathbf{c}}^{p}$ denote the corresponding
commitment vectors in step (3). Similarly, let $Q^{uv}$ denote the $v^{th}$
choice of $Q$ corresponding to $u^{th}$ value of $r$ for $u\in [p]$ and $v\in
[\theta]$. We do not consider the initial transcript as part of the tree of
transcripts. We notice that we have $\cup_{v\in [\theta]}Q^{uv}=[n]$ for all
$u\in [p]$, except with probability at most $pn(1-1/n)^{nt}\leq pne^{-t}$. At
step (4), $\extr$ uses extractor $\extr_{2d}$ for the protocol $\proximityTwoD$
to extract $h\times \ell$ matrix $W^{u}$ for $u\in [p]$. The extractor $\extr$ fails with output $\bot$
if $\extr_{2d}$ fails in any of its invocations. By the property of $\extr_{2d}$
we have that $\open(\tilde{\bm{c}}^u)=W^u$ and $W^u\in L_1\oplus L_2$ for all
$u\in [p]$. We construct the witness $\ewit$ by solving for each $h$-length
vector $\ewit[i,\cdot,k]$ for $i\in [p], k\in [n]$ according to
\eqref{eq:extraction3d}. Let $T_1,\ldots,T_n$ denote the columns of matrix
$\mc{T}$. 
\begin{align}\label{eq:extraction3d}
\text{For each $k\in [n]$ we have:}  \nonumber \\
\begin{array}{cccc}
r^1_1\ewit[1,\cdot,k]+ &\hdots & +r^1_p\ewit[p,\cdot,k] &= W^1T_k \\
\vdots & \ddots & \vdots & \vdots \\
r^p_1\ewit[1,\cdot,k]+ &\hdots & +r^p_p\ewit[p,\cdot,k] &= W^pT_k 
\end{array}
\end{align}
Let $\Lambda$ denote the $p\times p$ matrix with $\Lambda[i,j]=r^i_j$. We may
assume that $\Lambda$ is invertible, except with probability $1/|\FF|$. Let
$\Omega$ be such that $\Omega\Lambda = I_p$. It can be seen that the system of
equations \eqref{eq:extraction3d} is satisfied by setting $\ewit[i,\cdot,k]=\sum_{j\in
[p]}\Omega[i,j]W^jT_k$ for $i\in [p],k\in [n]$. First we prove that
$\comm(\ewit[i,\cdot,k])=\pi[i,k]$ for all $i$ and $k$. Indeed,
\begin{align*}
\comm(\ewit[i,\cdot,k]) & =\sum_{j\in [p]}\Omega[i,j]\comm(W^jT_k) \\
	& = \sum_{j\in [p]}\Omega[i,j]\sum_{a\in [\ell]}\mc{T}[a,k]\comm(W^j[.,a]) \\
	& = \sum_{j\in [p]}\Omega[i,j]\sum_{a\in
[\ell]}\mc{T}[a,k]\tilde{\bm{c}}^j_a \\
	& = \sum_{j\in [p]}\Omega[i,j]\sum_{a\in [p]}r^j_a\pi[a,k] \text{ (using check
(7)) } \\
	& = \sum_{a\in [p]} \big(\sum_{j\in [p]}\Omega[i,j]\Lambda[j,a]\big)\pi[a,k]
\\
	& = \pi[i,k]
\end{align*}

Next we compute the probability that $d(U,\mc{W})\leq e$. Note that the columns
$\ewit[i,\cdot,k]$ are linear combinations of the columns of extracted matrices
$W^u, u\in [p]$ which are codewords in the code $L_2$. Thus, each column
$\ewit[i,\cdot,k]$ in the extracted witness $\ewit$ is a codeword in $L_2$. Thus
$d_2(\ewit,\mc{W})=0$, and hence $d(U,\mc{W})=d_1(U,\mc{W})$. We define the
following events of interest:
\begin{itemize}
\item $A$: denotes the event that the first transcript is accepting. By
definition, $\prob{A}$ is the accepting probability $\prob{\langle
P^\ast(\sigma),\verifier(\sigma)\rangle=1}$.
\item $B$: denotes the sub-event of $A$ when the extracted opening $\ewit$ to the
commitment oracle $\pi$ is valid, i.e $d(\ewit,\mc{W})<e$. 
\item $F_1$: denotes the event that $\extr$ fails with output $\bot$. This
happens when one of the invocations subprotocol extractor $\extr_{2d}$ fails, or
unlikely events that the matrix $\Lambda$ is singular, or that $\theta=tn$
repetitions of the random query locations $Q$ fail to cover the set of indices
$[n]$. As discussed in the proof, we can bound $\prob{F_1}$ by
$p\kappa_{2d}(\secpar) + pne^{-t} + 1/|\FF|$. 
\end{itemize}
Using an analysis similar to the one in the proof of Lemma
\ref{lem:proximity2d_sound}, we have:
\begin{equation}\label{eq:probeq1}
\prob{B}\geq \prob{A} - \prob{F_1} - \condprob{A}{d_1(\ewit,\mc{W})>e}   
\end{equation}
Let $\tilde{\bm{c}}=(\tilde{c}_1,\ldots,\tilde{c}_\ell)$ denote the vector sent
by the prover in step (3). We consider the vector $n$-length vector $C_{adv}$
defined by $C_{adv}[k]=\sum_{i\in [\ell]}\mc{T}[i,k]\tilde{c}_i$ for $k\in [n]$. Let
$C_{hon}$ denote the honestly computed vector defined by $C_{hon}[k]=\sum_{i\in
[p]}r_i\pi[i,k]$. Note that for honest oracle $\pi\in\mc{W}$ and honest prover
we would have $C_{adv}=C_{hon}$. Let $\varepsilon := \Delta(C_{adv},C_{hon})$ denote the
hamming distance between the two vectors. Now we can write
$\condprob{A}{d_1(\ewit,\mc{W})>e}$ as:
\begin{align}\label{eq:probeq3}
\condprob{A}{d_1(\ewit,\mc{W})>e} &\leq \max(\condprob{A}{d_1(\ewit,\mc{W})>e,
\varepsilon \leq e},\condprob{A}{d_1(\ewit,\mc{W})>e, \varepsilon > e})
\end{align}
The above follows from the identity $\condprob{A}{X}\leq
\max(\condprob{A}{X_1},\condprob{A}{X_2})$ for $X=X_1\uplus X_2$. Next we note
that for $\varepsilon > e$, the check in step 7, succeeds with probability at most
$(n-e)^t/n^t=(1-e/n)^t$. Thus $\condprob{A}{d_1(\ewit,\mc{W})>e,\varepsilon > e}\leq
(1-e/n)^t$. Next we bound $\condprob{A}{d_1(\ewit,\mc{W})>e,\varepsilon\leq e}$.
With probability at least $1-\kappa_{2d}(\secpar)$, the extractor $\extr_{2d}$
produces a witness $\bar{U}$ such that $\bar{U}\mc{T}\in L_1\oplus L_2$, and
$\bar{U}=\open(\tilde{\bm{c}})$.  Let
$U_{adv} = \bar{U}\mc{T}$ denote the codeword in $L_1\oplus L_2$. We note that
$U_{adv}=\open(C_{adv})$. Define $U_{hon}=\sum_{i\in [p]}r_i\ewit[i,.,.]$. Note
that $U_{hon}=\open(C_{hon})$ by homomorphism of the commitment scheme. Since
$\varepsilon=d(C_{adv},C_{hon})\leq e$, we must have:
\begin{enumerate}[{\rm (i)}]
\item $\Delta_1(U_{adv},U_{hon})\leq e$ or,
\item There exists an index $j\in [n]$ such that $C_{adv}[j]=C_{hon}[j]$, but
their corresponding openings $U_{adv}[j]$ and $U_{hon}[j]$ are different. This
constitutes breakage to the binding property of the commitment scheme $\comm$. 
\end{enumerate}
Assuming $\Delta_1(U_{adv},U_{hon})\leq e$, we have $d_1(U_{hon},\mc{C}_1)\leq
e$. From the above, we can now write:
\begin{equation}\label{eq:probeq4}
\condprob{A}{d_1(\ewit,\mc{W})>e,\varepsilon\leq e}\leq
\condprob{d_1(U_{hon},\mc{C}_1)\leq e}{d_1(\ewit,\mc{W})>e} + \mc{B}(\secpar)
\end{equation}
Since $U_{hon}=\sum_{i\in [p]}r_i\ewit[i,\cdot,\cdot]$, from Lemma
\ref{lem:3dcompression}, we have $\condprob{d_1(U_{hon},\mc{C}_1)\leq
e}{d_1(\ewit,\mc{W})>e}<d_1/|\FF|$ where $d_1$ is the minimum distance of the
code $L_1$. Thus, Equation \eqref{eq:probeq3} gives us
\begin{equation}\label{eq:probeq5}
\condprob{A}{d_1(\ewit,\mc{W})>e}\leq \max\left\{\left(1-\frac{e}{n}\right)^t,
\frac{d_1}{|\FF|}+\kappa_{2d}(\secpar) + \mc{B}(\secpar)\right\}
\end{equation}
From Equations \eqref{eq:probeq1} and \eqref{eq:probeq5} we see that the
statement of the Lemma holds for 
\[\kappa_{3d}(\secpar) := (p+1)\kappa_{2d}(\secpar) + pne^{-t} +
\left(1-\frac{e}{n}\right)^t + \frac{d_1+1}{|\FF|} + \mc{B}(\secpar) \]
\end{proof}

\subsection{Linear Check Protocol}
In this section, we describe an IPCP that allows a prover to prove knowledge of
witness $\wit\in \FF^N$ satisfying a linear constraint of the form $A\wit = b$
for some $A\in \FF^{M\times N}$ and $b\in \FF^M$. As before we veiw $\wit$ as
$p\times m\times \ell$ matrix where $N=pm\ell$. 

\subsubsection{Linear Check}
We now describe a protocol to check that a purported commitment oracle
$\comoracle$ encodes witness $x$ satisfying the constraint $Ax=0$ for a public
matrix $A$. As before we assume $x\in \FF^N$ and $A\in \FF^{N\times N}$ and
$N=pm\ell$ for some positive integers $p,m$ and $\ell$. We further assume that
the prover has RS-encoded oracle $\rsoracle$ which opens to the commitment
$\comoracle$ and is $e$-close to the interleaved codes $L_1^{pm}$ and
$L_2^{pn_1}$. The prover and the verifier interact as follows:
\begin{enumerate}[{\rm 1.}]
\item $\verifier\rightarrow\prover$: The verifier sends a random $r\sample
\FF^N$ and random $\tau\sample \FF^{n_1}$ to the prover.
\item $\prover\rightarrow\verifier$: The prover computes as follows:
\begin{itemize}
\item interpolates bivariate polynomials $R^i:i\in [p]$ such that the polynomial $R^i$ interpolates the
vector $(r_{(i-1)mn+1},\ldots,r_{imn})$ for $i\in [p]$. 
\item computes polynomials $p_j(.)=\sum_{i\in [p]}R^i(\alpha_j,.)Q^i(\alpha_j,.)$ for
$j\in [n_2]$. 
\item evaluates the polynomials $p_j$ on the set
$\bm{\eta}=\{\eta_1,\ldots,\eta_{n_1}\}$. Let $P$ denote the $n_2\times n_1$
matrix whose $j^{th}$ row is the evaluation of the polynomial $p_j$ on the set
$\eta$. 
\item computes commitments $d_1,\ldots,d_{2\ell}$ to the first
$2\ell$ columns of $P$.
\end{itemize}
\begin{equation}
P := \begin{bmatrix}
p_1(\eta_1) & \cdots & p_1(\eta_{2\ell}) & \vline & \cdots &
p_1(\eta_{n_1}) \\
\vdots & \ddots & \vdots & \vline & \ddots & \vdots \\
p_{n_2}(\eta_1) & \cdots & p_{n_2}(\eta_{2\ell}) & \vline & \cdots &
p_{n_2}(\eta_{n_1})
\end{bmatrix}
\end{equation}
Note that there exists a $2\ell\times n_1$ matrix $T$ such that $P'T = P$ where $P'$ denotes
the submatrix of $P$ consisting of first $2\ell$ columns. Thus the commitments
to other columns of $P$ can be computed from $d_1,\ldots,d_{2\ell}$ using
homomorphism.
The prover sends the commitments $d_1,\ldots,d_{2\ell}$ and the polynomial
$p(x)=\sum_{j\in[m]} p_j(x)$ to the verifier.
\item $\verifier\rightarrow\prover$: The verifier samples $t$ distinct indices
$k_1,\ldots,k_t$ from the set $[n_1]$. It also picks $t$ indices
$j_1,\ldots,j_t$ from the set $[n_2]$ independently at random. Finally the
verifier sends the pairs $\{(j_u,k_u):u\in [t]\}$ to the prover.
\item $\prover\rightarrow\verifier$: The prover sends $t$ ``tubes''
$\rsoracle[.,j_u,k_u]$ for $u\in [t]$ to the verifier. Recall that
$\rsoracle[.,j_u,k_u]$ denotes the $p$-length vector
$(\rsoracle[1,j_u,k_u],\ldots,\rsoracle[p,j_u,k_u])$. The prover also sends the
columns $\comoracle[.,k_u]$ for $u\in [t]$ of the oracle $\comoracle$. 
\item The verifier proceeds as:
\begin{itemize}
\item It checks $\sum_{k\in [\ell]}p(\zeta_k)=0$.
\item It runs a proximity protocol to check that $P$ is $e$-close to
a bivariate interleaved code corresponding to Reed-Solomon codes of degrees
$2\ell$ and $2m$ respectively.
\item Checks that $p=\sum_{j\in n_2}p_j$.
\item It checks $P[j,k]=\sum_{i\in [p]}R^i(\beta_j,\eta_k)\rsoracle[i,j,k]$ for
$(j,k)\in \{(j_u,k_u):u\in [t]\}$.
\item It checks consistency of the openings $\rsoracle[.,j_u,k_u]$ with
commitment oracle $\comoracle$ for $u\in [t]$. 
\end{itemize}
\item The verifier accepts if all the above checks succeed.
\end{enumerate}
We now describe in detail each of verifier's checks in the final step of the
above interaction.\smallskip

\noindent{\em Checking proximity of matrix $P$}: Note that an honestly computed
matrix $P$ in the above protocol forms a bivariate interleaved codewords where
the rows correspond to evaluation of polynomials of degree $<2\ell$ and columns
correspond to evaulations of polynomials of degree $<2m$. Using matrix $T$ the
verifier can homomorphically compute the commitments to the columns of
purported matrix $P$ and then check proximity using the proximity protocol
described in Section \ref{sec:proximitybic}. Here we describe an optimized
version where the verifier need not compute all the column commitments of $P$. 
We consider the protocol of Section \ref{sec:proximitybic}, where the prover
sends commitments $d_1,\ldots,d_{2\ell}$ in its first message (instead of $n_1$
commitments). The prover and verifer proceed exactly as the proximity protocol.
In testing the proximity to the interleaved code along rows, the verifier needs
to compute the commitment to the vector $\sum_{k\in Q_1}\delta_kU[.,k]$. The
verifier computes the commitment as $\sum\lambda_kd_k$ where
$(\lambda_1,\ldots,\lambda_t)^T = T|_{Q_1}\delta$. Similarly for computing
commitment for the vector $w_2=P\tau$, for random $\tau\sample \FF^{n_1}$, the
verifier computes the commitment to $w_2$ as $\sum_{k\in
[2\ell]}\gamma_kd_k$ where $(\gamma_1,\ldots,\gamma_{2\ell})^T=T\tau$. Note
that naively computing commitments to all the columns would have required
$O(\ell m)$ cryptographic operations, while in the current scheme we only need
$O(m)$ cryptographic operations.\smallskip

\noindent{\em Checking consistency of $p$ with $P$}: To check that $p=\sum_{j\in
n_2}p_j$, the verifier evaluates $p$ on $\eta_1,\ldots,\eta_{2\ell}$ to obtain the
evaluation vector $\bar{p}$. The verifier now needs to verify
$\bar{p}=\bm{1}^TP'$ where $P'$ denotes the submatrix consisting of the first
$2\ell$ columns of $P$, which probabilistically reduces to inner product check
$\innp{\bm{1}}{P's}=\innp{\bar{p}}{s}$ for a randomly sampled $s\sample
\FF^{2\ell}$. For the inner product protocol, the verifier can homomorphically compute the commitment to the
vector $P's$ given $d_1,\ldots,d_{2\ell}$.\smallskip

\noindent{\em Checking consistency of $P$ with $\rsoracle$}: The checks
$P[j,k]=\sum_{i\in [p]} R^i(\beta_j,\eta_k)\rsoracle[i,j,k]$ probabilistically
verify the computation of $P$ from the $\rsoracle$ by probing a few locations
$(j_u,k_u)$ for $u\in [t]$. Since $P[j,k]=\innp{P[.,k]}{e_j}$, and the verifier
can compute commitment for $P[.,k]$ the required checks can be accomplished by
running $t$ instances of the inner product arguments.\smallskip


\noindent{\em Checking consistency of openings of $\rsoracle$ with
$\comoracle$}: Consider $(j,k)\in \{(j_u,k_u):u\in [t]\}$. To check the
consistency of the opened tube $\rsoracle[.,j,k]$, verifier checks
$\innp{\rsoracle[i,.,k]}{e_j}=\rsoracle[i,j,k]$ for all $i\in [p]$. This can be
checked probabilistically by randomly sampling $v\in \FF^p$ and checking
$\innp{\sum_{i\in [p]}v_i\rsoracle[i,.,k]}{e_j}=\innp{v}{\rsoracle[.,j,k]}$.
The commitment to the vector $\sum_{i\in [p]}v_i\rsoracle[i,.,k]$ can be
computed homomorphically as $\sum_{i\in [p]}v_i\comoracle[i,j]$. Similar
consistency check can be done for all $t$ tubes.

\begin{lemma}\label{lem:linchecksound}
Let $\rsoracle$ be an RS-encoded oracle where $U^\ast=\decode(\rsoracle)$ is
an encoding of $x$ s.t $Ax\neq 0$. Then any bounded prover $\pdv^\ast$ which
commits $\rsoracle$ as $\comoracle$ succeeds in the linear check protocol with
negligible proabability.
\end{lemma}
\begin{proof}
To simplify the proof, we assume that the prover $\pdv^\ast$ does not violate the
binding property of the commitment scheme $\comm$, i.e, it opens appropriate
homomorphic combinations of the committed vectors and does not break the
soundness of the inner product protocols. The verifier checks the
following in the linear check protocol:
\begin{enumerate}
\item Openings $\rsoracle[.,j,k]$ are consistent with $\comoracle$ for
$(j,k)\in \{(j_u,k_u):u\in [t]\}$.
\item The matrix $P$ satisfies $\Delta_1(P,L_1^{n_2})<e$ and
$\Delta_2(P,L_2^{n_1})<e$.
\item The matrix $P$ is correctly computed from the oracle $\rsoracle$ and
vector $r\in \FF^N$.
\item The polynomial $p$ is correctly computed from the matrix $P$.
\item The polynomial $p$ satisfies $\sum_{k\in \ell}p(\zeta_k)=0$.
\end{enumerate}
By assumption that prover does not know two openings to a commitment, the
openings $\rsoracle[.,j,k]$ in the first check are honest. Let $P^\ast$ denote
honestly computed matrix from $U^\ast$ and $p^\ast$ denote honestly computed
polynomial from $P^\ast$. Since $P$ satisfies the proximity checks, with
overwhelming probability Lemma \ref{lem:bicdecoding} implies that there exists bivariate codeword $\bar{P}$ such that
$\Delta_1(P,\bar{P})<e$ and $\Delta_2(P,\bar{P})<e$. We consider two cases,
viz, $\bar{P}=P^\ast$ and $\bar{P}\neq P^\ast$ and show that $\pdv^\ast$
succeeds with negligible probability in both the cases. 

First, assume that $\bar{P}=P^\ast$. Thus we have $\Delta_1(P,P^\ast)<e$. If
the polynomial $p$ sent by $\pdv^\ast$is the same as the polynomial $p^\ast$, we have $\sum_{k\in
[\ell]} p(\zeta_k) = \sum_{k\in [\ell]} p^\ast(\zeta_k)\neq 0$ as $U^\ast$
encodes $x$ such that $Ax\neq 0$. Thus $\pdv^\ast$ fails if $p=p^\ast$. Assume,
then that $p\neq p^\ast$. Let $K$ denote the column indices where $P$ and
$P^\ast$ agree. By assumption, $|K|>n_1-e$. For all $k\in K$ we have
$p(\eta_k)=p^\ast(\eta_k)$. Since the polynomials $p$ and $p^\ast$ are of
degree $<2\ell$, this is a contradiction when $n_1-e\geq 2\ell$. Thus an
adverserial prover $\pdv^\ast$ fails when $\bar{P}=P^\ast$.

Now consider the case when $\bar{P}\neq P^\ast$. Then, by the distance
properties of the codes $L_1^{n_2}$ and $L_2^{n_1}$ and Lemma
\ref{lem:bicdecoding}, we must have $\Delta_1(P,P^\ast)>n_1-e$ or
$\Delta_2(P,P^\ast)>n_2-e$. Without loss of generality, assume the
former. Let $E_u$ denote the event $\pdv^\ast$ succeding on query $(j_u,k_u)$
for $u\in [t]$. Since $P$ and $P^\ast$ differ in at least $n_1-e$ columns
and $P$ and $\bar{P}$ differ in at most $e$ columns, we conclude that $\bar{P}$
and $P^\ast$ differ in at least $n_1-2e$ columns. Let $X$ denote the indices of
the $n_1-2e$ columns where $P$ and $\bar{P}$ agree, while $P^\ast$ differs from
them. For $k_u\in X$,  $\pdv^\ast$ succeeds if
$$P[j_u,k_u]=\bar{P}[j_u,k_u]=P^\ast[j_u,k_u]=\sum_{i\in
[p]}R^i(\beta_{j_u},\eta_{k_u})\rsoracle[i,j_u,k_u].$$
Since the columns of $\bar{P}$ and $P^\ast$ are evaluations of polynomials of
degree $<2m$, the above succeeds with probability $2m/n_2$. Thus we have:
\begin{align*}
\prob{E_u}\leq \frac{2e}{n_1}+\frac{n_1-2e}{n_1}.\frac{2m}{n_2}
\end{align*}
The probability that the verifier succeeds on all queries is then:
\begin{align}
\prob{\bigwedge_{u\in [t]}E_u}\leq
\left(\frac{2e}{n_1}+\frac{n_1-2e}{n_1}.\frac{2m}{n_2}\right)^t.
\end{align}
The above probability is negligible in $\secpar$ for $t=O(\secpar)$. This completes the
proof of soundness of the linear check.
\end{proof}


\subsubsection{Quadratic Check}\label{sec:quadcheck}
We now describe the interactive oracle protocol for checking the relation
$x\circ y = z$ for vectors $x,y,z\in \FF^N$. Let $\rsoracle_x,\rsoracle_y$ and
$\rsoracle_z$ denote the encodings of vectors $x$, $y$ and $z$ respectively via
the bivariate code. Let $\comoracle_x,\comoracle_y$ and $\comoracle_z$ denote
the respecitve commitment oracles. The prover and the verifier interact as
follows:

\begin{enumerate}[{\rm 1.}]
\item $\verifier\rightarrow\prover$: The verifier sends a challenge $r\sample
\FF^p$ to the prover.
\item $\prover\rightarrow\verifier$: The prover computes as follows:
  \begin{itemize}
  \item For $j\in [n_2]$, $p_j(.)=\sum_{i\in [p]}
r_i(Q^i_x(\alpha_j,.).Q^i_y(\alpha_j,.)-Q^i_z(\alpha_j,.))$.
  \item Constructs $n_2\times n_1$ matrix $P$, where the $j^{th}$ row of $P$
consists of evaluations of the polynomial $p_j$ on the points
$\eta_1,\ldots,\eta_{n_1}$.
  \item Computes commitments $d_1,\ldots,d_{2\ell}$ to the first $2\ell$
columns of $P$.
  \end{itemize}
The prover sends the commitments $d_1,\ldots,d_{2\ell}$ to the verifier.

\item $\verifier\rightarrow\prover$: The verifier sends $\gamma\in \FF^m$ and
$t$ randomly sampled pairs $\{(j_u,k_u),u\in [t]\}$ from $[n_2]\times [n_1]$. 

\item $\prover\rightarrow\verifier$: The prover sends the polynomial
$p(.)=\sum_{j\in [m]}\gamma_j.p_j(.)$, the tubes $\rsoracle_a[.,j_u,k_u]$,
 the columns $\comoracle_a[.,k_u]$ for $a\in\{x,y,z\}$ and $u\in [t]$.

\item The verifier proceeds as:
  \begin{itemize}
  \item Checks that $p(\zeta_k)=0$ for all $k\in [l]$.
  \item Checks that $P$ is $e$-close to bivariate interleaved code with
corresponding Reed-Solomon codes of dimensions $2\ell$ and $2m$ respectively.
  \item Checks that $p=\sum_{j\in [m]}\gamma_jp_j$.
  \item Checks that $P[j,k]=\sum_{i\in
[p]}r_i(\rsoracle_x[i,j,k].\rsoracle_y[i,j,k]-\rsoracle_z[i,j,k]$ for $(j,k)\in
\{(j_u,k_u):u\in [t]\}$.
  \item Checks the consistency of openings $\rsoracle_a[i,j_u,k_u]$ for $a\in
\{x,y,z\}$ and $u\in [t]$ with the commitment oracles $\comoracle_a$.
  \end{itemize}
The verifier accepts if all the checks succeed.

\end{enumerate}


\begin{lemma}\label{lem:quadhecksound}
Let $\rsoracle = [\rsoracle_x,\rsoracle_y,\rsoracle_z]$ be an RS-encoded oracle where $U^\ast=\decode(\rsoracle)$ is
an encoding of $[x,y,z]$ s.t $x\circ y\neq z$. Then any bounded prover $\pdv^\ast$ which
commits $\rsoracle$ as $\comoracle$ succeeds in the quadratic check protocol with
negligible proabability.
\end{lemma}


\subsection{Non-interactive}
IOP to NIROP
