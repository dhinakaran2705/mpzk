\documentclass[runningheads]{llncs}
\input{packages.tex}
\input{style.tex}

\def\commit{\mathsf{Commit}}
\def\open{\mathsf{Open}}
\def\eval{\mathsf{Eval}}
\def\pp{\mathsf{pp}}
\def\bitset{\{0,1\}}
\def\ppt{\mathsf{PPT}}
\def\prover{\mathsf{P}}
\def\verifier{\mathsf{V}}
\def\coins{\mathsf{coins}}
\begin{document}
\section{DPZK from Polynomial IOP zkSNARK}
\subsection{Polynomial commitment scheme}
We will start with defining the notion of polynomial commitment scheme. The notion of polynomial commitment scheme was given by kate et al. \cite{KGZ10} later generalized in \cite{DARK19}.
\begin{definition}[Polynomial Commitment]\label{defn:polycomm}
A polynomial commitment scheme is a tuple of protocols $\Gamma =(\setup, \commit, \open, \eval)$ where $(\setup, \commit, \open)$ is a binding commitment scheme for a message space $R[X]$ of polynomials over some ring $R$, and 
\\ $\eval(\pp, c, z, y, \mu; f(X)) \rightarrow b \in \bitset$ is an interactive public coin protocol between a $\ppt$ prover $\prover$ and verifier $\verifier$. Both $\prover$ and $\verifier$ have as input a commitment $c$, points $z,y\in R$, and a degree $d$. The prover additionally knows the opening of $c$ to a secret polynomial $f(X)\in R[X]$ with deg$(f(X))\leq d$. The protocol convinces the verifier that $f(z)=y$. In a multivariate extension of polynomial commitments, the input $\mu > 1$ indicates the number of variables in the committed polynomial and $z\in R^{\mu}$.  
\end{definition}

A polynomial commitment scheme is \textbf{correct} if an honest committer can successfully convince the verifier of any evaluation. Specifically, if the prover is honest then for all polynomials $f(X) \in R[X]$ and all points $z\in R$,
\begin{align*}
\condprob{b=1}{
	\begin{array}{l}
	\pp \leftarrow \setup (\secparam); \\
	(c;r)\leftarrow\commit(\pp, f(X)); \\
	y \leftarrow f(z);\\
	d \leftarrow deg(f(X));\\
	b\leftarrow \eval(\pp, c,z,y,d;f(X),r)
	\end{array}
} = 1
\end{align*}

A polynomial commitment scheme is \textbf{evaluation binding} if no efficient adversary can convince the verifier that the committed polynomial $f(X)$ evaluates to a different value $y_0 \neq y_1 \in R$ in the same point $z\in R$.

\paragraph{\textbf{knowledge soundness: }} Any successful prover in the $\eval$ protocol must know a polynomial $f(X)$ such that $f(z)=y$ and $c$ is a commitment to $f(X)$. More formally, since $\eval$ is a public-coin interactive argument we define this knowledge property as a special case of witness-extended emulation.

Define the following $\NP$ relation given $\pp\leftarrow \setup(\secparam)$:
$$\calR_{\eval}(\pp)=\{\innp{(c,z,y,d)}{(f(X,r))}: f\in R[X] \text{ and } deg(f(X))\leq d
\text{ and } f(z)=y \text{ and }\open(\pp,c,f(X),r) =1 \}$$
 
the correctness definition above implies that if $\Gamma = (\setup, \commit, \open, \eval)$ is correct then $\eval$ is a correct interactive argument for $\calR_{\eval}(\pp)$, with overwhelming probability over the randomness of $\setup$. We say that $\Gamma$ gas \textbf{witness-extended emulation} if $\eval$ has witness-extended emulation as an interactive for $\calR_{\eval}(\pp)$.

It is easy to see that witness-extended emulation implies evaluation binding when the $\setup$, $\commit$ and $\open$ part of $\Gamma$ form a binding commitment scheme. If the adversary succeeds in $\eval$ on both $(c,z, y_0,d_0)$ and $(c,z,y_1,d_1)$ for $y_0\neq y_1$ or $d_0\neq d_1$ then the emulator obtains two distinct witness $f(X)\neq f'(X)$ such that $c$ is a valid commitment to both. This would contradict the binding property of the commitment scheme.

Here the $\eval$ interactive protocol can be made zero knowledge as well, described in \cite{DARK19}
$\eval$ can be made non-interactive zero knowkedge as well.
We will define a special type of proof, called \textbf{aggregatable proof}, which we will use later.

\begin{definition}\label{defn:aggregatable}
	A proof system (interactive or non-interactive) $\Pi=(\prover, \verifier)$ is called aggregatable if for any instances $\stmt_1, \stmt_2$ there are witnesses $\wit_1, \wit_2$ such that $\prover(\stmt_1,\wit_1) \rightarrow \pi_1$ and $\prover(\stmt_2, \wit_2) \rightarrow \pi_2$ and $\verifier(\stmt_1,\pi_1) \rightarrow 1$ and $\verifier(\stmt_2,\pi_2) \rightarrow 1$. Then there is a operation $\oplus$ such that $\verifier(\stmt_1+\stmt_2, \pi_1 \oplus \pi_2) \rightarrow 1$, where $\wit_1 + \wit_2$ is a correct witness for $\stmt_1+\stmt_2$.
\end{definition}
In other words there is a deterministic way to generate a proof for a combined statement, given the proof of the individual statements, where aggregating the witnesses of the statements give a witness for the combined statement.

\subsection{Algebraic Linear IOPs}
An Interactive Oracle Proof(IOP)\cite{BCS16, RRR16} is a multi-round interactive PCP: in each round of an IOP the verifier sends a message to the prover and the prover responds with a polynomial length proof, which the verifier can query via raqndom access.
A $t$-rounf $l$-query IOP has $t$ rounds of interaction in which the verifier makes exactly $l$ queries in each round.

Linear IOPs\cite{BBC+19} are defined analogously except that in each round the prover sends a linear PCP\cite{IKO07}, in which the prover sends a single proof vector $\bm{\pi} \in \bbF^m$ and the verifier makes linear queries to $\bm{\pi}$. Specifically, the PCP gives the verifier access to an oracle that receives queries of the form $\bm{q}\in\bbF^m$ and returns the inner product $\innp{\bm{\pi}}{\bm{q}}$.

\begin{definition}[Public-coin linear IOP]\label{defn:linearIOP}
	Let $\calR$ be a binary relation and $\bbF$ a finite field. A $t$-round $l$-query public coin linear IOP for $\calR$ over $\bbF$ with soundness error $\epsilon$ and knowledge error $\delta$ and query length $\bm{m}=(m_1,\ldots, m_t)$ consists of two stateful $\ppt$ algorithms, the prover $\prover$, and the verifier $\verifier = (\calQ, \calD)$, where the verifier consists in turn of a public deterministic query generator $\calQ$ and a decision algorithm $\calD$, that satisfy the following requirements:
	\begin{itemize}
		\item For each $i$th round there is a prover state $\st^{\prover}_i$ and a verifier state $\st^{\verifier}_i$. For any common input $\stmt$ and $\calR$ witness $\wit$, at round 0 the states are $\st^{\prover}_0 = (\stmt, \wit)$ and $\st^{\verifier}_0 = \stmt$. In the $i$th round (starting at $i=1$) the prover outputs a single proof oracle $\prover(\st^{\prover}_{i-1})\rightarrow \bm{\pi}_i \in \bbF^{m_i}$.
		
		The verifier samples public random coins $\coins_i \leftarrow \bitset^*$ and the query generator computes a query matrix from the verifier state and these coins: $\calQ(\st^{\verifier}_{i-1}, \coins_i)\rightarrow \bm{Q}_i \in \bbF^{m_i\times l}$. The verifier obtains the linear oracle response vector $\bm{\pi}_i^T\bm{Q}_i = \bm{a}_i \in \bbF^{1\times l}$. The updated prover state is $\st^{\prover}_i\leftarrow (\st^{\prover}_{i-1}, \bm{Q}_i)$ and verifier state is $\st^{\verifier}_{i-1}, \coins_i, \bm{a}_i)$. Finally $\calD(\st^{\verifier}_t)$ returns 1 or 0.
		
		\item \underline{Argument of Knowledge:} As a proof system, $(\prover, \verifier)$ satisfies perfect completeness, soundness with respect to the relation $\calR$ and with soundness error $\epsilon$, and witness-extended emulation with respect $\calR$ with knowledge error $\delta$.
	\end{itemize}
\end{definition}

A linear IOP is called \textbf{stateless} if for each $i\in [t]$, $\calQ(\st^{\verifier}_{i-1}, \coins_i) = \calQ(i,\coins_i)$.

A linear IOP has \textbf{algebraic queries} if it is stateless and for each $i\in[t]$, the map $\coins_i \stackrel{\calQ(i,\cdot)}{\longmapsto} \bm{Q}_i \in \bbF^{m_i \times l}$ decomposes into two maps, $\coins_i \stackrel{\calQ_0(i,\cdot)}{\longmapsto} \Sigma_i \stackrel{\calQ_1(i,\cdot)}{\longmapsto} \bm{Q}_i$, where $\Sigma_i \in \bbF^{\mu_i\times l}$ is a matrix of $\mu_i ( < m_i)$ rows and $l$ columns and $\calQ_1(i,\cdot)$ described by $l$ $\mu_i$-variate polynomial functions of degree at most $d = poly(\lambda)$: $p_1,\ldots, p_l: \bbF^{\mu_i}\rightarrow \bbF^{m_i}$ such that for all $k\in[l]$, $p_k(\sigma_{i,k})=q_{i,k}$, where $\sigma_{i,k}$ and $q_{i,k}$ denote the $k$th column of $\Sigma_i$ and $\bm{Q}_i$ respectively.


\subsection{Polynomial IOPs}
Polynomial IOP is an special case of the algebraic linear IOP, where proof given by the prover is a polynomial. prover commits to the polynomial using polynomial commitment scheme, and verifier instead of inner product queries for the evaluation at a random point.

\begin{definition}[Public coin polynomial IOP]\label{defn:polyIOP}
	Let $\calR$ be a binary relation and $\bbF$ a finite field. Let $\bm{X}=(X_1,\ldots, X_{\mu})$ be a vector of $\mu$ indeterminates. A $(\mu, d)$ Polynomial IOP for $\calR$ over $\bbF$ with soundness error $\epsilon$ and knowledge error $\delta$ consists of two stateful $\ppt$ algorithms, the prover $\prover$, and the verifier $\verifier$, that satisfy the following requirements: 
	\begin{itemize}
		\item For each $i$th round there is a prover state $\st^{\prover}_{i}$ and a verifier state $\st^{\verifier}_i$. For any common input $\stmt$ and $\calR$ witness $\wit$, at round 0 the states are $\st^{\prover}_0 = (\stmt, \wit)$ and $\st^{\verifier}_0 = \stmt$. In the $i$th round (starting at $i=1$) the prover outputs a single proof oracle $\prover(\st^{\prover}_{i-1})\rightarrow \pi_i$, whch is a polynomial $\pi_i(\bm{X})\in \bbF[\bm{X}]$.
		
		The verifier deterministically computes the query matrix $\Sigma_i\in \bbF^{\mu \times l}$ from its state and a string of public random bit $\coins_i \sample \bitset^*$, i.e, $\verifier(\st^{\verifier}_{i-1}, \coins_i) \rightarrow \Sigma_i$. This query matrix is interpreted as a list of $l$ points in $\bbF^{\mu}$ denoted by $(\sigma_{i,1},\ldots, \sigma_{i,l})$. The oracle $\pi_i$ is queried on all points in this list, producing the response vector $(\pi_1 (\sigma_{i,1}) , \ldots, \pi_l (\sigma_{i,l})) = \bm{a}_i \in \bbF^{1\times l}$.
		
		The updated prover state is $\st^{\prover}_i \leftarrow (\st^{\prover}_{i-1}, \Sigma_i)$ and verifier state is $\st^{\verifier}_{i} \leftarrow (\st^{\verifier}_{\i-1}, \Sigma_i, \bm{a}_i)$. Finally $\verifier(\st^{\verifier}_t)$ returns 1 or 0.   
		\item \underline{Argument of knowledge: } As a proof system, $(\prover, \verifier)$ satisfies perfect completeness, soundness with respect to the relation $\calR$ and with soundness error $\epsilon$, and witness-extended emulation with respect $\calR$ with knowledge error $\delta$.
	\end{itemize}
\end{definition}

\subsection{zkSNARK from Polynomial IOP} 
Let $\Gamma = (\setup, \commit, \open, \eval)$ be a multivariate polynomial commitment scheme. Given any $t$- round Polynomial IOP for $\calR$ over $\bbF$, \cite{DARK19} constructs an interactive protocol $\Pi = (\setup, \prover, \verifier)$ as follows:
\begin{itemize}
	\item Run $\pp \leftarrow \setup(\secparam)$
	
	\item In any round where the IOP prover sends a $(\mu, d)$ polynomial proof oracle $\bm{\pi} : \bbF^{\mu} \rightarrow \bbF$, in the corresponding outer round of $\Pi$, $\prover$ sends the commitment $c_{\pi} \leftarrow \commit(\pp;\bm{\pi})$
	
	\item in any round where the IOP verifier makes an evaluation query $\bm{z}$ to a $(\mu,d)$ polynomial proof oracle $\bm{\pi}$, in the corresponding outer round of $\Pi$, insert an interactive execution of $\eval(\pp, c_{\pi}, \bm{z}, y, \mu,d; \bm{\pi})$ between $\prover$ and $\verifier$, where $\bm{\pi}(\bm{z})=y$.
\end{itemize}

If $\verifier$ does not abort in any of these subprotocols, then it receives a simulated IOP transcript of oracle queries and responses. It runs the IOP verifier decision algorithm on this transcript and outputs the result.

\subsubsection{Obtaining zero knowledge} Following theorem from \cite{DARK19} explains how to obtain zero knowledge protocol from above Polynomial IOP based construction.

\begin{theorem}
	If the polynomial commitment scheme $\Gamma$ has witness-extended emulation and the $t$-round Polynomial IOP for $\calR$ has negligible knowledge error, then $\Pi$ is a public-coin interactive argument for $\calR$ that has witness-extended emulation. The compilation also preserves HVZK if $\Gamma$ is hiding and $\eval$ is HVZK.
\end{theorem}
.\pnote{Define what is aggregatable. and also mention about non interactive version of $\eval$}
\subsection{DPZK for zkSNARK based on Polynomial IOP}
\begin{theorem}
	If there is a polynomial IOP based zkSNARK where the underlying polynomial commitment scheme $\Gamma = (\setup, \commit, \open, \eval)$ has the following properties :
	\begin{itemize}
		\item $\Gamma$ is a homomorphic commitment scheme.
		\item $\eval$ protocol is aggregatable. 
	\end{itemize}
	Then the polynomial IOP based zkSNARK can be converted into a DPZK protocol.
\end{theorem}
Let $\prover_1, \ldots, \prover_{\Num}$ are the set of provers who are involved in the proof system.

$\prover_{\nu}$ starts the protocol with the input $(\stmt, \wit_{\nu})$ such that $\sum_{\nu\in[\Num]}\wit_{\nu} = \wit$, where single prover would have the input $(\stmt, \wit)$. 

If $\prover$ in the actual execution of the proptocol, at $i$th round, commits to a polynomial $\pi_i$ using the polynomial commitment scheme $\Gamma$. 
Then provers run $MPC$ to compute the function $f ( \st^{\prover_{1}}_{i-1}, \ldots, \st^{ \prover_{ \Num } }_{ i-1 } ) = (\pi_i^{1},\ldots, \pi_i^{\Num})$, where $\pi_i = \sum_{\nu\in[\Num]} \pi^{\nu}_i$ and $\pi_i = \prover ( \sum_{\nu \in [\Num] } \st^{ \prover_{\nu} }_{i-1})$.

$\prover_{\nu}$ gets $\pi_i^{\nu}$ as the output of $MPC$.

Each prover commits to the polynomial $\pi_i^{\nu}$, let $c^{\nu}_i = \commit(\pi_{i}^{\nu})$.
Then all the provers send $c_i^{\nu}$ to a common aggregator $\Ag$. 
$\Ag$ combines all the commitments and gets $c_i = \sum_{\nu \in [\Num] } c^{\nu}_i$ and sets this as oracle, which is a commitment of the polynomial $\pi$, by homomorphism property of the polynomial commitment scheme $\Gamma$.
Now if $\verifier$ sends a random challenge $z$ to evaluate $\pi_i$ at $z$, then $\Ag$ forwards $z$ to all the provers. $\prover_{\nu}$ computes $\pi_i^{\nu}(z)$ and sends to $\Ag$. $\Ag$ combines all the evaluations and gets $y = \pi(z)$ and sends $y$ to $\verifier$.
All the provers in addition to the evaluation $\pi^{\nu}_i(z) = y^{\nu}$ sends a proof $\eval(\pp, c^{\nu}_i , z, y^{\nu}, d; \pi^{\nu}_i, r)$. 
By the aggregatable property of $\eval$, $\Ag$ can aggregate the proofs and get a proof $\eval(\pp, c_i, z, y, d; \pi_i, r)$.

As all the provers are getting the challenges given by $\verifier$, Every prover updates their state and maintain the same homomorphic property.

 

Completeness is easy to see.

Soundness property depends on the binding of the polynomial commitment scheme and underlying single prover protocol.

Zero knowledge is preserved because the verifier it is same as interacting with one prover and if the single prover protocol is zero knowledge then the distributed protocol is also zero knowledge. 

Privacy among the provers is preserved if the MPC used in each round is secure. And the aggregator is not learning anything more what verifier learns in the single prover protocol. 
	\bibliographystyle{alpha}
	\bibliography{main.bib} 
\end{document}