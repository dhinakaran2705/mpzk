%---------
In Ligero~\cite{ligero}, an extended witness is viewed as a matrix of size $\sqrt{N} \times \sqrt{N}$. Then each row of the matrix is encoded. Then in that protocol, the prover is required to communicate messages, one of which is the size of a row and $O(1)$ many columns of the encoded extended witness. This imposes a natural restriction on Ligero as they cannot skew the dimensions to reduce the proof size. Among the two dimensions, the largest dimension becomes the dominating factor that makes $\sqrt{N}$ is the best achievable communication complexity in Ligero. This bottleneck was resolved in Ligero++~\cite{ligero++}. They replace the communication of one dimension by using the inner product argument. More precisely, they rely on the inner product argument proposed in Virgo~\cite{Virgo}, which in turn relies on the Aurora proof system. Our optimization over Ligero is in a similar direction. We present the extended witness as a cube (3D matrix). One extra dimension brings more flexibility to a better trade-off between the communication complexity and the verification time. The key differences from Ligero/Ligero++ are the following.
(i) We use bulletproofs based inner product argument on reducing the communication complexity, and also, this is mainly used to facilitate distributed prover version that others fail to achieve.
(ii) We split the extended witness into three dimensions that aids in verification time while retaining the communication complexity proportional to the smallest dimension.
%-------------

Further, we give a generic construction from an IOP-based proof system to obtain another proof system that offers DPZK. For most of the protocols, the communication cost among the provers is expensive. Our protocol $\name$ provides a much efficient construction of the distributed prover version. 
%-------------
\begin{lemma}[Compiler]\label{lemma:compiler}
	Let $\langle \prover, \verifier \rangle$ be an IOP-based zero-knowledge proof system with proof of knowledge property, where $\mathsf{Or}$ is the oracle construction algorithm. Then $\exists$ an IOP-based zero-knowledge proof system $\langle \prover', \verifier' \rangle$ with an homomorphic oracle construction algorithm $\mathsf{H}$ such that it supports DPZK.
\end{lemma}
%---
\begin{proof}
	Let $\langle \prover, \verifier \rangle$ be an $r$ round protocol. Furthermore, consider at the $i$th round $\prover$ sends $m_i$ to $\verifier$ and sets $\pi_i$ as the oracle.
	%---
	
	Note that $m_i$ and $\pi_i$ are functions of the statement $x$, (extended) witness $\wit$, $\prover$'s randomness $r_i$, previous messages and oracles $(m_1, \ldots, m_{i-1}, \pi_1, \ldots, \pi_{i-1})$, and $\verifier$'s challenges.
	%---
	
	In the new protocol $\langle \prover', \verifier' \rangle$, $\prover'$ sets $m'_i = m_i$ and $\pi'_i = \comm(\pi_i, r_i)$. Here $\comm(\cdot)$ is any homomorphic commitment scheme. In particular, we instantiate $\comm$ by using Pedersen commitment scheme. Therefore, the new oracle construction algorithm is $\mathsf{H}(\pi_i) = \mathsf{Or}(\comm(\pi_i, r_i))$.
	%---
	Similarly, the verification algorithm changes in the following way:
	If $\verifier$ queries $j$th position to the oracle $\pi_i$, then $\verifier'$ queries the same position and receives $\open(\pi'_i[j])$, followed by the same computation of $\verifier$.
	%----
	
	\textit{Completeness} of $\langle \prover', \verifier' \rangle$ holds directly from the completeness of $\langle \prover, \verifier \rangle$. Consider an instance $x$, where $R(x,\wit) = 1$ for the Relation $R$ and $\prover'$ has the witness $\wit$. 
	Now in $\langle \prover, \verifier \rangle$, $\prover$ sends the messages $m_i$ that is the same as the messages of $\langle \prover', \verifier' \rangle$, and for the oracle instead of $\mathsf{H}(\pi_i)$, $\prover$ executes $\mathsf{Or}(\pi_i)$. Since $\langle \prover, \verifier \rangle$ is complete, and the proof is correct. Therefore $\verifier$ accepts the proof. Hence, the proof given by $\prover'$ is also accepting, as the verification algorithm is the same. This ensures the completeness property.
	
	\textit{Proof of knowledge} of $\langle \prover', \verifier' \rangle$ holds due to the proof of knowledge property of $\langle \prover, \verifier \rangle$ and the binding property of the commitment scheme. 
	
	Let $\extrac$ be the extractor that interacts with a prover $\prover$ and if the interaction is accepting then $\extrac$ outputs a witness. We will use $\extrac$ to design an extractor $\extrac'$ for $\langle \prover', \verifier' \rangle$. $\extrac'$ works in the following way:
	%---
	\begin{itemize}
		%----
		\item[--] $\extrac'$ interacts with the prover $\prover'$ on behalf of the verifier $\verifier'$, and interacts with $\extrac$ on behalf of the prover $\prover$.
		%----
		\item[--] If $\prover'$ sends a message $m'$ then $\extrac'$ sends $m=m'$ to $\extrac$. 
		%----
		\item[--] If $\extrac$ makes any oracle query, then $\extrac'$ does the same oracle query. Let $\extrac$ queries for $j$. Then $\extrac'$ queries $j$ to $\pi'$ and receives $\pi^\ast[j] = \open(\pi'[j])$. 
		Note that, $\pi^\ast[j] = \pi[j]$ with high probability. If not, that is, either $\prover'$ commits to $\pi[j]$ but opens to a different value $\pi^\ast[j]$ with non-negligible probability which means $\prover'$ breaks the binding property of the commitment scheme, or if $\prover'$ does not commit to $\pi[j]$ that leads to verification failed in due to the soundness property of the underlying protocol $\langle \prover, \verifier \rangle$.
		Therefore $\extrac'$ sends $\pi^\ast$ to $\extrac$ as oracle response.
		%----
		\item[--] If $\extrac$ sends a challenge $c$ to $\extrac'$, then $\extrac'$ forwards $c$ to $\prover'$.
		%----
		\item[--] Finally, $\extrac'$ outputs whatever $\extrac$ outputs. 
	\end{itemize}
%	Let $\prover'^\ast$ does not have a correct witness corresponding to a statement $x$. But $\langle \prover'^\ast, \verifier' \rangle$ accepts with non-negligible probability.
%	Now we will use $\prover'^\ast$ to construct $\prover^\ast$ that can make $\langle \prover, \verifier \rangle$ output accept without the knowledge of a correct witness.
%	$\prover^\ast$ rewinds $\prover'^\ast$ to get the opening of $\pi'_i$, and obtain the oracle and sends $m_i$ that $\prover'^\ast$ sends to $\verifier$. Since the verification checks are the same for both protocols, $\langle \prover, \verifier \rangle$ outputs accept.
%	
%	The above reduction fails if $\prover'^\ast$ opens $\pi'_i$ to different values, which is possible with negligible probability due to the binding property of the commitment scheme. 
	
	\textit{Zero-knowledge} of $\langle \prover', \verifier' \rangle$ holds directly from the zero-knowledge property of $\langle \prover, \verifier \rangle$. 
	
	Since, $\langle \prover, \verifier \rangle$ has zero-knowledge property, therefore $\exists$ a simulator $\Sim$ that generates a transcript that is indistinguishable from a real transcript. Using $\Sim$, we will construct a new simulator $\Sim'$. 
	
	$\Sim'$ executes $\Sim$. If $\tau$ is the transcript generated by $\Sim$, and if $\pi_i$ be the part of $\tau$ which is an oracle set by $\prover$ at $i$th round of the protocol. Then $\Sim'$ commits to $\pi_i$ and gets $\pi'_i$. Finally the simulated transcript, $\tau'$, generated by $\Sim'$ by replacing $\pi_i$ with $\pi'_i$ is indistinguishable from a real execution of $\langle \prover', \verifier' \rangle$. This ensures the zero-knowledge property.
	%---
	
	Construction of $\DPZK$ version: Let $m_i(\cdot)$ be the function to generate $m_i$ and correspondingly $\pi_i(\cdot)$ for $\pi_i$. Let $\Partyset = \{\prover_{1}, \ldots, \prover_{\Num}\}$ be the set of $\Num$ provers, where at most $t (<n)$ can be corrupted. Parties in $\Partyset$ execute a $t$-secure MPC for the function $m_i(\cdot)$ and $\pi_i(\cdot)$ to get $\shareA{m_i}$ and $\shareA{\pi_i}$, where $\shareA{x}$ represents $t$-out of $n$ sharing of $x$. Provers locally compute $\shareA{\pi'_i}$ and send $\shareA{m_i}, \shareA{\pi'_i}$ to an aggregator $\Ag$.
	
	$\Ag$ obtains $m_i = \sum \shareA{m_i}$ and $\pi'_i = \prod \shareA{\pi'_i}$. It sets $\pi'_i$ as the oracle and sends $m_i$ to $\verifier$.
	
	\textit{Soundness with Witness Extraction:}
	
	Claim: The above construction of the DPZK from $\langle \prover', \verifier' \rangle$ has Soundness with Witness Extraction (SoWE) property if $\langle \prover', \verifier' \rangle$ has proof of knowledge property. 
	
	Let $\extrac$ be the extractor of $\langle \prover', \verifier' \rangle$. Therefore $\prover'$ interacts with $\extrac$ and $\extrac$ outputs a correct witness if the interaction is accepting. Using $\extrac$, we will construct $\extrac_{DP}$ for the distributed version.
	
	$\extrac_{DP}$ works as follows:
	If $\extrac$ sends $c$ to $\prover'$, then $\extrac_{DP}$ sends $c$ to all the provers (broadcasts).
	If $\extrac_{DP}$ receives $m$ from the aggregator $\Ag$, then $\extrac_{DP}$ forwards $m$ to $\extrac$. 
	Finally, $\extrac_{DP}$ outputs $\extrac$'s output.
	
	Note that $\extrac$ can extract a correct witness with high probability. Therefore, $\extrac_{DP}$'s output is also a correct witness with high probability.
	
	\textit{Zero-Knowledge:}
	
	Since in the DPZK of $\langle \prover', \verifier' \rangle$, the verifier's view does not change, therefore the same simulator works for the distributed prover setting also. Hence the zero-knowledge property is obvious.
	
	\textit{Witness Hiding:} 
	
	Let at the $i$th round, provers run a secure MPC, $\Pi_{m_i}$, to obtain $\shareA{m_i}$ such that $\sum \shareA{m_i} = m_i$.
	
	Corresponding to a corrupted set $C$ of $t$ provers, $\Sim$ does the following:
	\begin{itemize}
		%---
		\item[--] $\Sim$ calls the zero-knowledge simulator, $\Sim_{ZK}$ and obtains an indistinguishable transcript $\tau$.
		%---
		\item[--] On behalf of the verifier, $\Sim$ sets the challenge $c_i$ obtained from the transcript $\tau$, and corresponding response $m_i$.
		%---
		\item[--] If provers run an MPC, $\Pi_{m_i}$ to obtain $\shareA{m_i}$, and $\Sim_{m_i}$ be the corresponding simulator. Consider $\{st^i_j\}_{j\in C}$ be the inputs of the corrupted parties to $\Pi_{m_i}$. Then $\Sim$ executes $\Sim_{m_i}$ with inputs $\{st^i_j\}_{j\in C}$ and $\shareA{m_i}$.
		%---
		\item[--] Finally, $\Sim$ sends $\{\shareA{m_i}_j\}_{j\notin C}$ to $\Ag$.
		%---
	\end{itemize}
	%---
	Here note that, the view generated by $\Sim$ is indistinguishable from a real execution of the protocol. This can be established by the following argument:
	\begin{align*}
	& \SimV_1 || \ldots ||\SimV_i || \RealV_{i+1}|| \ldots || \RealV_r \\
	\approx\; & \SimV_1 || \ldots ||\RealV_i || \RealV_{i+1}|| \ldots || \RealV_r 
	\end{align*}
	Where $\SimV_i$ represents the simulated view of the $i$th round and analogously $\RealV_i$ represents the real view of the $i$th round.
	Now using hybrid argument we get \textit{simulated view} $\approx$ \textit{real view}.
\end{proof}
%------
The compiler preserves the proof size and round complexity of the underlying protocol. The overhead of the computational complexity depends on the oracle size and round complexity of the protocol. If $\langle \prover, \verifier \rangle$ has an oracle of size $|\pi_i|$ in the $i$th round, then the prover's complexity in $\langle \prover', \verifier' \rangle$ incurs an additional $|\pi_i|$ group exponentiations in the $i$th round. Similarly, if the verifier in $\langle \prover, \verifier \rangle$ makes $t$ many queries to the oracle $\pi_i$, that adds $t$ group exponentiations in the verifier's complexity in $\langle \prover', \verifier' \rangle$.
%------

In Aurora~\cite{aurora}, the size of the oracle is $O(N)$, the proof size is $O(\log^2 N)$, and number of rounds is $O(\log N)$. Aurora is an IOP-based proof system where almost all the messages from $\prover$ to $\verifier$ are set as oracles, and $\verifier$ makes a few oracle-queries complete the verification.
%----
We can convert Aurora using our compiler such that it supports DPZK, we call the distributed version to be D-Aurora. The compiled version retains the Oracle size, proof size, and number of rounds. However, the prover time and the verification time increase by $O(N\log N)$ group exponentiations. Since all the oracle construction and validation need $O(N)$ group exponentiations in every round. The distributed version of it needs secure evaluation of a depth one circuit with $O(N)$ multiplication gates in each round.
%----

Similarly, for Ligero~\cite{ligero}, Ligero++~\cite{ligero++}, our compiler provides protocols with  prover time $O(N\log N)$ field multiplication plus $O(N)$ group exponentiations, and verification time $O(N)$ field multiplication plus $O(N)$ group exponentiations. Note that the proof size of the protocols remains the same in the new compiled protocols. We call the distributed versions as D-Ligero and D-Ligero++ respectively.

%----
We provide construction of a new proof system which can be obtained from Ligero/Ligero++~\cite{ligero,ligero++} using our compiler and some additional optimization. The rationale behind opting for Ligero style proof system is that it does not have many oracles. Therefore the conversion is less costly.
%----
Using the compiler directly on Ligero++~\cite{ligero++} gives 2D version of our construction where the Virgo~\cite{Virgo} inner product is replaced by Bulletproofs~\cite{bulletproofs} inner product. We optimize further in our construction by adjoining additional dimension which aids in better trade-off between proof size and verification time. 
%----
We use a similar approach to~\cite{bootle2020linear, bootle2020zero}, where the witness is viewed as a multi-dimensional matrix. In our construction, we restrict to 3 dimensions since, among these dimensions, only the smallest one contributes to the proof size, while the remaining two aid in better verification time. In our setting, we explored the scenarios by increasing the number of dimensions. Those approaches lead to more complicated and costlier proof-generation and verification protocols without any more improvements. \cite{bootle2020zero} provides linear-time prover with poly-logarithmic verification, but a major drawback of this work is that the soundness error is $O(1)$. Furthermore,~\cite{bootle2020linear} obtain linear-time prover by using linear-time encodable codes. For that, they use a linear code provided by~\cite{druk2014linear}, whose decoding is conjectured intractable. Due to this property, ~\cite{bootle2020linear} does not satisfy the proof of knowledge property.

%\pnote{To add: 1. different amalgamations of MPC and ZK to achieve DPZK fails.
%	i) MPC-in-the head, ii) MIP, iii) trusted set-up run via MPC
%	 2. Gate by gate construction of ZK fails to provide DPZK. 3. Compare with tensor query based construction, the recent work that augment the zero-knowledge that does not provide proof of knowledge. 4. Address UC notion in the definition.}