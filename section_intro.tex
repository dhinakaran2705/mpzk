\section{Introduction}

\section{Preliminaries}
\subsection{Reed Solomon Codes}
\begin{definition}[Reed-Solomon Code]\label{defn:rscodes}{\rm
For positive integers $n,k$ and a finite field $\FF$, and a vector
$\bm{\eta}=(\eta_1,\ldots,\eta_n)\in \FF^n$ of distinct field elements, the
code $\RSC{k}{n}{\eta}$ is a linear code over $\FF$ consisting of tuples 
$(p(\eta_1),\ldots,p(\eta_n))$ where $p$ is a polynomial of degree $< k$ over
$\FF$.
}
\end{definition}

\begin{definition}[Interleaved Code]\label{defn:interleaved}{\rm
For an $[n,k,d]$ linear code $L$ over field $\FF$ and a positive integer $m$, we define
the {\em interleaved } code $L^m$ consisting of $m\times n$ matrices over $\FF$
whose rows are codewords in $L$. We view $L^m$ as a code over the alphabet
$\FF^m$, where each column of $L^m$ is a symbol in $\FF^m$.
}
\end{definition}
The distance of two codewords $A,B\in L^m$ is defined as the number of columns
where they differ, i.e $\Delta(A,B)=|\{i\in [n]: A[i]\neq B[i]\}|$ where $X[i]$
denotes the $i^{th}$ column of $m\times n$ matrix $X$. 

The soundness of our protocols of proximity rely on the following lemma:
\begin{lemma}\label{lem:proximitytest}{\rm
Let $L$ be an $[n,k,d]$ linear code and $L^m$ be the interleaved code obtained
from $L$ for some positive integer $m$. Let $U^\ast\in \FF^{mn}$ be such that
$d(U^\ast,L^m) > e$ where $e < d/3$. Then,
\begin{align}
\probsub{r\sample \FF^m}{\Delta(r^TU^\ast,L)\leq e} < \frac{d}{|\FF|}.
\end{align}
}
\end{lemma}
The above lemma is proved in \cite{Ligero2017} for $e=d/4$. We provide a
self-contained proof of the above for $e=d/3$ in the Appendix.

\subsection{Inner Product Arguments}
We define an interactive protocol that allows proving inner product relation
over committed values. 
\begin{definition}\label{defn:commscheme}
 A pair of $\ppt$ algorithms
$(\csetup,\comm)$ constitute a non-interactive commitment scheme if
$\sigma\sample \csetup(\secparam)$ consists of description of sets
$\mc{M}_\sigma$ (message space), $\mc{R}_\sigma$ (randomness space),
$\mc{C}_\sigma$ (commitment space) and an efficiently computable function 
$\comm_\sigma: \mc{M}_\sigma\times \mc{R}_\sigma\rightarrow \mc{C}_\sigma$ which is {\em hiding} and {\em binding} as defined later.
\end{definition}

For $x\in \mc{M}_p$, we generate a {\em commitment} of $x$
as $\comm_\sigma(x,r)$ where $r\sample \mc{R}_p$ is drawn uniformly at random. For ease
of notaion, we simply use $\comm$ instead of $\comm_\sigma$ and use $\comm(x)$ to denote the random variable corresponding to commitment of $x$. 

\begin{definition}[Hiding Commitment]\label{defn:hidingcomm}
A commitment scheme $(\csetup,\comm)$ is called {\em hiding} (perfectly) if for
all $\ppt$ adversaries $\adv$, the following probability is negligibly close to
$1/2$:
\begin{align*}
\condprob{b=b'}{
\begin{array}{l}
\sigma\sample \csetup(\secparam); \\
(x_0,x_1)\in \mc{M}^2_p\sample \adv(\sigma); \\
b\sample \{0,1\}; c\sample \comm(x_b);\\
b'\sample \adv(\sigma,c)
\end{array}
}
\end{align*}
\end{definition}

\begin{definition}[Binding Commitment]\label{defn:bindingcomm}
A commitment scheme $(\csetup,\comm)$ is called {\em binding} if for all $\ppt$
adversaries $\adv$, 
\begin{align*}
\condprob{\comm_p(x_0,r_0)=\comm_p(x_1,r_1)\wedge x_0\neq x_1}{
\begin{array}{l}
\sigma\sample \csetup(\secparam) \\
x_0,x_1,r_0,r_1 \sample \adv(\sigma)
\end{array}
} < \negl
\end{align*}

\end{definition}

We will assume that all the message spaces $\mc{M}_\sigma$ output by the
$\csetup$ algorithm come equipped with an inner product operator
$\innp{.}{.}:\mc{M}_\sigma\times \mc{M}_\sigma\rightarrow \ZZ$. We define
the language $\mc{L}_\sigma\subseteq \mc{C}_\sigma\times \mc{C}_\sigma\times
\ZZ$ as:
\begin{equation*}
\mc{L}_\sigma = \{(c_1,c_2,v):\exists x_1,x_2,r_1,r_2 \text{ s.t. }
c_1=\comm(x_1,r_1), c_2=\comm(x_2,r_2) \text{ and } \innp{x_1}{x_2}=v\} 
\end{equation*}

The $\npol$ relation $\mc{R}_\sigma$ for the language $\mc{L}_\sigma$ consists
of pairs $(u,w)$ with $u=(c_1,c_2,v)$ and $w=(x_1,x_2,r_1,r_2)$ such that
$c_1=\comm(x_1,r_1)$, $c_2=\comm(x_2,r_2)$ and $\innp{x_1}{x_2}=v$ 

\begin{definition}[Inner Product Argument]\label{defn:innerproductarg}
We call an interactive protocol $(\pip,\vip)$ consisting of $\ppt$ interactive algorithms
$\pip$ and $\vip$ an inner product argument for commitment scheme
$(\csetup,\comm)$ if it recognizes the language $\mc{L}_\sigma$ as defined
previously. Namely, $(\pip,\vip)$ satisfies the following:
\begin{enumerate}[{\rm (i)}]
\item {\bf Completeness}: For all adversaries $\adv$,
\begin{align*}
\condprob{(u,w)\not\in \mc{R}_\sigma \vee \langle \pip(\sigma,u,w),\vip(\sigma,u)\rangle={\tt accept}}{
\begin{array}{l}
\sigma\sample \csetup(\secparam);\\
(u,w)\sample \adv(\sigma)
\end{array}
}=1
\end{align*}

\item{\bf Soundness}: For all deterministic polynomial time $\mc{P}^\ast$ and
$\ppt$ adversaries $\adv$:
\begin{align*}
\condprob{u\not\in \mc{L}_\sigma \wedge \langle
\mc{P}^\ast(\sigma,u,s),\vip(\sigma,u)\rangle={\tt accept}}{
\begin{array}{l}
\sigma\sample \csetup(\secparam);\\
(u,s)\sample \adv(\sigma)
\end{array}
} = \negl
\end{align*}
\end{enumerate}
\end{definition}

We mention some concrete instantiations of commitment schemes and corresponding
inner product arguments that we use in our protocol.

\noindent{\em Logarithmic Inner Product Argument}: In this setting we have
$\mc{M}_\sigma=\ZZ^n_p$, $\mc{R}_\sigma=\ZZ_p$, $\mc{C}_\sigma=\GG$ where $\GG$
is group of prime order $p$. The algorithm $\csetup$ samples generators
$g_1,\ldots,g_n$, $h$ $\sample \GG$. The commitment is a pederson vector
commitment given by $\comm({\bf
x},r)=h^r.\prod_{i=1}^n {g_i}^{x_i}$ where ${\bf x}=(x_1,\ldots,x_n)$. We use
the inner product argument $(\piplog,\viplog)$ from Bootle et.al
in \cite{Bulletproofs} for the commitment scheme $(\csetup,\comm)$. The
interactive protocol $(\piplog,\viplog)$ is a $O(\log n)$ round protocol with
argument size $O(\log n)$. Time complexity of the verifier $\viplog$ is given
by $t(\viplog)=O(n).\ZZ_p + O(n).\GG$.\smallskip


\noindent{\em Square Root Inner Product Argument}: In this setting we use the
same commitment scheme as above. For the inner product argument we use the
interactive protocol $(\pipsq,\vipsq)$ from \cite{InnerProductDLS} or
\cite{Groth09b}. The construction in \cite{InnerProductDLS} gives a $5$-move
protocol with total communication complexity $O(\sqrt{n})$. The construction in
\cite{Groth09b} gives a 7-move protocol with $O(\sqrt{n})$ communication
complexity. In both the constructions $t(\vipsq) = O(n).\ZZ_p +
O(\sqrt{n}).\GG$.

\section{Solution Overview}
We present an overview of the techniques underlying our interactive protocol
with succint argument size and efficient verification with sublinear public
key operations and sublinear field operations in expectation. In our
presentation of the core ideas, we first give an informal overview of the
existing techniques, and then discuss our specific modifications to them.

Our starting point is the Interactive PCP argument presented in Ligero\cite{Ligero2017}. The
aforementioned protocol uses elementary techniques, is concretely
efficient being based on symmetric key operations, and achieves an argument
size which is square-root in size of the arithmetic circuit. Our core technical
contribution is to use homomorphic commitments and inner product arguments to 
further reduce the size of the ``queries'' to the witness oracle. The
reduced access to the witness oracle comes with another surprising benefit: The
verifier restricts its computations to those directly relevant to the parts of
witness being revealed. This allows us to achieve sublinear verification on
average. By carefully restricting the subprotocols using expensive public key
operations to asymptotically smaller circuits (much smaller for practically
relevant instantiations), we keep the number of public key operations for the
verifier to be strictly sublinear.
    
\subsection{Arguments for Arithmetic Circuits}
Our protocol natively supports showing the 
satisfiability of the $\FF$-arithmetic circuit for a finite field $\FF$ which
is an $\npol$-complete language. For ease of presentation, we produces an argument for the
statement ``$\exists x, \text{ s.t } C(x)=1$'' for an $\FF$-arithmetic circuit
$C$. This can be easily modified to
yeild arguments for the more typical $\npol$ language $\mc{L}_C = \{x:\exists w
\text{ s.t. } C(x,w)=1\}$, which we will briefly discuss later. The
satisfiability of an arithmetic circuit $C$ reduces to proving existence of
vectors $x,y,z,w$ such that:
$z = x\circ y$,
$x = P_x w$,
$y = P_y w$,
$z = P_z w$ for public matrices $P_x,P_y$ and $P_z$ (depending on
$C$). Thus, broadly in the IPCP setting we have the following protocol:
\begin{enumerate}
\item {\bf Oracle Setup}: The prover sets up witness oracle
$x,y,z,w$ and provides query access to the verifier. 
\item {\bf Linear Checks}: The verifier runs a subprotocol with the prover to verify
the linear constraints $x=P_x w$, $y=P_y w$, $z=P_z w$.
\item {\bf Quadratic Check}: The verifier runs a subprotocol with the prover to
verify $z=x\circ y$.
\end{enumerate}

\subsection{Interactive Protocols for RS-code Oracles}
\subsubsection{Reed Solomon Witness Encoding}
The linear and quadratic constraints discussed above do not naively admit a
sublinear query, i.e, the verifier needs to access complete vectors to
be convinced with high probability. Error correcting codes have been used to
encode the witness in PCP constructions to enable verification with sublinear
query. We discuss two such encodings based on Reed-Solomon codes which have
been used in recent constructions \cite{Ligero2017,Aurora,STARK2019}.

To encode a vector $x\in \FF^N$, one specifies two domains $G,H\subseteq \FF$.
We will call $G$ as {\em interpolation} domain and $H$ as {\em evaluation} domain.
The encoding in \cite{Aurora} encodes the vector $x$ as a single Reed-Solomon
codeword. This is done by first constructing a polynomial $\hat{f}^x$ which
interpolates the vector $x$ on $G$, and then computing its evaluations
$\langle \hat{f}^x(\alpha) \rangle_{\alpha\in H}$ on points in $H$. The sizes
of domains $G$ and $H$ need to be $\Omega(N)$ in the above encoding. For a
vector $x$, we will use the notation $\hat{f}^x$ to denote the polynomial
interpolating $x$ on $G$, and $f^x$ to denote the vector of evaluations of
$\hat{f}^x$ on $H$. Thus in the above scheme, $f^x$ is an encoding of the
vector $x$.

An alternative encoding used in \cite{Ligero2017} encodes parts of a vector
separately, and thus the encoded vector corresponds to a set of Reed-Solomon
codewords, or a single codeword of an Interleaved Reed-Solomon code(see
Definition \ref{defn:interleaved}). More specifically, one chooses integers $m$
and $\ell$ such that $m\ell > N$ and domains $G$ and $H$ of size
$\Omega(\ell)$. The vector $x\in \FF^N$ is written as
$x=(x_1|\cdots|x_m)$ where $x_i\in \FF^l$ for all $i\in [m]$. The vector $x$ is
encoded as $(f^x_1,\ldots,f^x_m)$ where $f^x_i$ encodes $x_i$ as described
before, i.e $f^x_i=\langle \hat{f}^x_i(\alpha)\rangle_{\alpha\in H}$ where the
polynomial $\hat{f}^x_i$ interpolates the vector $x_i$ on $G$. 

\subsubsection{Linear Check}
Without loss of generality, we will discuss an argument for proving linear constraints
of the form $Ax=0$ where $A$ is a public matrix and $x$ is a (secret) vector. The
case $Ax=y$ is easily transformed to the required form by defining
$A'=[A|-I]$ and $x'=(x,y)$, and running the protocol on $A'$ and
$x'$. Assume that $x\in \FF^N$ and $A\in \FF^{N\times N}$. To acheive sublinear query
complexity, we do two things: (i) we make a high probability reduction to the
problem of proving $\innp{r^TA}{x}=0$ where $r\sample \FF^N$ is sent by
the verifier (ii) encode the witness $x$ using Reed-Solomon code as
we described earlier.

We first consider the encoding used in \cite{Aurora} which encodes $x$ as a
single codeword $f^x$. The prover then provides oracle access to $f^x$. Let
$\hat{r}\in\FF[x]$ be the polynomial that interpolates the vector $r^TA$ on $G$.
Then the linear check reduces to checking $\sum_{\alpha\in
G}\hat{r}(\alpha).\hat{f}^x(\alpha) = 0$. In \cite{Aurora}, the aforementioned
identity is checked with query size of $O(\log|H|)$ using especially developed
sumcheck protocol for univariate polynomials. The verifier still incurs $O(N)$
work to compute the encoding $\hat{r}$ for the size $N$ vector $r^TA$. 

We now consider the interleaved encoding of the witness. 
Here we write the vector $x\in \FF^N$ as $x=(x_1|\cdots|x_m)$
where each $x_i\in \FF^\ell$ for some $m\ell > N$, and $x_m$ padded as necessary. For
suitable domains $G$ and $H$, we interpolate each chunk of the vector on $G$ 
seperately via 
polynomials $\hat{f}^x_1,\ldots,\hat{f}^x_m$. Similarly we write
$r^TA=(r_1,\ldots,r_m)$ with $r_i\in \FF^n$ and construct polynomials $\hat{r}_i$
for $i\in [m]$. The inner product check $\innp{r^TA}{x}=0$ is then equivalent to checking
$\sum_{i\in [m]}\sum_{\alpha\in G}\hat{r}_i(\alpha)\hat{f}^x_i(\alpha)=0$. The
latter is checked by the prover sending the polynomial $\hat{p}=\sum_{i\in
[m]}\hat{r}_i.\hat{f}^x_i$ to the verifier, and verifier checking
$\sum_{\alpha\in H}\hat{p}(\alpha)=0$. Choosing $m,\ell\approx O(N^\frac{1}{2})$ this
incurs square-root communication from the prover. How can the verifier be
sure that $\hat{p}$ was indeed computed correctly from the witness polynomials 
$\hat{f}^i_x$?. As we formally prove in the later sections, this can be
accomplished by the verifier querying the polynomial evaluations (oracles) at a constant
number of locations, say $\alpha_1,\ldots,\alpha_q$. The verifier then checks
that $\hat{p}$ is consistent at the queried locations by verifying
$\hat{p}(\alpha_j)=\sum_{i\in [m]}\hat{r}_i(\alpha_j)\hat{f}^x_i(\alpha_j)$ for
all $j\in [q]$. This incurs a total query complexity of $q.m=O(N^\frac{1}{2})$.
From the perspective of 
verifier's efficiency, it only needs to compute evaluations of
polynomials 
$\hat{r}_i$, $i\in [m]$ for $\alpha\in \{\alpha_1,\ldots,\alpha_q\}$. We will show
that this can be done in expected sublinear time, after a one time $O(||
A||)$ 
pre-processing. We will also discuss why a similar pre-processing does not work
for the earlier encoding scheme.

\subsubsection{Quadratic Check}
The quadratic check involves the prover convincing the verifier that $x\circ
y=z$ by providing oracle access to the vectors $x,y$ and $z$. Again, we
consider the encoding by parts we discussed for the linear check. We write
$x=(x_1|\cdots|x_m)$, $y=(y_1|\cdots|y_m)$ and $z=(z_1|\cdots|z_m)$ and
construct polynomials $\hat{f}^x_i$, $\hat{f}^y_i$ and $\hat{f}^z_i$ for $i\in
[m]$ as before. The quadratic check then reduces to showing that
$\hat{f}^x_i(\alpha).\hat{f}^y_i(\alpha)-\hat{f}^z_i(\alpha)=0$ for all $i\in
[m]$ and $\alpha\in G$. With high probability the above can be checked by
verifier sending a random vector $r\sample \FF^m$ to the prover, and prover
sending the polynomial $\hat{p}=\sum_{i\in
[m]}r_i(\hat{f}^x_i.\hat{f}^y_i-\hat{f}^z_i)$ to the verifier. The verifier
checks that $\hat{p}(\alpha)=0$ for all $\alpha\in G$. The verifier also checks
that $\hat{p}$ is correctly computed from the oracles by querying the oracles
at small number of points $\alpha_1,\ldots,\alpha_q$ and checking that
$\hat{p}(\alpha_j)=\sum_{i\in
[m]}r_i(\hat{f}^x_i(\alpha_j).\hat{f}^y_i(\alpha_j)-\hat{f}^z_i(\alpha_j))$ for
$j\in [q]$.

\subsubsection{Proximity Test}
The correctness of the previous two checks, namely the linear check and the
quadratic check rely on the fact that the witness oracles are evaluations of
``low'' degree polynomials. There are several known low degree tests for polynomials
from PCP literature. The protocol in \cite{Aurora} uses a recent test for
proximity by Ben Sesson et al.\cite{IOPP_FRI2018} with particularly efficient
prover and $O(\log d)$ query complexity for polynomials of degree at most $d$. 
We use a variant of proximty test from \cite{Ligero2017}, adapting it to work
with homomorphic commitments of the RS-encoded oracles and reducing the query
complexity.

\subsection{Protocols for commitments of RS-encoded oracles}
We now describe how to reduce the query complexity and verifier efficiency by
using homomorphic vector commitments over the RS encoded witness oracles. Let
$x\in \FF^N$ be the witness vector. Let $p,m$ and $\ell$ be integers such that
$pm\ell\geq N$. We choose ordered domains $G=\{\zeta_1,\ldots,\zeta_\ell\}$ and
$H=\{\eta_1,\ldots,\eta_n\}$. We then wirte the vectors $x$ as $x =
(x_{11},\ldots,x_{pm})$ where each $x_{ij}\in \FF^l$ for $(i,j)\in [p]\times
[m]$. Let $\hat{f}^x_{ij}$ be the polynomial interpolating the vector $x_{ij}$
on $G$ and let $f^x_{ij}$ denote the corresponding evaluation of
$\hat{f}^x_{ij}$ on $H$. We define the RS-encoded witness $\rsoracle\in
\FF^{p\times m\times l}$ as $\rsoracle[i,j,k]=\hat{f}^x_{ij}(\eta_k)$ for $i\in
[p]$, $j\in [m]$ and $k\in [n]$. We now construct a commitment oracle
$\comoracle$ from $\rsoracle$.

\subsubsection{Commitment Oracle}
Throughout we assume $\FF$ is a prime field. Let $\comm$ denote the pederson
vector commitment scheme over $\FF^m$ with randomness space as $\FF$ and
commitment space a group $\GG$ with independent generators $g_1,\ldots,g_m$ and
$h$. Define $c_{ik} = \comm(\rsoracle[i,.,k],\delta_{ik})$, $i\in [p]$, $k\in
[n]$ where $X[i,.,k]$
denotes the $m$-length vector $(X[i,1,k],\ldots,X[i,m,k])$ and $\delta_{ik}$
denotes the commitment randomness for computing the commitment $c_{ik}$. We
define the oracle $\comoracle$ as $\comoracle[i,k]=c_{ik}$. The oracle
$\comoracle$ answers queries of the type $Q\subseteq [n]$, responding with
columns $\comoracle[.,k]$ for $k\in Q$. We will use $\comoracle$ as the witness
oracle, and adapt the subprotocols for checking linear constraints, quadratic
constraints and proximity to this oracle.

\subsubsection{Linear Check with Commitment Oracle}
The linear check $Ax=0$ can be reduced to checking
$\innp{r^TA}{x}=0$, where the verifier samples a random $r\sample \FF^{pmn}$
and sends it to the prover. As before, the prover and verifer write $r$ as
$(r_{11}|\cdots|r_{pm})$ where each $r_i\in \FF^\ell$. Both the prover and the
verifier also compute degree $<\ell$ polynomials $\hat{r}_{ij}$ interpolating
the vector $r_{ij}$ on $G$. The required check in terms of polynomials can be
expressed as:
\begin{equation}\label{eq:lincheck}
\sum_{\alpha\in G}\sum_{j\in [m]}\sum_{i\in [p]}
\hat{r}_{ij}(\alpha).\hat{f}^x_{ij}(\alpha) = 0.
\end{equation}
The prover computes polynomials $\hat{p}_j = \sum_{i\in
[p]}\hat{r}_{ij}.\hat{f}^x_{ij}$ for $j\in [m]$ and polynomial $\hat{p}=\sum_j
\hat{p}_j$. Finally it sends the polynomial $\hat{p}$ of degree $< 2\ell$ to
the verifier who checks $\sum_{\alpha\in G}\hat{p}(\alpha)=0$. To guard against
dishonest provers, the verifier needs following additional consistency checks:
\begin{itemize}
\item The polynomial $\hat{p}$ is correctly computed from the polynomials
$\hat{p}_j$, $j\in [m]$.
\item The polynomials $p_j$, $j\in [m]$ are honestly computed from the witness
oracle $\comoracle$.
\end{itemize}
To enable the above checks, the prover needs to make additional communication.
In particular it needs to send a commitment to the set of polynomials
$\{\hat{p}_j: j\in [m]\}$. We first describe this commitment.\smallskip

\noindent{\em Commitment to set of polynomials $\hat{p}_j$}: We commit to the
set of polynomials $\hat{p}_j$ via their evaluations on $H$. Consider a matrix
$P\in \FF^{m\times n}$ where $P[j,k]=\hat{p}_j(\eta_k)$ for $(j,k)\in [m]\times
[n]$. Thus the $j^{th}$ row of $P$ corresponds to the evalaution $p_j$ of the polynomial
$\hat{p}_j$ on $H$. We commit to the matrix $P$ by sampling commitments to its
columns. Since $P$ corresponds to evaluations of polynomials of degree
$<2\ell$, we only generate commitments for the first $2\ell$ columns. Let
$d_1,\ldots,d_{2\ell}$ be the commitments for the first $2\ell$ columns of $P$
using the commitment scheme $\comm$. 
\begin{equation*}
P := \begin{bmatrix}
\hat{p}_1(\eta_1) & \cdots & \hat{p}_1(\eta_{2\ell}) & \vline & \cdots &
\hat{p}_1(\eta_n) \\
\vdots & \ddots & \vdots & \vline & \ddots & \vdots \\
\hat{p}_m(\eta_1) & \cdots & \hat{p}_m(\eta_{2\ell}) & \vline & \cdots &
\hat{p}_m(\eta_n)
\end{bmatrix}
\end{equation*}
Note that there exists a $2\ell\times n$ matrix $T$ such that $P'T = P$ where $P'$ denotes
the submatrix of $P$ consisting of first $2\ell$ columns. Thus the commitments
to other columns of $P$ can be computed from $d_1,\ldots,d_{2\ell}$ using
homomorphism. \smallskip

\noindent{\em Checking correctness of $\hat{p}$}: To check the consistency of
the polynomial $\hat{p}$ with respect to the polynomials $\hat{p}_j:j\in [m]$,
the prover additionally sends the commitments $d_1,\ldots,d_{2\ell}$ to the set
of aforementioned polynomials. Then the verifier needs to check that
$\hat{p}=\sum_{j\in [m]}\hat{p}_j$, which is equivalent to checking
$\bm{1}^TP'=\tilde{p}$ where $\bm{1}\in \FF^m$ denotes the all $1$ vector and
$\tilde{p}$ denotes the vector of evaluations of the polynomial $\hat{p}$ on
$\eta_1,\ldots,\eta_{2\ell}$. The verifier checks the preceeding identity
probabilistically by sampling $\gamma\sample \FF^{2\ell}$ and checking
$\innp{\bm{1}^T}{P'\gamma}=\innp{\tilde{p}}{\gamma}$. Next the verifier
computes the commitment $c$ of $P'\gamma$ using the matrix $T$ and homomorphic
properties of $\comm$. The inner product can now be verified by running the
inner product argument $(\pip,\vip)$ for the commitment scheme
$\comm$.\smallskip

\noindent{\em Checking correctness of $\hat{p}^j,j\in [m]$}: This check ensures
the the commitments $d_1,\ldots,d_{2\ell}$ open to polynomials $\hat{p}_j$,
$j\in [m]$ corresponding to honest computation. Notice that in the honest
computation we have (i) $P[j,k]=\hat{p}_j(\eta_k)=\sum_{i\in
[p]}\hat{r}_{ij}(\eta_k)\hat{f}^x_{ij}(\eta_k)=\sum_{i\in[p]}\hat{r}_{ij}(\eta_k)\rsoracle[i,j,k]$
for all $j,k$. Let $R_{jk}$ denote the vector
$(\hat{r}_{1j}(\eta_k),\ldots,\hat{r}_{pj}(\eta_k)\in \FF^p$. Then the previous
check can be written as:
\begin{equation}
\innp{e_j}{P[.,k]} = \innp{R_{jk}}{\rsoracle[.,j,k]} \quad \forall j,k.
\end{equation}
Note that $P[.,k]$ links to the commitments $d_1,\ldots,d_{2\ell}$ (we can
compute the commitment of $P[.,k]$ in terms of the $2\ell$ commitments). On the
other hand, the ``tube'' $\rsoracle[.,j,k]$ links to the commitment oracle
$\comoracle$. Thus the commitments $d_1,\ldots,d_{2\ell}$ are constrained by
the oracle. We make this linking more explicit. The verifier randomly samples
distinct indices $j_1,j_2,\ldots,j_q$ from $[m]$ and indices $k_1,\ldots,k_q$
from $[n]$ independently at random. Note that the latter indices are sampled
with repetition. It sends the tuples $\{(j_u,k_u)\}_{u\in [q]}$ to the prover. The prover responds with the tubes
$\{\rsoracle[.,j_u,k_u]:u\in [q]\}$ and columns $\{\comoracle[.,k_u]:u\in
[q]\}$. 
  

\subsection{Protocol with Commitment Oracle}
We describe how to use homomorphic commitment of RS-encoded oracle to reduce
argument size and verifier's complexity. Let $x\in \FF^N$ be the witness
vector. Let $p,m,\ell$ be positive integers such that $pm\ell > N$. We choose the interpolation domain $G\subseteq \FF\times \FF$ as
$G=\{(\alpha_j,\zeta_k): j\in [m], k\in [\ell]\}$ for distinct points
$\zeta_1,\ldots,\zeta_\ell$ and $\alpha_1,\ldots,\alpha_m$ in $\FF$. Define $n_1=\sigma_1\ell$ and
$n_2=\sigma_2 m$ where $\sigma_1,\sigma_2 > 1$ are constants. We now define the
evaluation domain $H=\{(\beta_j,\eta_k): j\in [n_2],k\in
[n_1]\}$ where $\beta$'s and $\eta$'s are distinct among themselves and from
coordinates in $G$.\smallskip

\noindent{\em RS Encoding with bivariate polynomials}:
We first write the witness $x=(x_1|\cdots|x_p)$ where each $x_i\in
\FF^{m\ell}$.
For each $i\in [p]$ we construct bivariate polynomial $Q^i(.,.)$ which
interpolates the matrix $x_i$ on $G$, i.e, $Q^i(\alpha_j,\zeta_k)=x_i[j,k]$.
Let $\mc{U}^i\subseteq \FF^{n_1n_2}$ denote the matrix of evaluations of $Q^i$
on $H$, i.e, $\mc{U}^i[j,k]=Q^i(\beta_j,\eta_k)$ for $j\in [n_1]$, $k\in
[n_2]$. Finally we define $\rsoracle=(\mc{U}^1|\cdots|\mc{U}^p)$. Note that
$\rsoracle[i,j,k]=Q^i(\beta_j,\eta_k)$ for all $i$, $j$ and $k$.\smallskip

\noindent{\em Commitment Oracle}: We commit the oracle $\rsoracle$ using
homomorphic vector commitment scheme which allows us to effectively provide
access to ``derived'' oracles, such as those obtained by suitable linear
operations on the oracle. Assume $\FF$ is a prime field and $\comm$ is a
commitment scheme over $\FF^{n_2}$ with randomness space $\FF$ and commitment
space a group $\GG$ with independent generators $g_1,\ldots,g_{n_2}$ and $h$.
For $i\in [p], k\in [n_1]$ define $c_{ik}=\comm(\rsoracle[i,.,k],\delta_{ik})$,
where $X[i,.,k]$ denotes the $n_2$-length vector $(X[i,1,k],\ldots,X[i,n_2,k])$
and $\delta_{ik}$ denotes the commitment randomness. We define oracle
$\comoracle$ as $\comoracle[i,k]=c_{ik}$ for $i\in [p],k\in [n_1]$.

\subsubsection{Bivariate Interleaved Code}
Let $Q(x,y)\in \FF[x,y]$ be a bivariate polynomial with $deg_x(Q) < m$ and
$\deg_y(Q) < \ell$. Then the evaluations of $Q$ on $H$ form an $n_2\times n_1$
matrix whose rows are codewords in a Reed-Solomon code, which we call $L_1$ and columns
are codewords in a Reed-Solomon code which we call $L_2$. Let $d_1$ and $d_2$
denote the minimum distance of the codes $L_1$ and $L_2$
respectively.\smallskip

\noindent{\em Proximity Protocol for BIC}: We
describe a protocol for ``proximity'' of a purported codeword to bivariate
interleaved code. Let $U\in \FF^{n_2\times n_1}$ denote the purported codeword and let
$e<\min(d_1,d_2)/3$ denote the proximity parameter. In its first message the
prover computes commitments $c_1,\ldots,c_{n_1}$ to the columns of $U$ and
sends it to verifier. Thereafter the prover and the verifier interact as
follows:
\begin{enumerate}[{\rm 1.}]
\item $\prover\rightarrow \verifier$: Commitments $c_1,\ldots,c_{n_1}$ to the
columns of $U$.
\item $\verifier\rightarrow \prover$: Verifier samples $\gamma\sample
\FF^{n_2}$ and $\tau\sample \FF^{n_1}$ and sends to the prover.
\item $\prover\rightarrow \verifier$: The prover computes $w_1=\gamma^TU$ and
$w_2=U\tau$. It computes commitment $\mathsf{cm}_1$ to the
vector $w_1$ and sends it to the verifier (the commitment to $w_2$ can be computed by the
verifier). 
\item $\verifier\rightarrow \prover$: Verifier samples subset $Q_1\subseteq
[n_1]$ of size $t$ and sends it to the prover.
\item $\prover\rightarrow\verifier$: The prover sends $w_1[k]$ for $k\in Q_1$.
\item The prover and the verifier run the subprotocols to check:
  \begin{itemize}
  \item $w_1\in L_1$ and $w_1=\gamma^TU$.
  \item $w_2\in L_2$ and $w_2=U\tau$.
  \end{itemize}
\end{enumerate}
We now describe the subprotocols used in the above protocol.
Let $H_1\in \FF^{n_1\times (n_1-\ell)}$ and $H_2\in \FF^{n_2\times (n_2-m)}$
denote the parity check matrices for the codes $L_1$ and $L_2$
respectively. For the first subprotocol, given the vector commitments
$c_1,\ldots,c_{n_1}$ to the columns of $U$ and commitment $\mathsf{cm}_1$ for
the vector $w_1$ (note that the vector is only revealed on positions in $Q_1$), the verifier checks the following inner products:
\begin{itemize}
\item $\innp{\gamma}{U[.,k]}=w_1[k]=\innp{w_1}{e_k}$ for all $k\in Q_1$.
\item $\innp{w_1}{H_1[k]}=0$ for all $k\in [n_1-\ell]$.
\end{itemize}
The first set of inner products, probabilistically check the relation
$\gamma^TU=w_1$ by checking it only on the index set $Q_1$. As we shall see,
this is sufficient to verify the desired relation with high probability. The
second check verifies membership of the $w_1$ in $L_1$ by checking
$w_1^TH_1=\bm{0}$. The former check reduces with high probability to inner
product checks (i) $\innp{\gamma}{\sum_k
\delta_kU[.,k]}=\innp{\delta}{w_1|_{Q_1}}$ and
$\innp{w_1}{\sum_k\delta_ke_k}=\innp{\delta}{w_1|_{Q_1}}$ for a randomly
$\delta\sample \FF^t$. Note that
commitments to all the vectors required in above inner products are available
to the verifier. The check $\innp{w_1}{H_1[k]}=0$ for $k\in [n_1-\ell]$
similarly reduces to a single inner product check $\innp{w_1}{H_1s}=0$ for a
random $s\sample \FF^{n_1-\ell}$. 

Next we check $w_2\in L_2$ and $w_2=U\tau$. The verifier homomorphically
computes commitment $\mathsf{cm}_2$ to $U\tau$ and uses this as the commitment
for $w_2$ in the inner product protocols to enforce $w_2=U\tau$ (with high
probability). The check $w_2\in L_2$ is done as in the previous case, since we
know the commitment to $w_2$.

\begin{lemma}\label{lem:soundbic}
For any prover $P^\ast$ that succeeds in the above protocol, there exists
extractor $\mc{E}$ with rewinding access to $P^\ast$ which extracts an
$e$-close oracle $U$ with overwhelming probability.
\end{lemma}
\begin{proof}
For any $\ppt$ adversary $\adv$, let $\advantage{com}{\adv,\comm}$,
$\advantage{ip}{\adv,{\rm ip}}$ denote $\adv$'s advantage against the
binding property of the commitment scheme $\comm$ and the soundness of the
inner product protocol respectively. Let
$c_1,\ldots,c_{n_1},\mathsf{cm},w_1|_{Q_1}$ be the prover's messages
$\gamma,\tau,\delta,s,Q_1$ be verifier's challenges in an accepting transcript.
Then running the ``extractor'' $\mc{E}$ for the inner product protocols (with
rewinding oracle access to $P^\ast$), the adversary $\adv$ extracts witnesses
$w'_1,w''_1,w'_2$ and $u,u_1,\ldots,u_{n_1}$ such that:

\begin{itemize}
\item $\innp{w'_1}{\sum_k\delta_ke_k}=\innp{\delta}{w_1|_{Q_1}}$ and
$\comm(w'_1)=\mathsf{cm}_1$.
\item $\innp{w''_1}{H_1s}=0$ and $\comm(w''_1)=\mathsf{cm}_1$.
\item $\innp{\gamma}{u}=\innp{\delta}{w_1|_{Q_1}}$ and $\comm(u)=\sum_{k\in
Q_1}\delta_kc_k$ (using additive notation for commitments).
\item $\comm(u_k)=c_k$ for $k\in [n_1]$. We assume the extractability of
columns $u_k$'s corresponding to commitments $c_k$'s because by rewinding
sufficient times the extractor can extract openings for different linear
combinations of $u_k$'s, and use those to extract individual openings.
\item $w^{'T}_2H_2 = \bm{0}$ and $\comm(w'_2)=\sum_{k\in n_1}\tau_kc_k$.
\end{itemize}
In the event that the adversary $\adv$ does not break the binding property of
the commitment scheme or the soundness of the inner product protocols, we must
have $w'_1=w''_1=w$(say), $u=\sum_{k\in Q_1} \delta_ku_k$. Now with very high
probability (because challenges $\delta,\gamma,s$ were random) we must have:
$w\in L_1$, $w|_{Q_1}=w_1|_{Q_1}$ and $\innp{\gamma}{u_k}=w_1[k]=w[k]$ for all
$k\in Q_1$. Similarly $w_2=\sum_{k\in [n_1]}\tau_ku_k$ and $w_2\in L_2$. From
Lemma \ref{lem:proximitytest}, with overwhelming probability the oracle
$U=[u_1,\ldots,u_{n_1}]$ is $e$-close to both the interleaved codes.  
\end{proof}
