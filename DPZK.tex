\section{Distributed Prover Zero Knowledge}
Framework
\begin{itemize}
\item Proof size independent of no. of parties.
\item Notion of homomorphic oracles
\item custom aggregation protocols for non-homomorphic messages
\item concrete improvements and adjustments to obtain sublinear communication for custom MPC. - only for interactive part of circuit
\end{itemize}

\subsection{Definition of DPZK}
Consider a language $L \in \npol$ and the corresponding relation $R \in \pol$ such that
\[
\stmt \in L \Leftrightarrow R(\stmt, \wit)=1 \text{ for some witness } \wit
\]
Let $\prover_1, \ldots, \prover_{\Num}$ be $\Num$ provers. In our setting, we let each party have an additive share of the witness $\wit$. For party $i \in [\Num]$, let $\wit_i$ be its share.  The witness $\wit$ and its shares have length equal to the number of input wires of the circuit $\C$ representing the relation $R$. We will discuss later in this section why we decided to do an additive share of the witness. For now, note that a partition of the witness among the provers such that each prover owns a non-intersecting piece of the witness is a sub-class of additive sharing since the share of a prover can be its partition of the witness padded with zeros in the rest of positions.


A DPZK protocol consists of three probabilistic polynomial time algorithms: $(\Setup, \Pi, \verifier)$. 
\begin{itemize}
\item $\Setup$ takes as input the security parameter $1^\secp$ and optionally a trapdoor $\tau$ and outputs the public parameters $\sigma$ of the system.
\item The interactive proof system is an $\round$-round protocol $\langle \Pi = \{\pi_i\}_{i \in [\round]}, \verifier \rangle$ where in every round $i \in [\round]$, we have the output $m_i$ of $\Exec^{\pi_i}(\st^i_1, \ldots, \st^i_{\Num})$ provided to $\verifier$. Here, $\st^i_j$ is the state of the prover $\prover_j$ at round $i$. $\st^1_j$ is set to $\prover_j$'s share of the witness $\wit_j$ and the public parameters $\sigma$ and updated later as the protocol proceeds. The output of $\verifier$ is either an $\tt accept$ (1) or a $\tt{reject}$ (0). Also, let $\tr$ be the transcript of the protocol.
\end{itemize}
A $\DPZK$ protocol for a language $L$ satisfies the following properties: 
correctness, soundness, zero-knowledge and privacy among provers.
\dnote{self: give a name for Privacy among provers}
\paragraph{Completeness}: %We will define correctness assuming that the witness set is minimal.
Given $\sigma \gets \Setup(1^\secp, \tau)$ and a valid witness $\wit$ corresponding to $\stmt \in L$, when the initial states are set with $\sigma$ and the shares of $\wit$, $\langle \Pi, \verifier \rangle$ outputs 1 with probability 1.

\paragraph{Soundness}:  The basic definition of soundness ensures the existence of a valid witness for $\stmt \in L$. For every instance $\stmt \notin L$ and any $\ppt$ algorithm $\Pi^*$, $\verifier$ accepts with probability at most $\negl(\secp)$.

The notion of proof of knowledge of the witness by the prover is captured by the notion of knowledge extraction where an extractor extracts the witness whenever the verifier accepts using an oracle access to the prover. The stronger notion of witness extended emulation \cite{Lindell03} proposes the existence of an emulator which additionally produces a simulated transcript between the prover and the verifier irrespective of whether the verifier accepts or not. We will now define the notion of witness-extended emulation for the $\DPZK$ setting, adapted from \cite{Groth11}. 
\begin{definition}
The argument $(\Setup, \Pi, \verifier)$ has computational witness-extended emulation if for all deterministic polynomial time $\Pi^*$ there exists an expected polynomial time emulator $\chi$ such that for all non-uniform polynomial time adversaries $\adv$ and all $\tau$
\begin{align*}
& Pr \left[\sigma \leftarrow \Setup(1^\secp, \tau); (\stmt, \{\wit_i\}_{i \in [\Num]}) \leftarrow \adv(\sigma); \tr \leftarrow \langle \Pi^*, \verifier \rangle: \adv(\tr) = 1 \right] \\
\approx \; & Pr \left[\sigma \leftarrow \Setup(1^\secp, \tau); (\stmt, \{\wit_i\}_{i \in [\Num]}) \leftarrow \adv(\sigma); (\tr, \wit) \leftarrow \chi^{\langle \Pi^*, \verifier \rangle}(\sigma, x): \right. \\
&\;\;\; \adv(\tr) = 1 \left. \text{ and if } \tr \text{ accepts then } \stmt \in L \text{ with } \wit \text{ as witness} \right] 
\end{align*}
where $\chi$ has access to the oracle $\langle \Pi^*, \verifier \rangle$ which produces the transcript. $\chi$ can rewind $\langle \Pi^*, \verifier \rangle$ to any round and resume the protocol with fresh randomness from the verifier.
\end{definition}
%.\dnote{1. should the notation $\langle \Pi, \verifier \rangle$ be modified to also take their respective inputs?\\
%2. Proof of knowledge \textit{vs} argument of knowledge}
Note that this follows from the single prover definition since an adversarial prover in the single prover definition can be any $\ppt$ algorithm, and this is independent of whether the $\ppt$ algorithm is run by a single prover or a protocol between multiple provers.
Also, allowing for any adversarial $\Pi^*$ captures adversarial behaviour by all the parties.

\paragraph{Zero-knowledge}: 
The traditional notion of zero-knowledge ensures that the proof does not reveal any information beyond the fact that the instance is in the language.
This is a property with respect to the view of the verifier $\verifier$. The protocol $\Pi$ and the number of provers involved to produce these messages do not impact the zero-knowledge property. The following definition captures this formally.
\begin{definition}
The argument $(\Setup, \Pi, \verifier)$ is a special honest verifier zero-knowledge argument for $L$ if there exists a PPT simulator $S$ such that for all non-uniform polynomial time adversaries $A$ and all $\tau \in \secp^{O(1)}$ 
\begin{align*}
&Pr \left[ \sigma \leftarrow \Setup(1^\secp, \tau); (\stmt ,\wit ,\rho) \leftarrow \adv(\sigma); \tr \leftarrow \langle \Pi, \verifier_\rho \rangle: \stmt \in L \text{ with witness } \wit \text{ and } \adv(\tr)=1 \right] \\
\approx \; &Pr \left[\sigma \leftarrow \Setup(1^\secp, \tau); (\stmt,\wit,\rho) \leftarrow \adv(\sigma); \tr \leftarrow S(\sigma,\stmt,\rho): \stmt \in L \text{ with witness } \wit \text{ and } \adv(\tr) = 1 \right]
\end{align*}
\end{definition}
%.\dnote{Auxiliary input zk or just without it?}

\paragraph{Privacy among parties}:
This notion captures the privacy of a prover's share of witness from other provers. The provers interact to generate shares of the extended witness $\extwit$ and then to compute the messages to be sent to the verifier. The privacy notion here can be formalized as multi-party computation protocols among the provers. The transcript of the interaction between provers can be simulated by a simulator with access only to the secret inputs of the corrupted provers and the final output of the interaction. Hence, for a protocol supporting $t$ corruptions, the input witnesses of the remaining honest prover cannot be inferred by an adversary possessing the inputs and controlling the actions of these $t$ provers.
%\dnote{ include formal definition}
%Whenever provers interact, there is a simulator with access to corrupt provers' input and output of the interaction can generate a transcript which is indistinguishable (computationally) from a real transcript. 

\begin{definition}
Let $T\subseteq [\Num]$ be the set of corrupt parties and let $m_i$ be the output of $\Exec^{\pi_i}(\st^i_1, \ldots, \st^i_{\Num})$. An argument $\innp{\Pi = \{\pi_i\}_{i \in [\round]}}{\verifier}$ with $\Num$ provers has $t$-privacy if for any $T$ of size $\leq t$ and for every round $i \in [\round]$, there is a $\ppt$ simulator $\Sim$ such that the following holds: 
\[
 \{ \Sim (\stmt, \st^i_T, m_i) \} \stackrel{c}{\approx}  \View^{Real, i}_T ( \stmt, \{\st^i_j\}_{j \in [N]}) 
\]
where $\st^i_T$ is the state of the parties in $T$ for the $i$th round, and $\View^{Real, i}_T$ is the view of the parties in $T$ during an honest execution of $\pi_i$.
\end{definition}
.\dnote{Write a formal definition that captures the linear composability between the protocols.}

\paragraph{Zero Knowledge under $t$-collusions}: 
The notion of zero-knowledge, as we discussed earlier, considers the knowledge gained by a verifier on seeing the proof. But when there are multiple provers, this does not capture the setting where the verifier colludes with a subset of provers trying to learn information about the witness shares of the remaining provers. We define the notion of zero knowledge under $t$-collusions ($t-\ZKUC$) to capture this.

\begin{definition}
An argument $\innp{\Pi}{\verifier}$ with $\Num$ provers has the property of computational zero-knowledge under $t$-collusions ($t-\ZKUC$), if for every $\ppt$ interactive machine $\verifier^*$ and any subset of colluding provers $T\subseteq [\Num]$ of size $\leq t$, there exists a $\ppt$ algorithm $\Sim$ such that the following holds for any instance $\stmt \in L$ with witness $\wit$ and for any $\rho$: 
\[
\innp{\Pi(\stmt, \wit)}{\verifier^*(\stmt, \rho, \wit_T)}  \stackrel{c}{\approx}  \Sim (\stmt, \rho, \wit_T)
\]
where $\wit_T$ is the input of the provers in $T$. 
\end{definition}

\begin{theorem}\label{theo:equivalent}
	A $\round$-round$\DPZK$ protocol $\innp{\Pi}{\verifier}$ has Zero-knowledge and $t$-privacy among provers property if and only if it has Zero-knowledge under $t$-collusion.
\end{theorem}

\begin{proof}
	\textbf{case 1:} Let $\innp{\Pi}{\verifier}$ has Zero-knowledge and $t$-privacy among provers property. That implies there are simulators $\Sim_{ZK}$ and $\Sim_{P}$ for which 
	\begin{align*}
		&\{ \innp{ \Pi( \wit ) }{ \verifier^*( z ) } ( \stmt) \} \stackrel{c}{\approx} \{ \langle \Sim_{ZK} \rangle(\stmt, z) \} \cdots (1)\\		
		\text{for all }i \in [\round] \text{, } &\{ \innp { \prover_{\overline{T}}( \st^i_{\overline{T}} ) } { \prover_T ( \st^i_T ) } ( \stmt ) , m \}
	 \stackrel{c}{\approx} \{ \langle \Sim_P \rangle (\stmt, \st^i_T, m) \} \cdots (2)
	\end{align*}
	
	A transcript of an execution of $\innp{\Pi}{\verifier^*}$ will have two types of values:

	\begin{itemize}
		\item Interaction among the prover and the verifier.
		\item Interaction among the provers to generate the next message.		
	\end{itemize}
	Now we will design a simulator $\Sim$.
	
	$\Sim$ on input $\stmt, \wit_T, m$ does the following: 
	\begin{itemize}
		\item If $\Sim$ requires to generate a value which is due to interaction among the prover and the verifier, then $\Sim$ calls $\Sim_{ZK}$ on input $\stmt, \wit_T$ and includes the output in the transcript.
		\item If $\Sim$ requires to generate a value which is due to interactioin among the provers, then $\Sim$ calls $\Sim_{P}$ on input $\stmt, \st^i_T, m_i$, where if $i=1$ the $\st^i_T = \wit_T$ other set $\st^i_T$ from the output of the simulators in the previous step, then include the output in the transcript.
	\end{itemize}
	The following hybrids prove that $\Sim$ generates a transcript which is indistinguishable from an actual transcript.:
	\begin{itemize}
		\item[$H_0$:] Real transcript
		\item[$H_1$:] Real transcript for interaction among provers and simulated transcript for zero knowledge generated by $\Sim_{ZK}$
		\item[$H_2$:] Simulated transcript for interaction among provers generated by $\Sim_P$ and simulated transcript for zero knowledge generated by $\Sim_{ZK}$
	\end{itemize}

	$H_0 \stackrel{c}{\approx} H_1$ due to Zero-knowledge property
	
	$H_1 \stackrel{c}{\approx} H_2$ due to $t$-privacy among provers
	
	These two relation implies $H_0 \stackrel{c}{\approx} H_2$.
	
	That implies $\innp{\Pi}{\verifier}$ has Zero-knowledge under $t$-collusion property.
	
	\textbf{case 2:} Let $\innp{\Pi}{\verifier}$ has $t$-ZKUC property.
	
	Then it is obvious that $\innp{\Pi}{\verifier}$ has $ZK$, it just a special case of $t-ZKUC$, when $t=0$.
	
	Now we will prove that $\innp{\Pi}{\verifier}$ has $t$-privacy among provers property. 
	
	If not, let there is a set $T\subseteq [\Num]$ of size $leq t$ for which during the interaction among the provers, adversary corrupting provers in $T$ learns a function $h(\wit)$ which can not be computed by the advesary i.e. $h(\wit)$ cannot computed using $\stmt, \wit_T, m, z$. Therefore $\verifier^*$ is learning $h(w)$, which he is not supposed to learn. That imples $\innp{\Pi}{\verifier}$ does not have ZKUC property, contradiction.
	
	Therefore $\innp{\Pi}{\verifier}$ has $t$-privacy among provers and Zero-knowledge property.
\end{proof}


\paragraph{Efficiency measures}
In addition to the efficiency measures used for single-prover protocols, $\DPZK$ protocols are also measured in terms of the complexity and number of rounds involved in the communication between the provers. We now state all the efficient measures used to quantify a $\DPZK$ protocol.
\begin{enumerate}
\item Complexity of $\Pi$: The protocol $\Pi$ is measured in terms of the following complexities:
\begin{itemize}
\item \textit{computation} complexity for the provers
\item total \textit{communication} complexity between the provers
\item number of \textit{rounds} of communication between the provers
\end{itemize}
\item Verifier complexity
\item Proof size
\end{enumerate}

\subsubsection{Circuit share complexity}
Consider a relation where the witness is \textit{partitioned} among the provers in the $\DPZK$ setting. We define a new notion of efficiency for a $\DPZK$ protocol which would become a prominent efficiency measure for a class of real-world applications.
Let \textit{shared circuit} denote the part of the circuit representing the relation whose wire values are functions of inputs from more than one prover. 
We introduce the notion of \textit{circuit share complexity} to denote the size of this shared circuit.
Consider the class of applications where hashes (or any other commitment) of data from different parties are stored on a blockchain and a zero-knowledge proof has to be generated on an aggregation of all the data. This could be: 
\begin{enumerate}
\item Finance network: different bank account holders proving to a loan provider that the sum of their account balances is greater than the required threshold.
\item Trade logistic network: different logistic providers proving to a customer or regulator that the average delay of shipment along a particular route is less than a specified time.
\end{enumerate}
In all the applications in this class, each party participating in the aggregation first proves the \textit{relevance} of his/her data before they all run a protocol to prove the aggregated value on their data together. The proof of relevance involves proving that the data corresponds to a commitment in the blockchain network by proving the knowledge of the opening of a commitment in the blockchain. 
For instance, when using verifying a hash commitment within a proof system which works with circuit representation of the relation, the proofs of relevance i.e. the hash verifications of the individual data take up most of the gates in the circuit. But each such verification rely only on data from a single party. The aggregation does involve data from multiple parties but this step requires a relatively smaller number of gates. Hence, the circuit share complexity is very small for such applications, compared to the total size of the circuit. A DPZK protocol with its complexities proportional to the circuit share complexity instead of the total circuit complexity can attain major savings for such applications.
In general, the compatibility of the commitment with function representation of the proof system plays a part in the above discussion. We will discuss the relevant work on this compatibility in more detail in Section \ref{sec:relatedwork}.

Looking ahead, the complexity of the interaction between the provers in our DPZK protocol will be linear only in the circuit share complexity of the circuit predicate to be proven, and not in the \textit{total} size of the circuit. 
 
\subsubsection{Discussion}
Discussion on the definition.

Discussion on the sharing the witness among the parties instead of partitioning the witness.
\begin{itemize}
\item clarity in defining definitions?
\end{itemize}

%\subsection{Construction step 1: The introduction of homomorphic commitments}
%
% -- some technical description of the techniques, and how "commitment oracle"
%helps in realizing DPZK
%
%\paragraph{Note} If we did not use homomorphic commitment we get +poly(secp).N protocol.
