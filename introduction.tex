\section{Introduction} \label{sec:intro}
In a zero-knowledge proof protocol, a verifier tries to verify that an instance $x$ is in a language $L$. A prover with a witness $w$ to $x \in L$ tries to convince the verifier on this without revealing any additional information to the verifier than what she already knows. Be it proving that a user is single-spending a coin that he has earned before in a private manner \cite{zerocash} or validating sensitive web browser data reported during telemetry \cite{MozillaPrio}, ZK protocols have garnered immense interest over the last few years. Still in the dream of a decentralized world, there are multiple co-opetitive entities interacting with each other to obtain insights and maximize their goals. A desirable goal is to enable these mutually distrusting entities to prove a predicate on their joint data. But, the traditional \textit{single-prover} ZK setting is restrictive here since there is a single prover holding the entire witness required to prove the predicate. 

%\pdnote{do we want to motivate it in a way such that the honest prover setting we are looking at will suffice for the listed applications? }
In this work, we study the general setting of \textit{distributed prover zero-knowledge protocols} ($\DPZK$) where multiple co-opetitive i.e., collaborating but mutually distrusting entities each possessing their own secret data want to prove to a verifier that their secret data together satisfies a predicate of common interest. This is done without revealing any information about their sensitive data to each other or to the verifier, more than what each of them know about it beforehand. Some real-world applications follow:
\begin{itemize}
\item A simple but pertinent scenario is of a \textit{joint loan application} by an association of companies from a particular industry. The loan issuer has a set of financial requirements that it wants the association to satisfy, but there is no single trusted entity to act as the prover whom all the companies are willing to provide their sensitive business information with.
\item In cryptocurrency settings \cite{bitcoin, ethereum, zerocash}, this would enable a \textit{multi-wallet transaction} where the wallets are held by different parties or a \textit{proof of joint stake} where the stake is held by different parties. These in turn enable secure collaboration applications by design on a blockchain network. % use it for joint auction-
\item In trade logistics business networks \cite{scbn, e2open, tradelens}, a major reason for businesses to enter these networks is to benefit from cross-industry statistics. Publishing these statistics in a publicly verifiable manner without having a single trusted entity is another embodiment of this setting.
\end{itemize}

In abstract terms, we have multiple provers $\prover_1, \ldots, \prover_{\Num}$ respectively possessing witnesses $\wit_1, \ldots, \wit_{\Num}$. For a predicate $C$ from the supported class of predicates $\cC$, the provers want to prove to a verifier that $C(w_1,\cdots,w_{\Num}) = 1$.
A natural solution for distributed proof generation is to start with the prover algorithm from a single prover protocol and run this algorithm between multiple provers using multi-party computation (MPC). Pedersen \cite{Ped92} proposed this notion and discussed this generic construction using MPC.
%Each round of proof generation is implemented by an MPC among the provers to generate the message to be sent to the verifier.
The generic construction is optimal in proof size and verifier complexity in that it retains these complexities from the single-prover version irrespective of the number of provers. But, the complexity of proof generation suffers when the single prover protocol is not constructed with distributed proof generation in mind. Even an optimal $\round$-round proof generation algorithm with $O(N)$ multiplicative complexity of the prover's computation might result in a distributed proof generation algorithm with $\Omega(R \cdot N)$ communication among the provers.
Prior works have improved the complexity of distributed proof generation $o(R \cdot N)$, but only when considering simple predicates involved in threshold signatures \cite{DDS}, some sigma protocols \cite{EfficientTZ} and range proofs \cite{bulletproofs}, or when working in the trusted setup setting with a weaker adversarial model of majority of parties being honest \cite{trinocchio}.

The goal of this work is to study zero-knowledge protocols with efficient distributed proof generation, informally an ``MPC-friendly'' proof generation, while supporting \textit{arbitrary} predicates. %The proof generation algorithm is usually measured for efficiency in terms of number of group operations and number of rounds of interaction with the verifier.
Our work first identifies complexity measures that a ZK protocol should optimize for to admit efficient distributed proof generation. We then construct a ZK protocol which is the state-of-art in these parameters. The discussions will focus on {\em public-coin honest-verifier} protocols with a transparent setup, which is essentially the setting for real-world applications: 1) protocols with such verifiers can be converted to succinct non-interactive  arguments (zk-SNARGs)  via the Fiat-Shamir transform \cite{FS86, BCS16}, and  2) generating the parameters of the protocol should ideally {\em not} involve a trusted third party. The next few subsections elaborate on the new efficiency measures, formal definition and our new construction for DPZK that itself relies on a new single-prover ZK.

\subsection{Efficiency parameters for $\DPZK$}
In the single-prover setting, the efficiency of a proof generation algorithm is usually measured in terms of: 
\begin{itemize}
\item the number of arithmetic operations performed by the prover, referred as \textit{prover complexity}, with the number of group/field multiplications dominating the costs
\item proof/argument size denoted as $\zkcomm$ that refers to the amount of communication from the prover to the verifier
\item verifier complexity
\item the number of \textit{rounds} ($\zkrounds$) of interaction between the prover and the verifier. %especially when a non-interactive prover is obtained from its interactive version in a provably secure manner \cite{BCS16}.
\end{itemize} 
But, these parameters do not capture the core bottleneck in the setting of multiple provers.  
%For instance, Spartan \cite{spartan} has an $O(N \log N)$ \commentA{unclear; you mean no. of multiplication or overall arithmetic operations? } proof generation algorithm, but due to the high multiplicative complexity of proof generation its straightforward distributed version requires $O(N^2)$ MPC multiplications where $N$ is the number of gates in the circuit representation of the predicate being proved.  \commentA{intuitively explain why the jump from $NlogN$ to $N^2$ happens}%Similar arguments will be made in a future section for the other state-of-art protocols like Aurora \cite{aurora}, Bulletproofs \cite{bulletproofs}. \dnote{mention the asymptotics in the above claims}
As a first step in our work, we identify parameters with significant impact in distributed proof generation. 

\paragraph{Proof generation communication ($\prcomm$)}
%The first parameter of interest is \textit{proof generation communication} $(\prcomm)$. 
This quantifies the amount of communication between the provers during the distributed proof generation. In general, this grows linearly with the circuit complexity of the proof generation algorithm for the practical MPC protocols. 
%\dnote{I am saying "practical" because there are RAM based protocols which do better than circuit complexity of the algorithm.}
But, there also exist MPC protocols, the secret-sharing based MPC protocols \cite{GMW87, BGW88, SPDZ}, where the communication is only dependent on the number of cross-multiplications i.e., the multiplications between the witness bits from different parties. %This parameter \textit{circuit share complexity}, which we will explain later, will be relevant in many real-world applications. 

%\commentA{section 1.2 should be here, circuit share complexity is related to cross multiplications which is what you talk above. in its current location, it is not clear if it is another parameter of DPZK. If it is, it should be part of this section. To me, it looks like a parameter that impacts both proof generation and proof generation rounds. So after explaining both this parameters, say that we identify a common parameter called 'circuit share complexity' that impacts both in bla bla way. But the above four parameters will be the ones we use for stating the complexity of our protocols and for the purpose of comparison  }
%, since an affine function over the witnesses and a multiplication between witness bits from the same prover can be computed without any interaction in a secret-sharing based MPC.

\paragraph{Proof generation rounds ($\prrounds$)}
%The next parameter of interest is the number of \textit{proof generation rounds ($\prrounds$)} which 
This indicates the number of rounds of communication between the provers during the distributed proof generation. In a typical MPC, this parameter would be a constant number for the garbled-circuit based protocols and be the cross-multiplicative depth of the circuit for the secret-sharing based protocols. But in our setting of distributed proof generation, the provers have to compute their message for that round, in clear, to be sent to the verifier. Thus, even a garbled-circuit based approach here might result in $\prrounds$ be linear in the number of $\zkrounds$, and hence not a constant with respect to the size of the instance unless $\zkrounds$ is also a constant. 
%\commentA{it's hard to digest the above; what's the point you are trying to make; some of the zkRounds do not need MPC and hence we can get read of the linear independence of prRounds from zkRounds?  }
%\dnote{The above point makes sense only for the interactive version. Should we also argue for non-interactive proof generation?-that it requires us to do hash inside MPC if MPC is not done for each step.} 
%\commentA{I didn't understand your comment. other can help?}
This parameter $\prrounds$ is also of cryptographic interest. If there is more than one round of prover message generation which requires MPC, care has to be taken to ensure a secure composition of the individual MPCs to prove the complete protocol secure.

\paragraph{Shared circuit complexity}
We will now elaborate a bit more on the notion of cross-multiplication since that is of practical relevance and influences $\prcomm$ and $\prrounds$. In applications where the initial witness is \textit{partitioned} among the provers, the term \textit{shared circuit} denotes the part of the circuit whose wire values are functions of inputs from more than one prover. Consider the earlier example of a trade-logistics business network, now on top of a blockchain where the hashes (or any other commitment) of large number of data points from different participants are stored on the blockchain. When parties come together to prove a statistic on their combined data, they first prove that each data point used to compute the statistic corresponds to a hash entry in the blockchain, and then prove the result of the statistic on these data points. But here, the value of the circuit wires for the part on hash verification depend only on witness bits from a single party. Only the part of the circuit computing the statistic will take witness bits from multiple parties. With the standard SHA hash function having around 30 thousand gates, and with a hash circuit required for each data point, the practicality of a zero-knowledge protocol will be heavily improved if its parameters like $\prcomm$ and $\prrounds$ are linear in the size of the shared circuit $N_s$ and not the total circuit size $N$.
%Looking ahead, the complexity of the interaction between the provers in our DPZK protocol will be linear only in the circuit share complexity of the circuit predicate to be proven, and not in the total size of the circuit. 

 In summary, the efficiency of a DPZK in the public-verifiable and non-interactive setting (which is our concern) will be measured via four parameters:  $\prcomm$,  $\prrounds$, proof-size and verifier computation complexity. While the latter two parameters are relevant in both single and multi prover settings, the former two are exclusively meant for DPZK protocols.    

\subsection{On the formal Definition of $\DPZK$}
%\commentA{changed the title of this subsection and the text below sightly} 
The primary departures that the security definition of $\DPZK$ witness compared to the  traditional single-prover ZK are concerning the zero-knowledge property.     
%Before we delve into our DPZK construction, we would also provide a couple of subtle notes regarding the zero-knowledge property of DPZK protocols. This would shed some light on the rationale for some of the artefacts of DPZK protocols. 
In an $\DPZK$ protocol, the verifier is allowed to collude with a subset of provers to learn the witnesses of the other provers. A strong definition of zero-knowledge should ensure that this collusion does not learn any additional information than what they know before the protocol. %Here, one should also consider the number of other provers involved in the proof generation as an additional information. In our protocols, we will allow all the provers to know the total number of provers involved. This will lead to a relaxed definition where a verifier colluding with a prover will additionally learn the total number of provers\pnote{usage of broadcast reveals the number of provers even without collusion}. This still does not let a standalone verifier learn the total number of provers during its interaction with the provers.

%\commentA{I am not finding the following paragraph pressing. Should we remove? }\dnote{This is to emphasize the need for public key ops or communication in oracle generation/answering too. I cut it short though.}
%This subtle note also impacts the size of the oracles for the protocols in the IOP framework \cite{aurora, ligero}. The oracle and the answers to the oracle queries should be independent of the total number of provers. Hence, for the IOP-based protocols, the efficiency parameters discussed above should be optimized not only for the prover message generation but also for the oracle generation and the query answering.\footnote{In principle, generating the oracle or answering a query would form a part of the prover message generation when IOP is viewed in the lens of an arbitrary interactive protocol.}
%The IOP-based protocols in the literature \cite{aurora, ligero} market their non-use of public-key cryptography and thus a potential post-quantum security feature. To achieve zero-knowledge in the distributed prover setting while retaining these features, at a high level, they have to incur the additional overhead in $\prcomm$ due to using information-theoretic MPC to also construct the oracle and answer oracle queries. 

Another subtle point here is that a single-prover ZK protocol provides the zero-knowledge property only for honest provers. The witness is not guaranteed to be hidden from the verifier if a prover deviates from the protocol. Hence, in a distributed prover setting it is non-trivial to prove or even define the zero-knowledge property if some of the provers deviate from the protocol or if they do not have the valid witness. 

We come up with an MPC-style definition based on real-world ideal world paradigm \cite{Canetti00,Goldreich2001,Lindell17,CohenL14}  that takes the above issues into account. In the ideal-world, the provers deliver their respective part of the witnesses and the functionality (that is parametrised with a language) combines them and check the assertion of a statement. In the real protocol,  the provers participate in  instances of MPC for `proof-generating functions' to generate messages for the verifier. To hide the number of provers from a corrupt verifier and to keep the proof-size  independent of the number of provers, one of the provers enacts in a special role called aggregator   that prepares the message for the verifier taking into account communication from all its fellow provers and communicates the same to the verifier on behalf of all the provers. We say our protocol is secure if whatever an adversary (corrupting various subset of provers and verifier) can do in real execution can be done in the ideal execution. Lastly, keeping in mind the final goal of non-interactive and publicly-verifiable proofs/arguments, we explicitly mention the exact corruption scenario that we handle for our constructions.  For example, it is enough to tackle a semi-honestly corrupt verifier (since a non-interactive proof does not give any additional scope of misbehaviour to a maliciously corrupt verifier  over a semi-honestly corrupt one).  We refer to Section~\ref{sec:security model} for complete details. Next, we move on to discuss the single-prover construction on which we build our DPZK. 
To preserve the privacy, we assume that provers are not going to deviate from the protocol, since that may lead to rejection of the proof, though our protocol can withstand the scenario if all the provers are maliciously corrupt together due to the soundness property of the underlying ZK protocol.% Also, we will discuss how can we achieve security against maliciously corrupt provers (assuming the aggregator \commentA{we have not introduced aggregator} to be semi-honest).

\subsection{\name{}: an MPC-friendly zero-knowledge protocol}
We propose an MPC-friendly single-prover protocol \name{} with a transparent setup which would allow for an efficient  DPZK.
%This linear $\prComm$ is due to linear number of cross-multiplications which can be done concurrently, and hence the MPC is only performed on an $N$ mult-gates circuit of depth 1. 
\name{} achieves proof size and verification complexity competitive with the state-of-art zero-knowledge protocols, while achieving efficient distributed proof generation. In particular, \name{} admits a proof size of $O(N^{1/c})$ for arbitrary $c\geq 2$, and a verification complexity of $O(N^{1-2/c})$ public key operations and $O(N)$ field operations. \name{} is a public-coin honest verifier zero-knowledge protocol in the Interactive PCP (IPCP) \cite{KR08, KR09, GIMS10} paradigm. % that achieves the property of zero-knowledge-with-collusion i.e., the witnesses from a set of provers are not revealed to a verifier even when it colludes with the complimentary set of provers who are honest-but-curious.

%Efficiency Desiderata:  
%- Transparent setup 
%- Minimum interaction between the provers (\# of rounds of MPC) 
%- Total communication complexity of the msgs exchanged
%- verifiers view is indistinguishable from a single prover setting
%- How efficient is underlying zkp protocol (public key operations, size of proof, prover/ verification time)
%- Applicability to a general class of computation

%\paragraph{Technical overview}
%Our goal is construct a zero-knowledge protocol which optimizes all the efficiency parameters: $\zkcomm$ a.k.a., the proof size, $\zkrounds$, provers' complexity (represented by $\prcomm$ and $\prrounds$) and the verifier's complexity. We will now brief the MPC (non-)friendliness of the state-of-art protocols in the setting before we brief \name{}.
%
%Also, its verifier requires $O(N)$ public key operations to verify a proof. 
%Spartan \cite{spartan} admits sublinear verifier complexity in an amortized sense, but its prover again incurs $O(N^2)$ multiplications.

\name{} follows the outline of Ligero: (i) encoding the witness via a suitable error correcting code, (ii) checking linear relations on the witness, (iii) checking quadratic relations on the witness, and (iv) a proximity protocol to check that the witness is correctly encoded. The witness encoding is committed as an ``oracle'' and is queried during the linear, quadratic and the proximity checks.  Our innovations are listed below.
\paragraph{New encoding} A core technical contribution of our work is a novel way to encode the witness and thereby design the three checks in the zero-knowledge protocol around the new encoding. The \textit{witness} is represented as a \textit{3D matrix} of dimensions $p \times m \times s$ whose product is $O(N)$. The \textit{witness encoding} is obtained by encoding every $m \times s$ `slice' of the 3D matrix using a carefully crafted 2D product Reed-Solomon code. %careful crafting: along rows, we interpolate and evaluate with different sets of disctinct points; but along columns, we interpolate with a set of distinct points, and evaluate with the same set of points + some extra disctinct points. For rows, we choose evaluation points distinct from interpolation points because the extra t randoms rows added for ZK should be interpresed during encoding to achieve ZK. But for columns, it is good enough to just encode for soundness and not for ZK, so we can just augment the interpolation points to get the evaluation points. Interestingly, having the evaluation points as an augmentation of interpolation points is \textit{necessary} for us in our protocol to check some properties. \dnote{what properties exactly? for plain correctness, or during some verifier check?}
The \textit{oracle} is now obtained by committing each $O(m)$-sized `column' in the encoded witness using homomorphic vector commitments \cite{Ped92}. 
Our oracle is a $O(p \cdot n)$-sized matrix of commitments. The use of homomorphic vector commitments helps in two aspects: (i) enabling distributed proof generation and (ii) achieving proof sizes independent of the largest dimension of the matrix.
As we will see later, we will be able to regulate the three dimensions such that we get \textit{sub-linear} complexities in both the communication between the provers $\prcomm$ and the proof size $\zkcomm$, when building DPZK based on it. 
% \paragraph{Proximity check} The proximity protocol checks that the encoding is well-formed by verifying that a random linear combination of the slices of the 3D matrix is \textit{near} to a 2D product code, which is a matrix of size $h\times n$. This is sufficient due to the claim, that we prove, that a random linear combination of the rows is far from the codespace if at least one row of the matrix is far from the codespace. A Ligero-style proximity check protocol is additionally performed to check that the encoding used in the above step is the same one that is committed in the oracle. The salient feature of the above two steps is that the proof size $\zkcomm$ is independent of the largest dimension of the witness matrix and linear in the sum of the other two dimensions. We also carefully design the distributed proof generation protocol such that the communication between the provers $\prcomm$ is only linear in the largest dimension.
%\pnote{We don't have a separate proximity check, it is u}
\paragraph{Linear check} The protocol to check the linear relations on the witness starts as in Ligero to reduce the checks to polynomial identity testing. We then design new steps to further reduce this test to multiple inner-product arguments on vectors of lengths linear in the individual dimensions of the 3D witness matrix. An additional check is performed to test the consistency of the inputs used in the inner-products with those committed in the oracle.
\paragraph{Quadratic check} This protocol follows the same set of steps as the linear check, except that additional MPC is required to obtain the inputs for the inner product arguments during distributed proof generation. The MPC will be required for $N$ independent multiplications between the witness bits and this would incur an additional $O(N)$ communication among the provers.\dnote{Check complexity in prev sentence.}  This protocol is presented in Section~\ref{}.

\subsection{\dpname: A new $\DPZK$ protocol}
\commentA{The structure of this section should be as follows:  (a) state what the extract result for $\DPZK$, mentioning the achieved complexities (can plug in the best-known MPC)  (b) tell the high level idea for the approach taken. be concise (c) tell about the difficulties in turning existing spzks to DPZK (d) compare and put the table with asymptotic complexity; (e) report some  of the numbers that we obtain from benchmarking.  }
Building on \name{}, we design our DPZK protocol \dpname{} with the prover communication $\prcomm$ linear in circuit size and a constant number of $\prrounds$. To be more precise, the communication for a $\Num$-prover proof generation would be $O(N_s + \Num \cdot N^{1-2/c})$, where $N_s$ is the circuit share complexity. The provers in \dpname{} are semi-honest in trying to learn each other's witnesses while constructing messages for the verifier. We compare the complexities of \dpname{} with our DPZK construction building on Bulletproofs \cite{bulletproofs}.\footnote{Our DPZK-Bulletproofs construction supporting arbitrary predicates readily follows from their single-prover construction, even though they mention it as an open problem to support arbitrary predicates after they build a distributed proof generation algorithm for range proofs. Our efforts simply distil the multiplicative parts of their inner-product protocol. \pnote{Bulletproofs proof aggregation is not same as distributed proof generation.}} \dnote{is the phrasing in the footnote fine?}

Each prover in \dpname{} starts with an additive share of the witness. Each prover generates an encoding of its witness using the same procedure as in \name{} due to the additive homomorphism in Reed-Solomon encoding and in oracle generation. \dnote{seems like we have to add slightly more details in the description of \name{} so that we can refer to it here to explain the dpzk construction. @Nitin can you take a shot at this paragraph after you augment the technical overview?}

Proving the security of this construction is interesting because of a couple of reasons. The witness shares that the provers start with are additive, but they need not be from a secret sharing of a ``global'' witness. And, even if the provers' shares are secret shares of a global witness with a threshold of $\Num-1$, the aggregator in our construction sees messages from \textit{all} the $\Num$ provers. We prove the security of \dpname{} taking care of these aspects when the provers and the aggregator are semi-honest.\dnote{insert benchmarking numbers for \dpname{} here}

%\subsection*{Distributed proof generation}
%--- Informal notion of Distributed Provers Zero Knowledge Protocol $\innp{\Pi}{\verifier}$--- 
%
%A na\"ive approach to build a $\DPZK$ protocol is to take a single-prover ZK protocol and execute a multi-party computation among the provers of each message to be generated by the prover in the single-prover protocol. This satisfies the required security properties, but suffers in concrete efficiency when MPC is used over the proof generation as a black box. 
%
%\subsubsection*{Need for homomorphic commitments} 
%(Oracle access for IOP).
%The (non-interactive) zero-knowledge proof generation protocols based on the Interactive oracle proofs (IOP) or the Interactive PCP (IPCP) paradigms make use of \textit{oracles}. The prover establishes an oracle based on her witness. Once established, the IOP/IPCP protocols ensure that a prover will not modify the oracle further in the protocol. The verifier queries the oracle later in the protocol to verify some the claims made by the prover. When IOP/IPCP based proof systems are converted into the non-interactive setting, the establishment of the oracle is done by producing a commitment to the oracle entries.
%
%We will now run through a mental experiment on achieving distributed proof generation following the blueprint of the single-prover proof generation algorithm. We desire to not have the proof length depend on the number of parties. As we would discuss in depth later, we would also avoid running an MPC protocol on the proof generation circuit(s) of some zero-knowledge protocol. This would trivially, in theory, satisfy our goals, but it would be very inefficient in practice. The way we satisfy these goals for the establishment of the oracle is by requiring the oracle entries and their commitments satisfy homomorphic properties.
%\dnote{self: Sounds somewhat weak. Make it more compelling.}
%
%\subsection*{Technical summary}
%We will now provide a high-level summary of our work and along the way mention our core ideas.
%
%%Our contributions are two-fold: first in defining and constructing a zero-knowledge protocol with distributed proof generation and the second in proposing the first protocol with (expected) sub-linear verifier complexity.
%
%Our main contribution is defining and constructinf a zero-knowledge protocol with distributed proof generation.
%
%\paragraph{DPZK}
%We design a framework for constructing DPZK protocols starting from a single-prover ZK protocol.
%%To construct our DPZK protocol \name{} we follow the strategy of designing a (public coin honest verifier) single-prover ZK protocol whose proofs are ``aggregatable'' at minimal cost. 
%Let the parties $\prover_1, \ldots, \prover_{\Num}$ hold their respective witnesses $\wit_1, \ldots, \wit_{\Num}$ to the relation $R(\stmt, (\wit_1, \ldots,\wit_{\Num}))$. 
%Starting with a (public coin honest verifier) single-prover ZK protocol, there are two steps involved in our proof generation.
%\begin{itemize}
%\item The first step involves performing a secret sharing based MPC protocol on $R$ between the provers. As a result, each prover obtains her share of the extended witness, which includes all the wires (correspondingly variables) of a circuit (correspondingly R1CS) representation of R. 
%\item Next, for each message from the prover to the verifier, the parties perform the following two steps:
%\begin{itemize}
%\item The parties run an MPC protocol to obtain their share of the message. This step has a major implication on the efficiency of distributed proof generation. Depending on the single-prover protocol, some messages already posses homomorphism properties. Hence, the output of a local run of the single-prover algorithm for this round on a prover's shares of extended witness is already her share of the message in the distributed proof generation. When the message is not homomorphic, we design custom efficient protocols to obtain the shares of the message.
%\item One of the prover parties or an external entity trusted with the correctness of execution is chosen as an ``aggregator''. Aggregator is not trusted with the privacy of the inputs. The aggregator receives the shares of the messages from all the parties and performs the steps of the single-prover protocol to be performed with the aggregated message. Also, a prover acting as an aggregator does not have an incentive to deviate from executing the correct protocol during this step. This is because she could have caused the protocol to abort in any of the previous steps, and there is no additional information that she gains in the intermediate steps that aids her deviation in the aggregation step.
%\end{itemize}
%\end{itemize}
%
%Starting with the single-prover protocol of \cite{ours}, we design custom protocols so that the only additional interaction between the parties during the second step involves MPC for $\intpartofC$ concurrent multiplications, where $\intpartofC$ is the number of wires in the \textit{interactive} part of the circuit. Consider the check $x+y \stackrel{?}{=} z$ when given their respective hashes. If the inputs are present with three different parties, the corresponding circuit for the hash check followed by the addition and equality check involves extensive local computations for the hash before the interaction happens. \dnote{self: Provide a compelling real world use-case here} The additional communication complexity of our $\DPZK$ protocol grows only with the size of the interactive part. To enable this, we do.... start with \cite{ours} --- arrange the rows accordingly in the witness matrix --- 
%
%proof size independent of number of parties --- Oracle queries outputs should be independent of the number of parties --- we do it having parties generate a homomorphic oracle starting with their shares on the extended witness --- we would achieve indistinguishability between proof generated in a distributed manner and the proof generated by a single party ---
%In this, we use homomorphic commitments --- we follow from \cite{ours} --- 


\input{Related_work.tex}
%Let $P$ be the predicate that is being proved. An aggregation of multiple proofs on the same $P$ produces a proof.  Let us consider the interactive version of the protocol. A proof consists of the messages sent by the prover to the verifier and, additionally in IOPs, the replies to the oracle queries of the verifier.
%where each message from the prover is first identified whether it is homomorphic or not. If 
%each prover can produce an additive share of the proof.  find a way to \textit{aggregate} the proof parts from each prover. identify the prover messages which are homomorphic.
%
%the goals that we set for our construction
%
%the theme that we will have - require every message from prover to verifier be homomorphic.
%
%concrete starting point - ligero --- 
