\section{Introduction} \label{sec:intro}
Applications of ZK proofs - mention those which naturally extend to multiple provers holding witness - think about applications both in the real-world setting, and also in crypto settings (eg. does our setting lead to more efficient MPC protocols?)\\

A typical zero-knowledge protocol...\\
In this work, we study the setting where the witness is present among multiple provers - secret shared / partitioned \\
Motivate by extending above use-cases\\
Create new use-cases which do not exist with single prover protocols?\\

What are our main selling points?\\
-- the notion of distributed proof generation (fine-tune it based on state-of-art? with concrete efficiency for general predicates)\\
-- single-prover protocol with ?? (what are the exact parameters we should highlight? concrete prover complexity, transparency)\\

Related work for the above mentioned claims\\

\dnote{CHECK: our protocol needs MPC in only one of the rounds among the log n rounds. How does it get better than others? }
\subsection{Overview}
--- Overview of our work: the notion, techniques.--- 
--- define the notion of distributed proof generation--- 
--- provide a protocol which satisfies these notions

\subsection*{Distributed proof generation}
--- Informal notion of Distributed Provers Zero Knowledge Protocol $\innp{\Pi}{\verifier}$--- 

A na\"ive approach to build a $\DPZK$ protocol is to take a single-prover ZK protocol and execute a multi-party computation among the provers of each message to be generated by the prover in the single-prover protocol. This satisfies the required security properties, but suffers in concrete efficiency when MPC is used over the proof generation as a black box. 

\subsubsection*{Need for homomorphic commitments} 
(Oracle access for IOP).
The (non-interactive) zero-knowledge proof generation protocols based on the Interactive oracle proofs (IOP) or the Interactive PCP (IPCP) paradigms make use of \textit{oracles}. The prover establishes an oracle based on her witness. Once established, the IOP/IPCP protocols ensure that a prover will not modify the oracle further in the protocol. The verifier queries the oracle later in the protocol to verify some the claims made by the prover. When IOP/IPCP based proof systems are converted into the non-interactive setting, the establishment of the oracle is done by producing a commitment to the oracle entries.

We will now run through a mental experiment on achieving distributed proof generation following the blueprint of the single-prover proof generation algorithm. We desire to not have the proof length depend on the number of parties. As we would discuss in depth later, we would also avoid running an MPC protocol on the proof generation circuit(s) of some zero-knowledge protocol. This would trivially, in theory, satisfy our goals, but it would be very inefficient in practice. The way we satisfy these goals for the establishment of the oracle is by requiring the oracle entries and their commitments satisfy homomorphic properties.
\dnote{self: Sounds somewhat weak. Make it more compelling.}

\subsection*{Technical summary}
We will now provide a high-level summary of our work and along the way mention our core ideas.

%Our contributions are two-fold: first in defining and constructing a zero-knowledge protocol with distributed proof generation and the second in proposing the first protocol with (expected) sub-linear verifier complexity.

Our main contribution is defining and constructinf a zero-knowledge protocol with distributed proof generation.

\paragraph{DPZK}
We design a framework for constructing DPZK protocols starting from a single-prover ZK protocol.
%To construct our DPZK protocol \name{} we follow the strategy of designing a (public coin honest verifier) single-prover ZK protocol whose proofs are ``aggregatable'' at minimal cost. 
Let the parties $\prover_1, \ldots, \prover_{\Num}$ hold their respective witnesses $\wit_1, \ldots, \wit_{\Num}$ to the relation $R(\stmt, (\wit_1, \ldots,\wit_{\Num}))$. 
Starting with a (public coin honest verifier) single-prover ZK protocol, there are two steps involved in our proof generation.
\begin{itemize}
\item The first step involves performing a secret sharing based MPC protocol on $R$ between the provers. As a result, each prover obtains her share of the extended witness, which includes all the wires (correspondingly variables) of a circuit (correspondingly R1CS) representation of R. 
\item Next, for each message from the prover to the verifier, the parties perform the following two steps:
\begin{itemize}
\item The parties run an MPC protocol to obtain their share of the message. This step has a major implication on the efficiency of distributed proof generation. Depending on the single-prover protocol, some messages already posses homomorphism properties. Hence, the output of a local run of the single-prover algorithm for this round on a prover's shares of extended witness is already her share of the message in the distributed proof generation. When the message is not homomorphic, we design custom efficient protocols to obtain the shares of the message.
\item One of the prover parties or an external entity trusted with the correctness of execution is chosen as an ``aggregator''. Aggregator is not trusted with the privacy of the inputs. The aggregator receives the shares of the messages from all the parties and performs the steps of the single-prover protocol to be performed with the aggregated message. Also, a prover acting as an aggregator does not have an incentive to deviate from executing the correct protocol during this step. This is because she could have caused the protocol to abort in any of the previous steps, and there is no additional information that she gains in the intermediate steps that aids her deviation in the aggregation step.
\end{itemize}
\end{itemize}

Starting with the single-prover protocol of \cite{ours}, we design custom protocols so that the only additional interaction between the parties during the second step involves MPC for $\intpartofC$ concurrent multiplications, where $\intpartofC$ is the number of wires in the \textit{interactive} part of the circuit. Consider the check $x+y \stackrel{?}{=} z$ when given their respective hashes. If the inputs are present with three different parties, the corresponding circuit for the hash check followed by the addition and equality check involves extensive local computations for the hash before the interaction happens. \dnote{self: Provide a compelling real world use-case here} The additional communication complexity of our $\DPZK$ protocol grows only with the size of the interactive part. To enable this, we do.... start with \cite{ours} --- arrange the rows accordingly in the witness matrix --- 

proof size independent of number of parties --- Oracle queries outputs should be independent of the number of parties --- we do it having parties generate a homomorphic oracle starting with their shares on the extended witness --- we would achieve indistinguishability between proof generated in a distributed manner and the proof generated by a single party ---
In this, we use homomorphic commitments --- we follow from \cite{ours} --- 


\input{Related_work.tex}

%Let $P$ be the predicate that is being proved. An aggregation of multiple proofs on the same $P$ produces a proof.  Let us consider the interactive version of the protocol. A proof consists of the messages sent by the prover to the verifier and, additionally in IOPs, the replies to the oracle queries of the verifier.
%where each message from the prover is first identified whether it is homomorphic or not. If 
%each prover can produce an additive share of the proof.  find a way to \textit{aggregate} the proof parts from each prover. identify the prover messages which are homomorphic.
%
%the goals that we set for our construction
%
%the theme that we will have - require every message from prover to verifier be homomorphic.
%
%concrete starting point - ligero --- 